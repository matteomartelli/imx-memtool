/*
 * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
 *
 * This is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this software; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 */

#include "memtools_register_info.h"

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark AIPSTZ
#endif

// Bitfields in register AIPSTZ_MPR.
static const field_t hw_aipstz_mpr[] =
{
    {
        "MPROT3",
        DESC("Master 3 Priviledge, Buffer, Read, Write Control.")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPROT1",
        DESC("Master 1 Priviledge, Buffer, Read, Write Control")
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPROT0",
        DESC("Master 0 Priviledge, Buffer, Read, Write Control")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AIPSTZ_OPACR.
static const field_t hw_aipstz_opacr[] =
{
    {
        "OPAC7",
        DESC("Off-platform Peripheral Access Control 7")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC6",
        DESC("Off-platform Peripheral Access Control 6")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC5",
        DESC("Off-platform Peripheral Access Control 5")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC4",
        DESC("Off-platform Peripheral Access Control 4")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC3",
        DESC("Off-platform Peripheral Access Control 3")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC2",
        DESC("Off-platform Peripheral Access Control 2")
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC1",
        DESC("Off-platform Peripheral Access Control 1")
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC0",
        DESC("Off-platform Peripheral Access Control 0")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AIPSTZ_OPACR1.
static const field_t hw_aipstz_opacr1[] =
{
    {
        "OPAC15",
        DESC("Off-platform Peripheral Access Control 15")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC14",
        DESC("Off-platform Peripheral Access Control 14")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC13",
        DESC("Off-platform Peripheral Access Control 13")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC12",
        DESC("Off-platform Peripheral Access Control 12")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC11",
        DESC("Off-platform Peripheral Access Control 11")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC10",
        DESC("Off-platform Peripheral Access Control 10")
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC9",
        DESC("Off-platform Peripheral Access Control 9")
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC8",
        DESC("Off-platform Peripheral Access Control 8")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AIPSTZ_OPACR2.
static const field_t hw_aipstz_opacr2[] =
{
    {
        "OPAC23",
        DESC("Off-platform Peripheral Access Control 23")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC22",
        DESC("Off-platform Peripheral Access Control 22")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC21",
        DESC("Off-platform Peripheral Access Control 21")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC20",
        DESC("Off-platform Peripheral Access Control 20")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC19",
        DESC("Off-platform Peripheral Access Control 19")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC18",
        DESC("Off-platform Peripheral Access Control 18")
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC17",
        DESC("Off-platform Peripheral Access Control 17")
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC16",
        DESC("Off-platform Peripheral Access Control 16")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AIPSTZ_OPACR3.
static const field_t hw_aipstz_opacr3[] =
{
    {
        "OPAC31",
        DESC("Off-platform Peripheral Access Control 31")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC30",
        DESC("Off-platform Peripheral Access Control 30")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC29",
        DESC("Off-platform Peripheral Access Control 29")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC28",
        DESC("Off-platform Peripheral Access Control 28")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC27",
        DESC("Off-platform Peripheral Access Control 27")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC26",
        DESC("Off-platform Peripheral Access Control 26")
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC25",
        DESC("Off-platform Peripheral Access Control 25")
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC24",
        DESC("Off-platform Peripheral Access Control 24")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AIPSTZ_OPACR4.
static const field_t hw_aipstz_opacr4[] =
{
    {
        "OPAC33",
        DESC("Off-platform Peripheral Access Control 33")
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPAC32",
        DESC("Off-platform Peripheral Access Control 32")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a AIPSTZ module.
static const reg_t hw_aipstz[] =
{
    {
        "MPR",
        DESC("Each AIPSTZ_MPR specifies 16 4-bit fields defining the access privileg"
        "e level associated with a bus master in the platform, as well as speci"
        "fying whether write accesses from this master are bufferable shown in "
        " The registers provide one field per bus master, where field 15 corres"
        "ponds to master 15, field 14 to master 14,...")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_aipstz_mpr
    },
    {
        "OPACR",
        DESC("Each of the off-platform peripherals have an Off-platform Peripheral A"
        "ccess Control Register (AIPSTZ_OPACR) which defines the access levels "
        "supported by the given block.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_aipstz_opacr
    },
    {
        "OPACR1",
        DESC("Each of the off-platform peripherals have an Off-platform Peripheral A"
        "ccess Control Register (AIPSTZ_OPACR) which defines the access levels "
        "supported by the given block.")
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_aipstz_opacr1
    },
    {
        "OPACR2",
        DESC("Each of the off-platform peripherals have an Off-platform Peripheral A"
        "ccess Control Register (AIPSTZ_OPACR) which defines the access levels "
        "supported by the given block.")
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_aipstz_opacr2
    },
    {
        "OPACR3",
        DESC("Each of the off-platform peripherals have an Off-platform Peripheral A"
        "ccess Control Register (AIPSTZ_OPACR) which defines the access levels "
        "supported by the given block.")
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_aipstz_opacr3
    },
    {
        "OPACR4",
        DESC("Each of the off-platform peripherals have an Off-platform Peripheral A"
        "ccess Control Register (AIPSTZ_OPACR) which defines the access levels "
        "supported by the given block.")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_aipstz_opacr4
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ARMGLOBALTIMER
#endif

// Bitfields in register ARMGLOBALTIMER_COUNTER0.
static const field_t hw_armglobaltimer_counter0[] =
{
    {
        "VALUE",
        DESC("32-bits of the counter value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ARMGLOBALTIMER_COUNTER1.
static const field_t hw_armglobaltimer_counter1[] =
{
    {
        "VALUE",
        DESC("32-bits of the counter value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ARMGLOBALTIMER_CONTROL.
static const field_t hw_armglobaltimer_control[] =
{
    {
        "TIMER_ENABLE",
        DESC("Timer enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMP_ENABLE",
        DESC("This bit is banked per Cortex-A9 processor.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ENABLE",
        DESC("This bit is banked per Cortex-A9 processor.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_INCREMENT",
        DESC("This bit is banked per Cortex-A9 processor.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALER",
        DESC("The prescaler modifies the clock period for the decrementing event for"
        " the Counter Register.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ARMGLOBALTIMER_IRQSTATUS.
static const field_t hw_armglobaltimer_irqstatus[] =
{
    {
        "EVENT_FLAG",
        DESC("The event flag is a sticky bit that is automatically set when the Coun"
        "ter Register reaches the Comparator Register value.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ARMGLOBALTIMER_COMPARATOR0.
static const field_t hw_armglobaltimer_comparator0[] =
{
    {
        "VALUE",
        DESC("32-bits of the comparator value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ARMGLOBALTIMER_COMPARATOR1.
static const field_t hw_armglobaltimer_comparator1[] =
{
    {
        "VALUE",
        DESC("32-bits of the comparator value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ARMGLOBALTIMER_AUTOINCREMENT.
static const field_t hw_armglobaltimer_autoincrement[] =
{
    {
        "VALUE",
        DESC("32-bit auto-increment value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ARMGLOBALTIMER module.
static const reg_t hw_armglobaltimer[] =
{
    {
        "COUNTER0",
        DESC("There are two timer counter registers.")
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_armglobaltimer_counter0
    },
    {
        "COUNTER1",
        DESC("There are two timer counter registers.")
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_armglobaltimer_counter1
    },
    {
        "CONTROL",
        DESC("Configuration and control of the Global Timer.")
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_armglobaltimer_control
    },
    {
        "IRQSTATUS",
        DESC("This is a banked register for all Cortex-A9 processors present.")
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_armglobaltimer_irqstatus
    },
    {
        "COMPARATOR0",
        DESC("There are two timer counter registers.")
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_armglobaltimer_comparator0
    },
    {
        "COMPARATOR1",
        DESC("There are two timer counter registers.")
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_armglobaltimer_comparator1
    },
    {
        "AUTOINCREMENT",
        DESC("This 32-bit register gives the increment value of the Comparator Regis"
        "ter when the Auto-increment bit is set in the Timer Control Register.")
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_armglobaltimer_autoincrement
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark AUDMUX
#endif

// Bitfields in register AUDMUX_PTCR1.
static const field_t hw_audmux_ptcr1[] =
{
    {
        "SYN",
        DESC("Synchronous/Asynchronous Select.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        DESC("Receive Clock Select.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        DESC("Receive Clock Direction Control.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        DESC("Receive Frame Sync Select.")
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        DESC("Receive Frame Sync Direction Control.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        DESC("Transmit Clock Select.")
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        DESC("Transmit Clock Direction Control.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        DESC("Transmit Frame Sync Select.")
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        DESC("Transmit Frame Sync Direction Control.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR1.
static const field_t hw_audmux_pdcr1[] =
{
    {
        "INMMASK",
        DESC("Internal Network Mode Mask.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        DESC("Mode Select.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        DESC("Transmit/Receive Switch Enable.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        DESC("Receive Data Select.")
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR2.
static const field_t hw_audmux_ptcr2[] =
{
    {
        "SYN",
        DESC("Synchronous/Asynchronous Select.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        DESC("Receive Clock Select.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        DESC("Receive Clock Direction Control.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        DESC("Receive Frame Sync Select.")
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        DESC("Receive Frame Sync Direction Control.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        DESC("Transmit Clock Select.")
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        DESC("Transmit Clock Direction Control.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        DESC("Transmit Frame Sync Select.")
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        DESC("Transmit Frame Sync Direction Control.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR2.
static const field_t hw_audmux_pdcr2[] =
{
    {
        "INMMASK",
        DESC("Internal Network Mode Mask.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        DESC("Mode Select.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        DESC("Transmit/Receive Switch Enable.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        DESC("Receive Data Select.")
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR3.
static const field_t hw_audmux_ptcr3[] =
{
    {
        "SYN",
        DESC("Synchronous/Asynchronous Select.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        DESC("Receive Clock Select.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        DESC("Receive Clock Direction Control.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        DESC("Receive Frame Sync Select.")
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        DESC("Receive Frame Sync Direction Control.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        DESC("Transmit Clock Select.")
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        DESC("Transmit Clock Direction Control.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        DESC("Transmit Frame Sync Select.")
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        DESC("Transmit Frame Sync Direction Control.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR3.
static const field_t hw_audmux_pdcr3[] =
{
    {
        "INMMASK",
        DESC("Internal Network Mode Mask.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        DESC("Mode Select.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        DESC("Transmit/Receive Switch Enable.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        DESC("Receive Data Select.")
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR4.
static const field_t hw_audmux_ptcr4[] =
{
    {
        "SYN",
        DESC("Synchronous/Asynchronous Select.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        DESC("Receive Clock Select.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        DESC("Receive Clock Direction Control.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        DESC("Receive Frame Sync Select.")
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        DESC("Receive Frame Sync Direction Control.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        DESC("Transmit Clock Select.")
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        DESC("Transmit Clock Direction Control.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        DESC("Transmit Frame Sync Select.")
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        DESC("Transmit Frame Sync Direction Control.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR4.
static const field_t hw_audmux_pdcr4[] =
{
    {
        "INMMASK",
        DESC("Internal Network Mode Mask.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        DESC("Mode Select.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        DESC("Transmit/Receive Switch Enable.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        DESC("Receive Data Select.")
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR5.
static const field_t hw_audmux_ptcr5[] =
{
    {
        "SYN",
        DESC("Synchronous/Asynchronous Select.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        DESC("Receive Clock Select.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        DESC("Receive Clock Direction Control.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        DESC("Receive Frame Sync Select.")
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        DESC("Receive Frame Sync Direction Control.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        DESC("Transmit Clock Select.")
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        DESC("Transmit Clock Direction Control.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        DESC("Transmit Frame Sync Select.")
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        DESC("Transmit Frame Sync Direction Control.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR5.
static const field_t hw_audmux_pdcr5[] =
{
    {
        "INMMASK",
        DESC("Internal Network Mode Mask.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        DESC("Mode Select.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        DESC("Transmit/Receive Switch Enable.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        DESC("Receive Data Select.")
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR6.
static const field_t hw_audmux_ptcr6[] =
{
    {
        "SYN",
        DESC("Synchronous/Asynchronous Select.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        DESC("Receive Clock Select.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        DESC("Receive Clock Direction Control.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        DESC("Receive Frame Sync Select.")
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        DESC("Receive Frame Sync Direction Control.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        DESC("Transmit Clock Select.")
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        DESC("Transmit Clock Direction Control.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        DESC("Transmit Frame Sync Select.")
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        DESC("Transmit Frame Sync Direction Control.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR6.
static const field_t hw_audmux_pdcr6[] =
{
    {
        "INMMASK",
        DESC("Internal Network Mode Mask.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        DESC("Mode Select.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        DESC("Transmit/Receive Switch Enable.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        DESC("Receive Data Select.")
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PTCR7.
static const field_t hw_audmux_ptcr7[] =
{
    {
        "SYN",
        DESC("Synchronous/Asynchronous Select.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSEL",
        DESC("Receive Clock Select.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCLKDIR",
        DESC("Receive Clock Direction Control.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSEL",
        DESC("Receive Frame Sync Select.")
        17, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFS_DIR",
        DESC("Receive Frame Sync Direction Control.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEL",
        DESC("Transmit Clock Select.")
        22, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCLKDIR",
        DESC("Transmit Clock Direction Control.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSEL",
        DESC("Transmit Frame Sync Select.")
        27, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFS_DIR",
        DESC("Transmit Frame Sync Direction Control.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register AUDMUX_PDCR7.
static const field_t hw_audmux_pdcr7[] =
{
    {
        "INMMASK",
        DESC("Internal Network Mode Mask.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        DESC("Mode Select.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRXEN",
        DESC("Transmit/Receive Switch Enable.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEL",
        DESC("Receive Data Select.")
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a AUDMUX module.
static const reg_t hw_audmux[] =
{
    {
        "PTCR1",
        DESC("PTCR1 is the Port Timing Control Register for Port 1.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr1
    },
    {
        "PDCR1",
        DESC("PDCR1 is the Port Data Control Register for Port 1.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr1
    },
    {
        "PTCR2",
        DESC("PTCR2 is the Port Timing Control Register for Port 2.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr2
    },
    {
        "PDCR2",
        DESC("PDCR2 is the Port Data Control Register for Port 2.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr2
    },
    {
        "PTCR3",
        DESC("PTCR3 is the Port Timing Control Register for Port 3.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr3
    },
    {
        "PDCR3",
        DESC("PDCR3 is the Port Data Control Register for Port 3.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr3
    },
    {
        "PTCR4",
        DESC("Port Timing Control Register for Port 4")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr4
    },
    {
        "PDCR4",
        DESC("PDCR4 is the Port Data Control Register for Port 4.")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr4
    },
    {
        "PTCR5",
        DESC("Port Timing Control Register for Port 5")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr5
    },
    {
        "PDCR5",
        DESC("PDCR5 is the Port Data Control Register for Port 5.")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr5
    },
    {
        "PTCR6",
        DESC("Port Timing Control Register for Port 6")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr6
    },
    {
        "PDCR6",
        DESC("PDCR6 is the Port Data Control Register for Port 6.")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr6
    },
    {
        "PTCR7",
        DESC("Port Timing Control Register for Port 7")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_audmux_ptcr7
    },
    {
        "PDCR7",
        DESC("PDCR7 is the Port Data Control Register for Port 7 .")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_audmux_pdcr7
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CCM
#endif

// Bitfields in register CCM_CCR.
static const field_t hw_ccm_ccr[] =
{
    {
        "OSCNT",
        DESC("Oscillator ready counter value.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COSC_EN",
        DESC("On chip oscillator enable bit - this bit value is reflected on the out"
        "put cosc_en.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WB_COUNT",
        DESC("Well Bias counter.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG_BYPASS_COUNT",
        DESC("Counter for analog_reg_bypass signal assertion after standby voltage r"
        "equest by pmic_vstby_req.")
        21, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBC_EN",
        DESC("Enable for REG_BYPASS_COUNTER.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCDR.
static const field_t hw_ccm_ccdr[] =
{
    {
        "MMDC_ROOT_MASK",
        DESC("During divider ratio mmdc_root_axi_podf change or sync mux periph2_clk"
        "_sel change (but not jtag) or SRC request during warm reset, mask hand"
        "shake with mmdc_root module.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_CH0_MASK",
        DESC("During divider ratio mmdc_ch0_axi_podf change or sync mux periph_clk_s"
        "el change (but not jtag) or SRC request during warm reset, mask handsh"
        "ake with mmdc_ch0 module.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSR.
static const field_t hw_ccm_csr[] =
{
    {
        "REF_EN_B",
        DESC("Status of the value of ref_en_b output of ccm")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COSC_READY",
        DESC("Status indication of on board oscillator.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCSR.
static const field_t hw_ccm_ccsr[] =
{
    {
        "PLL3_SW_CLK_SEL",
        DESC("Selects source to generate pll3_sw_clk.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL2_SW_CLK_SEL",
        DESC("Selects source to generate pll2_sw_clk.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL1_SW_CLK_SEL",
        DESC("Selects source to generate pll1_sw_clk.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STEP_SEL",
        DESC("Selects the option to be chosen for the step frequency when shifting A"
        "RM frequency.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_396M_DIS_MASK",
        DESC("Mask of 396M PFD auto-disable.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_352M_DIS_MASK",
        DESC("Mask of 352M PFD auto-disable.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_594M_DIS_MASK",
        DESC("Mask of 594M PFD auto-disable.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_508M_DIS_MASK",
        DESC("Mask of 508M PFD auto-disable.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_454M_DIS_MASK",
        DESC("Mask of 454M PFD auto-disable.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_720M_DIS_MASK",
        DESC("Mask of 720M PFD auto-disable.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDF_540M_DIS_MASK",
        DESC("Mask of 540M PFD auto-disable.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CACRR.
static const field_t hw_ccm_cacrr[] =
{
    {
        "ARM_PODF",
        DESC("Divider for ARM clock root.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CBCDR.
static const field_t hw_ccm_cbcdr[] =
{
    {
        "PERIPH2_CLK2_PODF",
        DESC("Divider for periph2_clk2 podf.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FABRIC_MMDC_PODF",
        DESC("Post divider for fabric_mmdc clock.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_CLK_SEL",
        DESC("OCRAM clock source select")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_ALT_CLK_SEL",
        DESC("OCRAM alternative clock select")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPG_PODF",
        DESC("Divider for ipg podf.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_PODF",
        DESC("Divider for ahb podf.")
        10, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_PODF",
        DESC("Post divider for ocram clock.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK_SEL",
        DESC("Selector for peripheral main clock (source of mmdc_ch0_axi_clk_root).")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH2_CLK_SEL",
        DESC("Selector for peripheral2 main clock (source of mmdc_root_axi_clk_root "
        ").")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK2_PODF",
        DESC("Divider for periph2 clock podf.")
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CBCMR.
static const field_t hw_ccm_cbcmr[] =
{
    {
        "GPU2D_OVG_CORE_CLK_SEL",
        DESC("Selector for gpu2d_ovg_core clock multiplexer")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU2D_CORE_CLK_SEL",
        DESC("Selector for gpu2d_core clock multiplexer")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VDOAXI_CLK_SEL",
        DESC("Selector for vdoaxi clock multiplexer")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK2_SEL",
        DESC("Selector for peripheral clk2 clock multiplexer")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRE_PERIPH_CLK_SEL",
        DESC("Selector for pre_periph clock multiplexer")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH2_CLK2_SEL",
        DESC("Selector for periph2_clk2 clock multiplexer")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRE_PERIPH2_CLK_SEL",
        DESC("Selector for pre_periph2 clock multiplexer")
        21, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_PIX_PODF",
        DESC("Post divider for EPDC_PIX.")
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU2D_OVG_CORE_PODF",
        DESC("Divider for gpu3d_core clock.")
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU2D_CORE_PODF",
        DESC("Post divider for gpu2d_core clock.")
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCMR1.
static const field_t hw_ccm_cscmr1[] =
{
    {
        "PERCLK_PODF",
        DESC("Divider for perclk podf.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERCLK_CLK_SEL",
        DESC("Selector for the perclk clock multiplexor")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI1_CLK_SEL",
        DESC("Selector for ssi1 clock multiplexer")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI2_CLK_SEL",
        DESC("Selector for ssi2 clock multiplexer")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI3_CLK_SEL",
        DESC("Selector for ssi3 clock multiplexer")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC1_CLK_SEL",
        DESC("Selector for usdhc1 clock multiplexer")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC2_CLK_SEL",
        DESC("Selector for usdhc2 clock multiplexer")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC3_CLK_SEL",
        DESC("Selector for usdhc3 clock multiplexer")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC4_CLK_SEL",
        DESC("Selector for usdhc4 clock multiplexer")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_PIX_PODF",
        DESC("Post divider for LCDIF_PIX.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EMI_SLOW_PODF",
        DESC("Divider for aclk_emi_slow clock root.")
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EMI_SLOW_SEL",
        DESC("Selector for aclk_emi_slow root clock multiplexer")
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCMR2.
static const field_t hw_ccm_cscmr2[] =
{
    {
        "EXTERN_AUDIO_CLK_SEL",
        DESC("Selector for external audio clock multiplexer")
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCDR1.
static const field_t hw_ccm_cscdr1[] =
{
    {
        "UART_CLK_PODF",
        DESC("Divider for uart clock podf.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UART_CLK_SEL",
        DESC("Selector for the UART clock multiplexor")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC1_PODF",
        DESC("Divider for usdhc1 clock podf.")
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC2_PODF",
        DESC("Divider for usdhc2 clock.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC3_PODF",
        DESC("Divider for usdhc3 clock podf.")
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC4_PODF",
        DESC("Divider for esdhc4 clock pred.")
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CS1CDR.
static const field_t hw_ccm_cs1cdr[] =
{
    {
        "SSI1_CLK_PODF",
        DESC("Divider for ssi1 clock podf.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI1_CLK_PRED",
        DESC("Divider for ssi1 clock pred.")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTERN_AUDIO_CLK_PRED",
        DESC("Divider for external audio clock pred.")
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI3_CLK_PODF",
        DESC("Divider for ssi3 clock podf.")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI3_CLK_PRED",
        DESC("Divider for ssi3 clock pred.")
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTERN_AUDIO_CLK_PODF",
        DESC("Divider for external audio clock podf.")
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CS2CDR.
static const field_t hw_ccm_cs2cdr[] =
{
    {
        "SSI2_CLK_PODF",
        DESC("Divider for ssi2 clock podf.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSI2_CLK_PRED",
        DESC("Divider for ssi2 clock pred.")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI0_CLK_SEL",
        DESC("Selector for ldb_di1 clock multiplexer")
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI1_CLK_SEL",
        DESC("Selector for ldb_di1 clock multiplexer")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CDCDR.
static const field_t hw_ccm_cdcdr[] =
{
    {
        "SPDIF1_CLK_SEL",
        DESC("Selector for spdif1 clock multiplexer")
        7, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF1_CLK_PODF",
        DESC("Divider for spdif1 clock podf.")
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF1_CLK_PRED",
        DESC("Divider for spdif1 clock pred.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF0_CLK_SEL",
        DESC("Selector for spdif0 clock multiplexer")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF0_CLK_PODF",
        DESC("Divider for spdif0 clock podf.")
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF0_CLK_PRED",
        DESC("Divider for spdif0 clock pred.")
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CHSCCDR.
static const field_t hw_ccm_chsccdr[] =
{
    {
        "PXP_AXI_PODF",
        DESC("Divider for pxp_axi clock divider.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_AXI_CLK_SEL",
        DESC("Selector for pxp_axi root clock multiplexer")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_AXI_PODF",
        DESC("Divider for epdc_axi (SiPix) clock divider.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_AXI_CLK_SEL",
        DESC("Selector for epdc_axi (SiPix) root clock multiplexer")
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCDR2.
static const field_t hw_ccm_cscdr2[] =
{
    {
        "LCDIF_PIX_PRED",
        DESC("Divider for lcdif_pix clock divider.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_PIX_CLK_SEL",
        DESC("Selector for lcdif_pix root clock multiplexer")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_PIX_PRED",
        DESC("Divider for epdc_pix clock divider.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_PIX_CLK_SEL",
        DESC("Selector for epdc_pix root clock pre-multiplexer")
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECSPI_CLK_SEL",
        DESC("Selector for the ECSPI clock multiplexor")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECSPI_CLK_PODF",
        DESC("Divider for ecspi clock podf.")
        19, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCDR3.
static const field_t hw_ccm_cscdr3[] =
{
    {
        "CSI_CORE_CLK_SEL",
        DESC("Selector for csi_core clock multiplexer")
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_CORE_PODF",
        DESC("Post divider for csi_core clock.")
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_AXI_CLK_SEL",
        DESC("Selector for lcdif_axi clock multiplexer")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_AXI_PODF",
        DESC("Divider for lcdif_axi clock.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CWDR.
static const field_t hw_ccm_cwdr[] =
{
    { 0 } // Terminator
};

// Bitfields in register CCM_CDHIPR.
static const field_t hw_ccm_cdhipr[] =
{
    {
        "AXI_PODF_BUSY",
        DESC("Busy indicator for axi_podf.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB_PODF_BUSY",
        DESC("Busy indicator for ahb_podf.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MMDC_ROOT_PODF_BUSY",
        DESC("Busy indicator for mmdc_root_axi_podf.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PERIPH2_CLK_SEL_BUSY",
        DESC("Busy indicator for periph2_clk_sel mux control.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MMDC_CH0_PODF_BUSY",
        DESC("Busy indicator for mmdc_ch0_axi_podf.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PERIPH_CLK_SEL_BUSY",
        DESC("Busy indicator for periph_clk_sel mux control.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ARM_PODF_BUSY",
        DESC("Busy indicator for arm_podf.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CTOR.
static const field_t hw_ccm_ctor[] =
{
    {
        "OBS_SPARE_OUTPUT_2_SEL",
        DESC("Selection of the signal to be generated on obs_output_2 (output of CCM"
        ") for observability on the pads.")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBS_SPARE_OUTPUT_1_SEL",
        DESC("Selection of the signal to be generated on obs_output_1 (output of CCM"
        ") for observability on the pads.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBS_SPARE_OUTPUT_0_SEL",
        DESC("Selection of the signal to be generated on obs_output_0 (output of CCM"
        ") for observability on the pads.")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBS_EN",
        DESC("observability enable bit.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CLPCR.
static const field_t hw_ccm_clpcr[] =
{
    {
        "LPM",
        DESC("Setting the low power mode that system will enter on next assertion of"
        " dsm_request signal.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_PMIC_VFUNCTIONAL_READY",
        DESC("By asserting this bit CCM will bypass waiting for pmic_vfunctional_rea"
        "dy signal when coming out of STOP mode.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARM_CLK_DIS_ON_LPM",
        DESC("Define if ARM clocks (arm_clk, soc_mxclk, soc_pclk, soc_dbg_pclk, vl_w"
        "rck) will be disabled on wait mode.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBYOS",
        DESC("Standby clock oscillator bit.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS_REF_OSC",
        DESC("dis_ref_osc - in run mode, software can manually control closing of ex"
        "ternal reference oscillator clock, i.e.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSTBY",
        DESC("Voltage standby request bit.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STBY_COUNT",
        DESC("Standby counter definition.")
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COSC_PWRDOWN",
        DESC("In run mode, software can manually control powering down of on chip os"
        "cillator, i.e.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WB_PER_AT_LPM",
        DESC("Enable periphery charge pump for well biasing at low power mode (stop "
        "or wait)")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_MMDC_CH0_LPM_HS",
        DESC("Bypass handshake with mmdc_ch0 on next entrance to low power mode (wai"
        "t or stop mode).")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_MMDC_ROOT_LPM_HS",
        DESC("Bypass handshake with mmdc_root on next entrance to low power mode (wa"
        "it or stop mode).")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CORE0_WFI",
        DESC("Mask WFI of core0 for entering low power mode  Note: assertion of all "
        "bits[27:22] will generate low power mode request")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_SCU_IDLE",
        DESC("Mask SCU IDLE for entering low power mode  Note: assertion of all bits"
        "[27:22] will generate low power mode request")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_L2CC_IDLE",
        DESC("Mask L2CC IDLE for entering low power mode.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CISR.
static const field_t hw_ccm_cisr[] =
{
    {
        "LRF_PLL",
        DESC("Interrupt ipi_int_2 generated due to lock of all enabled and not bypas"
        "eed pll's")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COSC_READY",
        DESC("Interrupt ipi_int_2 generated due to on board oscillator ready, i.e.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_PODF_LOADED",
        DESC("Interrupt ipi_int_1 generated due to frequency change of axi_a_podf")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_B_PODF_LOADED",
        DESC("Interrupt ipi_int_1 generated due to frequency change of axi_b_podf")
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PERIPH2_CLK_SEL_LOADED",
        DESC("Interrupt ipi_int_1 generated due to frequency change of periph2_clk_s"
        "el")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_PODF_LOADED",
        DESC("Interrupt ipi_int_1 generated due to frequency change of ahb_podf")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_ROOT_PODF_LOADED",
        DESC("Interrupt ipi_int_1 generated due to frequency change of mmdc_ch0_podf"
        "_ loaded")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK_SEL_LOADED",
        DESC("Interrupt ipi_int_1 generated due to update of periph_clk_sel.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_CH0_PODF_LOADED",
        DESC("Interrupt ipi_int_1 generated due to update of mmdc_ch0_axi_podf.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARM_PODF_LOADED",
        DESC("Interrupt ipi_int_1 generated due to frequency change of arm_podf.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CIMR.
static const field_t hw_ccm_cimr[] =
{
    {
        "MASK_LRF_PLL",
        DESC("mask interrupt generation due to lrf of pll's")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_COSC_READY",
        DESC("mask interrupt generation due to on board oscillator ready")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_AXI_PODF_LOADED",
        DESC("mask interrupt generation due to frequency change of axi_podf")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_AXI_B_PODF_LOADED",
        DESC("mask interrupt generation due to frequency change of axi_b_podf")
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MASK_PERIPH2_CLK_SEL_LOADED",
        DESC("mask interrupt generation due to update of periph2_clk_sel.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_AHB_PODF_LOADED",
        DESC("mask interrupt generation due to frequency change of ahb_podf")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_MMDC_ROOT_PODF_LOADED",
        DESC("mask interrupt generation due to update of mask_mmdc_root_podf")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PERIPH_CLK_SEL_LOADED",
        DESC("mask interrupt generation due to update of periph_clk_sel.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_MMDC_CH0_PODF_LOADED",
        DESC("mask interrupt generation due to update of mask_mmdc_ch0_podf")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARM_PODF_LOADED",
        DESC("mask interrupt generation due to frequency change of arm_podf")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCOSR.
static const field_t hw_ccm_ccosr[] =
{
    {
        "CLKO1_SEL",
        DESC("Selection of the clock to be generated on clko1")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO1_DIV",
        DESC("Setting the divider of CLKO1")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO1_EN",
        DESC("Enable of CLKO1 clock")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO1_CLKO2_SEL",
        DESC("CLKO1 output to reflect clko1 or clko2 clocks")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO2_SEL",
        DESC("Selection of the clock to be generated on clko2")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO2_DIV",
        DESC("Setting the divider of CLKO2")
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO2_EN",
        DESC("Enable of CLKO2 clock")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CGPR.
static const field_t hw_ccm_cgpr[] =
{
    {
        "PMIC_DELAY_SCALER",
        DESC("Defines clock dividion of clock for stby_count (pmic delay counter)")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEM_IGP_STOP_MASK",
        DESC("Clear this bit to disallow putting the ARM cache into low power mode.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_EXT_CLK_DIS",
        DESC("Disable external clock driver of MMDC during STOP mode")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EFUSE_PROG_SUPPLY_GATE",
        DESC("Defines the value of the output signal cgpr_dout[4].")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPL",
        DESC("")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR0.
static const field_t hw_ccm_ccgr0[] =
{
    {
        "CG0",
        DESC("aips_tz1 clocks (aips_tz1_clk_enable)")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        DESC("aips_tz2 clocks (aips_tz2_clk_enable)")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        DESC("Reserved")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        DESC("Reserved")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        DESC("Reserved")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        DESC("Reserved")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        DESC("Reserved")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        DESC("Reserved")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        DESC("Reserved")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        DESC("Reserved")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        DESC("Reserved")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        DESC("CPU debug clocks (cheetah_dbg_clk_enable)")
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        DESC("Reserved")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        DESC("Reserved")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        DESC("Reserved")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        DESC("Reserved")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR1.
static const field_t hw_ccm_ccgr1[] =
{
    {
        "CG0",
        DESC("ecspi1 clocks (ecspi1_clk_enable)")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        DESC("ecspi2 clocks (ecspi2_clk_enable)")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        DESC("ecspi3 clocks (ecspi3_clk_enable)")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        DESC("ecspi4 clocks (ecspi4_clk_enable)")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        DESC("Reserved")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        DESC("Reserved")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        DESC("epit1 clocks (epit1_clk_enable)")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        DESC("epit2 clocks (epit2_clk_enable)")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        DESC("esai clocks (extern_audio_clk_enable)")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        DESC("Reserved")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        DESC("gpt bus clock (gpt_clk_enable)")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        DESC("gpt serial clock (gpt_serial_clk_enable)")
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        DESC("Reserved")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        DESC("gpu2d ovg clock (gpu2d_ovg_core_clk_enable)")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        DESC("Reserved")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        DESC("Reserved")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR2.
static const field_t hw_ccm_ccgr2[] =
{
    {
        "CG0",
        DESC("Reserved")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        DESC("Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        DESC("Reserved")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        DESC("i2c1_serial clock (i2c1_serial_clk_enable)")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        DESC("i2c2_serial clock (i2c2_serial_clk_enable)")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        DESC("i2c3_serial clock (i2c3_serial_clk_enable)")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        DESC("OCOTP_CTRL clock (iim_clk_enable)")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        DESC("iomux_ipt_clk_io clock (iomux_ipt_clk_io_enable)")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        DESC("ipmux1 clock (ipmux1_clk_enable)")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        DESC("ipmux2 clock (ipmux2_clk_enable)")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        DESC("ipmux3 clock (ipmux3_clk_enable)")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        DESC("ipsync_ip2apb_tzasc1_ipg clocks (ipsync_ip2apb_tzasc1_ipg_master_clk_e"
        "nable)")
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        DESC("Reserved")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        DESC("ipsync_vdoa_ipg clocks (ipsync_vdoa_ipg_master_clk_enable)")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        DESC("Reserved")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        DESC("Reserved")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR3.
static const field_t hw_ccm_ccgr3[] =
{
    {
        "CG0",
        DESC("csi core clock (csi_core_clk_enable)")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        DESC("pxp axi clock (pxp_axi_clk_enable)")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        DESC("epdc axi clock (epdc_axi_clk_enable)")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        DESC("lcdif axi clock (lcdif_axi_clk_enable)")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        DESC("ipu2_ipu_di0 clock (ipu2_ipu_di0_clk_enable)  lcdif_pix clock (lcdif_p"
        "ix_clk_enable)")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        DESC("epdc_pix clock (epdc_pix_clk_enable)")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        DESC("Reserved")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        DESC("Reserved")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        DESC("Reserved")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        DESC("Reserved")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        DESC("mmdc_core_aclk_fast_core_p0 clock (mmdc_core_aclk_fast_core_p0_enable)")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        DESC("Reserved")
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        DESC("mmdc_core_ipg_clk_p0 clock (mmdc_core_ipg_clk_p0_enable)")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        DESC("mmdc_core_ipg_clk_p1 clock (mmdc_core_ipg_clk_p1_enable)")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        DESC("ocram clock (ocram_clk_enable)")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        DESC("Reserved")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR4.
static const field_t hw_ccm_ccgr4[] =
{
    {
        "CG0",
        DESC("Reserved")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        DESC("Reserved.")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        DESC("Reserved.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        DESC("Reserved.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        DESC("pl301_mx6qfast1_s133 clock (pl301_mx6qfast1_s133clk_enable)")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        DESC("Reserved")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        DESC("Reserved")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        DESC("pl301_mx6qper2_mainclk_enable (pl301_mx6qper2_mainclk_enable)")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        DESC("pwm1 clocks (pwm1_clk_enable)")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        DESC("pwm2 clocks (pwm2_clk_enable)")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        DESC("pwm3 clocks (pwm3_clk_enable)")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        DESC("pwm4 clocks (pwm4_clk_enable)")
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        DESC("rawnand_u_bch_input_apb clock (rawnand_u_bch_input_apb_clk_enable)")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        DESC("rawnand_u_gpmi_bch_input_bch clock (rawnand_u_gpmi_bch_input_bch_clk_e"
        "nable)")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        DESC("rawnand_u_gpmi_bch_input_gpmi_io clock (rawnand_u_gpmi_bch_input_gpmi_"
        "io_clk_enable)")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        DESC("rawnand_u_gpmi_input_apb clock rawnand_u_gpmi_input_apb_clk_enable)")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR5.
static const field_t hw_ccm_ccgr5[] =
{
    {
        "CG0",
        DESC("rom clock (rom_clk_enable)")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        DESC("Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        DESC("100M clock (100M_clk_enable)")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        DESC("sdma clock (sdma_clk_enable)")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        DESC("Reserved")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        DESC("Reserved")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        DESC("spba clock (spba_clk_enable)")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        DESC("spdif clock (spdif_clk_enable)")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        DESC("Reserved")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        DESC("ssi1 clocks (ssi1_clk_enable)")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        DESC("ssi2 clocks (ssi2_clk_enable)")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        DESC("ssi3 clocks (ssi3_clk_enable)")
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        DESC("uart clock (uart_clk_enable)")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        DESC("uart_serial clock (uart_serial_clk_enable)")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        DESC("Reserved")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        DESC("Reserved")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR6.
static const field_t hw_ccm_ccgr6[] =
{
    {
        "CG0",
        DESC("usboh3 clock (usboh3_clk_enable)")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        DESC("usdhc1 clocks (usdhc1_clk_enable)")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        DESC("usdhc2 clocks (usdhc2_clk_enable)")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        DESC("usdhc3 clocks (usdhc3_clk_enable)")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        DESC("usdhc4 clocks (usdhc4_clk_enable)")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        DESC("emi_slow clocks (emi_slow_clk_enable)")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        DESC("vdoaxiclk root clock (vdoaxiclk_clk_enable)")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        DESC("vpu clocks (vpu_clk_enable)")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        DESC("Reserved")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        DESC("Reserved")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        DESC("Reserved")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        DESC("Reserved")
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        DESC("Reserved")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        DESC("Reserved")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        DESC("Reserved")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        DESC("Reserved")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CMEOR.
static const field_t hw_ccm_cmeor[] =
{
    {
        "MOD_EN_OV_VDOA",
        DESC("overide clock enable signal from vdoa - clock will not be gated based "
        "on vdoa signal.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_GPT",
        DESC("overide clock enable signal from gpt - clock will not be gated based o"
        "n gpt's signal 'ipg_enable_clk' .")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_EPIT",
        DESC("overide clock enable signal from epit - clock will not be gated based "
        "on epit's signal 'ipg_enable_clk' .")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_USDHC",
        DESC("overide clock enable signal from usdhc.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_DAP",
        DESC("overide clock enable signal from dap- clock will not be gated based on"
        " dap's signal 'dap_dbgen' .")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_VPU",
        DESC("overide clock enable signal from vpu- clock will not be gated based on"
        " vpu's signal 'vpu_idle' .")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_GPU2D",
        DESC("overide clock enable signal from gpu2d - clock will not be gated based"
        " on gpu2d's signal 'gpu2d_busy' .")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_GPU3D",
        DESC("overide clock enable signal from gpu3d - clock will not be gated based"
        " on gpu3d's signal.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_CAN2_CPI",
        DESC("overide clock enable signal from can2 - clock will not be gated based "
        "on can's signal 'enable_clk_cpi'.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_CAN1_CPI",
        DESC("overide clock enable signal from can1 - clock will not be gated based "
        "on can's signal 'enable_clk_cpi'.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CCM module.
static const reg_t hw_ccm[] =
{
    {
        "CCR",
        DESC("The figure below represents the CCM Control Register (CCR), which cont"
        "ains bits to control general operation of CCM.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ccm_ccr
    },
    {
        "CCDR",
        DESC("The figure below represents the CCM Control Divider Register (CCDR), w"
        "hich contains bits that control the loading of the dividers that need "
        "handshake with the modules they affect.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ccm_ccdr
    },
    {
        "CSR",
        DESC("The figure below represents the CCM status Register (CSR).")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_ccm_csr
    },
    {
        "CCSR",
        DESC("The figure below represents the CCM Clock Switcher register (CCSR).")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_ccsr
    },
    {
        "CACRR",
        DESC("The figure below represents the CCM Arm Clock Root register (CACRR).")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_cacrr
    },
    {
        "CBCDR",
        DESC("The figure below represents the CCM Bus Clock Divider Register (CBCDR)"
        ".")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ccm_cbcdr
    },
    {
        "CBCMR",
        DESC("The figure below represents the CCM Bus Clock Multiplexer Register (CB"
        "CMR).")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ccm_cbcmr
    },
    {
        "CSCMR1",
        DESC("The figure below represents the CCM Serial Clock Multiplexer Register "
        "1 (CSCMR1).")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_cscmr1
    },
    {
        "CSCMR2",
        DESC("The figure below represents the CCM Serial Clock Multiplexer Register "
        "2 (CSCMR2).")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_cscmr2
    },
    {
        "CSCDR1",
        DESC("The figure below represents the CCM Serial Clock Divider Register 1 (C"
        "SCDR1).")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cscdr1
    },
    {
        "CS1CDR",
        DESC("The figure below represents the CCM SSI1, SSI3, ESAI Clock Divider Reg"
        "ister (CS1CDR).")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cs1cdr
    },
    {
        "CS2CDR",
        DESC("The figure below represents the CCM SSI2, LDB Clock Divider Register ("
        "CS2CDR).")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_cs2cdr
    },
    {
        "CDCDR",
        DESC("The figure below represents the CCM DI Clock Divider Register (CDCDR).")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cdcdr
    },
    {
        "CHSCCDR",
        DESC("The figure below represents the CCM IPU1 DI Clock Divider Register (CH"
        "SCCDR).")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_chsccdr
    },
    {
        "CSCDR2",
        DESC("The figure below represents the CCM Serial Clock Divider Register 2(CS"
        "CDR2).")
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cscdr2
    },
    {
        "CSCDR3",
        DESC("The figure below represents the CCM Serial Clock Divider Register 3(CS"
        "CDR3).")
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_cscdr3
    },
    {
        "CWDR",
        DESC("The figure below represents the CCM Wakeup Detector Register (CWDR).")
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_ccm_cwdr
    },
    {
        "CDHIPR",
        DESC("The figure below represents the CCM Divider Handshake In-Process Regis"
        "ter (CDHIPR).")
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_ccm_cdhipr
    },
    {
        "CTOR",
        DESC("The figure below represents the CCM Testing Observability Register (CT"
        "OR).")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_ctor
    },
    {
        "CLPCR",
        DESC("The figure below represents the CCM Low Power Control Register (CLPCR)"
        ".")
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_clpcr
    },
    {
        "CISR",
        DESC("The figure below represents the CCM Interrupt Status Register (CISR).")
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ccm_cisr
    },
    {
        "CIMR",
        DESC("The figure below represents the CCM Interrupt Mask Register (CIMR).")
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ccm_cimr
    },
    {
        "CCOSR",
        DESC("The figure below represents the CCM Clock Output Source Register (CCOS"
        "R).")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_ccosr
    },
    {
        "CGPR",
        DESC("Fast PLL enable.")
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ccm_cgpr
    },
    {
        "CCGR0",
        DESC("CG(i) bits CCGR 0-7  These bits are used to turn on/off the clock to e"
        "ach module independently.The following table details the possible cloc"
        "k activity conditions for each module         CGR value    Clock Activ"
        "ity Description        00    clock is off during all modes.")
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr0
    },
    {
        "CCGR1",
        DESC("The figure below represents the CCM Clock Gating Register 1(CCM_CCGR1)"
        ".")
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr1
    },
    {
        "CCGR2",
        DESC("The figure below represents the CCM Clock Gating Register 2 (CCM_CCGR2"
        ").")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr2
    },
    {
        "CCGR3",
        DESC("The figure below represents the CCM Clock Gating Register 3 (CCM_CCGR3"
        ").")
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr3
    },
    {
        "CCGR4",
        DESC("The figure below represents the CCM Clock Gating Register 4 (CCM_CCGR4"
        ").")
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr4
    },
    {
        "CCGR5",
        DESC("The figure below represents the CCM Clock Gating Register 5 (CCM_CCGR5"
        ").")
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr5
    },
    {
        "CCGR6",
        DESC("The figure below represents the CCM Clock Gating Register 6 (CCM_CCGR6"
        ").")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr6
    },
    {
        "CMEOR",
        DESC("The follow figure represents the CCM Module Enable Override Register ("
        "CMEOR).")
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ccm_cmeor
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CCM_ANALOG
#endif

// Bitfields in register CCM_ANALOG_PLL_ARM.
static const field_t hw_ccm_analog_pll_arm[] =
{
    {
        "DIV_SELECT",
        DESC("This field controls the pll loop divider.")
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LF",
        DESC("Reserved by Freescale.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_LF",
        DESC("Reserved by Freescale.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_CP",
        DESC("Reserved by Freescale.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_CP",
        DESC("Reserved by Freescale.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLD_RING_OFF",
        DESC("Analog debug bit.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        DESC("Powers down the PLL.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        DESC("Enable the clock output.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        DESC("Determines the bypass source.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        DESC("Bypass the pll.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_SEL",
        DESC("Analog Debug Bit")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_24MHZ_SEL",
        DESC("Analog Debug Bit")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_SEL",
        DESC("Reserved")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        DESC("1 - PLL is currently locked.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_USB1.
static const field_t hw_ccm_analog_pll_usb1[] =
{
    {
        "DIV_SELECT",
        DESC("This field controls the pll loop divider.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        DESC("Powers the 9-phase PLL outputs for USBPHYn.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        DESC("Powers up the PLL.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        DESC("Enable the PLL clock output.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        DESC("Determines the bypass source.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        DESC("Bypass the pll.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        DESC("1 - PLL is currently locked.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_USB2.
static const field_t hw_ccm_analog_pll_usb2[] =
{
    {
        "DIV_SELECT",
        DESC("This field controls the pll loop divider.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        DESC("0: 8-phase PLL outputs for USBPHY1 are powered down.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        DESC("Powers up the PLL.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        DESC("Enable the PLL clock output.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        DESC("Determines the bypass source.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        DESC("Bypass the pll.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        DESC("1 - PLL is currently locked.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_SYS.
static const field_t hw_ccm_analog_pll_sys[] =
{
    {
        "DIV_SELECT",
        DESC("This field controls the pll loop divider.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LF",
        DESC("Reserved by Freescale")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_LF",
        DESC("Reserved by Freescale")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_CP",
        DESC("Reserved by Freescale")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_CP",
        DESC("Reserved by Freescale")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLD_RING_OFF",
        DESC("Analog Debug bit.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        DESC("Powers down the PLL.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        DESC("Enable PLL output")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        DESC("Determines the bypass source.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        DESC("Bypass the pll.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        DESC("Enables an offset in the phase frequency detector.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        DESC("1 - PLL is currently locked; 0 - PLL is not currently locked.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_AUDIO.
static const field_t hw_ccm_analog_pll_audio[] =
{
    {
        "DIV_SELECT",
        DESC("This field controls the pll loop divider.")
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LF",
        DESC("Reserved by Freescale.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_LF",
        DESC("Reserved by Freescale.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_CP",
        DESC("Reserved by Freescale.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_CP",
        DESC("Reserved by Freescale.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLD_RING_OFF",
        DESC("Analog debug Bit")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        DESC("Powers down the PLL.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        DESC("Enable PLL output")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        DESC("Determines the bypass source.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        DESC("Bypass the pll.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        DESC("Enables an offset in the phase frequency detector.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        DESC("These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.")
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSC_EN",
        DESC("Reserved Bit")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        DESC("1 - PLL is currently locked.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_AUDIO_NUM.
static const field_t hw_ccm_analog_pll_audio_num[] =
{
    {
        "A",
        DESC("30 bit numerator of fractional loop divider.")
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_AUDIO_DENOM.
static const field_t hw_ccm_analog_pll_audio_denom[] =
{
    {
        "B",
        DESC("30 bit Denominator of fractional loop divider.")
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_VIDEO.
static const field_t hw_ccm_analog_pll_video[] =
{
    {
        "DIV_SELECT",
        DESC("This field controls the pll loop divider.")
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LF",
        DESC("Reserved by Freescale.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_LF",
        DESC("Reserved by Freescale.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_CP",
        DESC("Reserved by Freescale.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_CP",
        DESC("Reserved by Freescale.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLD_RING_OFF",
        DESC("Analog Debug bit.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        DESC("Powers down the PLL.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        DESC("Enalbe PLL output")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        DESC("Determines the bypass source.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        DESC("Bypass the pll.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        DESC("Enables an offset in the phase frequency detector.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        DESC("These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.")
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSC_EN",
        DESC("Revserved BIt")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        DESC("1 - PLL is currently locked;  0 - PLL is not currently locked.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_VIDEO_NUM.
static const field_t hw_ccm_analog_pll_video_num[] =
{
    {
        "A",
        DESC("30 bit numerator of fractional loop divider(Signed number), absolute v"
        "alue should be less than denominator")
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_VIDEO_DENOM.
static const field_t hw_ccm_analog_pll_video_denom[] =
{
    {
        "B",
        DESC("30 bit Denominator of fractional loop divider.")
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PLL_ENET.
static const field_t hw_ccm_analog_pll_enet[] =
{
    {
        "DIV_SELECT",
        DESC("Controls the frequency of the ethernet reference clock.00 - 25MHz; 01 "
        "- 50MHz; 10 - 100MHz (not 50% duty cycle); 11 - 125MHz;")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LF",
        DESC("Reserved by Freescale")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_LF",
        DESC("Reserved by Freescale")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_CP",
        DESC("Reserved by Freescale")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOUBLE_CP",
        DESC("Reserved by Freescale")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLD_RING_OFF",
        DESC("Analog debug bit")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        DESC("Powers down the PLL.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        DESC("Enable the ethernet clock output.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        DESC("Determines the bypass source.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        DESC("Bypass the pll.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        DESC("Enables an offset in the phase frequency detector.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_125M",
        DESC("Enables an offset in the phase frequency detector.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_100M",
        DESC("Enables an offset in the phase frequency detector.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        DESC("1 - PLL is currently locked; 0 - PLL is not currently locked.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PFD_480.
static const field_t hw_ccm_analog_pfd_480[] =
{
    {
        "PFD0_FRAC",
        DESC("This field controls the fractional divide value.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        DESC("This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        DESC("If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        DESC("This field controls the fractional divide value.")
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        DESC("This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        DESC("IO Clock Gate.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        DESC("This field controls the fractional divide value.")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        DESC("This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.")
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        DESC("IO Clock Gate.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        DESC("This field controls the fractional divide value.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        DESC("This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        DESC("IO Clock Gate.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_PFD_528.
static const field_t hw_ccm_analog_pfd_528[] =
{
    {
        "PFD0_FRAC",
        DESC("This field controls the fractional divide value.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        DESC("This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        DESC("If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        DESC("This field controls the fractional divide value.")
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        DESC("This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        DESC("IO Clock Gate.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        DESC("This field controls the fractional divide value.")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        DESC("This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.")
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        DESC("IO Clock Gate.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        DESC("This field controls the fractional divide value.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        DESC("This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        DESC("IO Clock Gate.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_MISC0.
static const field_t hw_ccm_analog_misc0[] =
{
    {
        "STOP_MODE_CONFIG",
        DESC("Configure the analog behavior in stop mode.")
        11, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_MISC2.
static const field_t hw_ccm_analog_misc2[] =
{
    {
        "PLL3_DISABLE",
        DESC("Default value of \"0\".")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        DESC("LSB of Post-divider for Audio PLL: 0x0=div-by-1(default), 0x1=div-by-2"
        ", 0x2=div-by-1, 0x3=div-by-4.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_MSB",
        DESC("MSB of Post-divider for Audio PLL: 0x0=div-by-1(default), 0x1=div-by-2"
        ", 0x2=div-by-1, 0x3=div-by-4.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        DESC("Post-divider for video: 0x0=div-by-1(default), 0x1=div-by-2, 0x2=div-b"
        "y-1, 0x3=div-by-4.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CCM_ANALOG module.
static const reg_t hw_ccm_analog[] =
{
    {
        "PLL_ARM",
        DESC("The control register provides control for the system PLL.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_pll_arm
    },
    {
        "PLL_USB1",
        DESC("The control register provides control for USBPHY0 480MHz PLL.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_pll_usb1
    },
    {
        "PLL_USB2",
        DESC("The control register provides control for USBPHY1 480MHz PLL.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_pll_usb2
    },
    {
        "PLL_SYS",
        DESC("The control register provides control for the 528MHz PLL.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_pll_sys
    },
    {
        "PLL_AUDIO",
        DESC("The control register provides control for the audio PLL.")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_pll_audio
    },
    {
        "PLL_AUDIO_NUM",
        DESC("This register contains the numerator (A) of Audio PLL fractional loop "
        "divider.(Signed number), absolute value should be less than denominato"
        "r  Absolute value should be less than denominator")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_pll_audio_num
    },
    {
        "PLL_AUDIO_DENOM",
        DESC("This register contains the Denominator (B) of Audio PLL fractional loo"
        "p divider.(unsigned number)")
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_pll_audio_denom
    },
    {
        "PLL_VIDEO",
        DESC("The control register provides control for the Video PLL.")
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_pll_video
    },
    {
        "PLL_VIDEO_NUM",
        DESC("This register contains the numerator (A) of Video PLL fractional loop "
        "divider.(Signed number)  Absolute value should be less than denominato"
        "r")
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_pll_video_num
    },
    {
        "PLL_VIDEO_DENOM",
        DESC("This register contains the Denominator (B) of Video PLL fractional loo"
        "p divider.(Unsigned number)")
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_pll_video_denom
    },
    {
        "PLL_ENET",
        DESC("The control register provides control for the ENET PLL.")
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_pll_enet
    },
    {
        "PFD_480",
        DESC("The PFD_480 control register provides control for PFD clock generation"
        ".")
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_pfd_480
    },
    {
        "PFD_528",
        DESC("The PFD_528 control register provides control for PFD clock generation"
        ".")
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_pfd_528
    },
    {
        "MISC0",
        DESC("This register defines the control for miscellaneous CCM Analog blocks.")
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_misc0
    },
    {
        "MISC2",
        DESC("This register defines the control for miscellaneous CCM Analog blocks.")
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_analog_misc2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CSI
#endif

// Bitfields in register CSI_CSICR1.
static const field_t hw_csi_csicr1[] =
{
    {
        "PIXEL_BIT",
        DESC("Pixel Bit.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REDGE",
        DESC("Valid Pixel Clock Edge Select.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INV_PCLK",
        DESC("Invert Pixel Clock Input.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INV_DATA",
        DESC("Invert Data Input.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GCLK_MODE",
        DESC("Gated Clock Mode Enable.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_RXFIFO",
        DESC("Asynchronous RXFIFO Clear.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_STATFIFO",
        DESC("Asynchronous STATFIFO Clear.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PACK_DIR",
        DESC("Data Packing Direction.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCC",
        DESC("FIFO Clear Control.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCIR_EN",
        DESC("CCIR656 Interface Enable.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        DESC("HSYNC Polarity Select.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOF_INTEN",
        DESC("Start Of Frame (SOF) Interrupt Enable.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOF_POL",
        DESC("SOF Interrupt Polarity.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFF_INTEN",
        DESC("RxFIFO Full Interrupt Enable.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FB1_DMA_DONE_INTEN",
        DESC("Frame Buffer1 DMA Transfer Done Interrupt Enable.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FB2_DMA_DONE_INTEN",
        DESC("Frame Buffer2 DMA Transfer Done Interrupt Enable.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATFF_INTEN",
        DESC("STATFIFO Full Interrupt Enable.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFF_DMA_DONE_INTEN",
        DESC("STATFIFO DMA Transfer Done Interrupt Enable.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF_OR_INTEN",
        DESC("RxFIFO Overrun Interrupt Enable.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SF_OR_INTEN",
        DESC("STAT FIFO Overrun Interrupt Enable.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COF_INT_EN",
        DESC("Change Of Image Field (COF) Interrupt Enable.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCIR_MODE",
        DESC("CCIR Mode Select.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRP_IF_EN",
        DESC("CSI-PrP Interface Enable.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EOF_INT_EN",
        DESC("End-of-Frame Interrupt Enable.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXT_VSYNC",
        DESC("External VSYNC Enable.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWAP16_EN",
        DESC("SWAP 16-Bit Enable.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSICR2.
static const field_t hw_csi_csicr2[] =
{
    {
        "HSC",
        DESC("Horizontal Skip Count.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSC",
        DESC("Vertical Skip Count.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVRM",
        DESC("Live View Resolution Mode.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BTS",
        DESC("Bayer Tile Start.")
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCE",
        DESC("Skip Count Enable.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AFS",
        DESC("Auto Focus Spread.")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRM",
        DESC("Double Resolution Mode.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_BURST_TYPE_SFF",
        DESC("Burst Type of DMA Transfer from STATFIFO.")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_BURST_TYPE_RFF",
        DESC("Burst Type of DMA Transfer from RxFIFO.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSICR3.
static const field_t hw_csi_csicr3[] =
{
    {
        "ECC_AUTO_EN",
        DESC("Automatic Error Correction Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_INT_EN",
        DESC("Error Detection Interrupt Enable.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZERO_PACK_EN",
        DESC("Dummy Zero Packing Enable.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWO_8BIT_SENSOR",
        DESC("Two 8-bit Sensor Mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFF_LEVEL",
        DESC("RxFIFO Full Level .")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRESP_ERR_EN",
        DESC("Hresponse Error Enable.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATFF_LEVEL",
        DESC("STATFIFO Full Level.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_REQ_EN_SFF",
        DESC("DMA Request Enable for STATFIFO.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_REQ_EN_RFF",
        DESC("DMA Request Enable for RxFIFO.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_REFLASH_SFF",
        DESC("Reflash DMA Controller for STATFIFO.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_REFLASH_RFF",
        DESC("Reflash DMA Controller for RxFIFO.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRMCNT_RST",
        DESC("Frame Count Reset.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRMCNT",
        DESC("Frame Counter.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSISTATFIFO.
static const field_t hw_csi_csistatfifo[] =
{
    {
        "STAT",
        DESC("Static data from sensor")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIRFIFO.
static const field_t hw_csi_csirfifo[] =
{
    {
        "IMAGE",
        DESC("Received image data")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIRXCNT.
static const field_t hw_csi_csirxcnt[] =
{
    {
        "RXCNT",
        DESC("RxFIFO Count.")
        0, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSISR.
static const field_t hw_csi_csisr[] =
{
    {
        "DRDY",
        DESC("RXFIFO Data Ready.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_INT",
        DESC("CCIR Error Interrupt.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRESP_ERR_INT",
        DESC("Hresponse Error Interrupt Status.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COF_INT",
        DESC("Change Of Field Interrupt Status.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1_INT",
        DESC("CCIR Field 1 Interrupt Status.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F2_INT",
        DESC("CCIR Field 2 Interrupt Status.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOF_INT",
        DESC("Start of Frame Interrupt Status.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EOF_INT",
        DESC("End of Frame (EOF) Interrupt Status.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFF_INT",
        DESC("RXFIFO Full Interrupt Status.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TSF_DONE_FB1",
        DESC("DMA Transfer Done in Frame Buffer1.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TSF_DONE_FB2",
        DESC("DMA Transfer Done in Frame Buffer2.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATFF_INT",
        DESC("STATFIFO Full Interrupt Status.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TSF_DONE_SFF",
        DESC("DMA Transfer Done from StatFIFO.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF_OR_INT",
        DESC("RxFIFO Overrun Interrupt Status.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SF_OR_INT",
        DESC("STATFIFO Overrun Interrupt Status.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIDMASA_STATFIFO.
static const field_t hw_csi_csidmasa_statfifo[] =
{
    {
        "DMA_START_ADDR_SFF",
        DESC("DMA Start Address for STATFIFO.")
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIDMATS_STATFIFO.
static const field_t hw_csi_csidmats_statfifo[] =
{
    {
        "DMA_TSF_SIZE_SFF",
        DESC("DMA Transfer Size for STATFIFO.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIDMASA_FB1.
static const field_t hw_csi_csidmasa_fb1[] =
{
    {
        "DMA_START_ADDR_FB1",
        DESC("DMA Start Address in Frame Buffer1.")
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIDMASA_FB2.
static const field_t hw_csi_csidmasa_fb2[] =
{
    {
        "DMA_START_ADDR_FB2",
        DESC("DMA Start Address in Frame Buffer2.")
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIFBUF_PARA.
static const field_t hw_csi_csifbuf_para[] =
{
    {
        "FBUF_STRIDE",
        DESC("Frame Buffer Parameter.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIIMAG_PARA.
static const field_t hw_csi_csiimag_para[] =
{
    {
        "IMAGE_HEIGHT",
        DESC("Image Height.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IMAGE_WIDTH",
        DESC("Image Width.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CSI module.
static const reg_t hw_csi[] =
{
    {
        "CSICR1",
        DESC("This register controls the sensor interface timing and interrupt gener"
        "ation.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_csi_csicr1
    },
    {
        "CSICR2",
        DESC("This register provides the statistic block with data about which live "
        "view resolution is being used, and the starting sensor pixel of the Ba"
        "yer pattern.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_csi_csicr2
    },
    {
        "CSICR3",
        DESC("This read/write register acts as an extension of the functionality of "
        "the CSI Control register 1, adding additional control and features.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_csi_csicr3
    },
    {
        "CSISTATFIFO",
        DESC("The StatFIFO is a read-only register containing statistic data from th"
        "e sensor.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_csi_csistatfifo
    },
    {
        "CSIRFIFO",
        DESC("This read-only register contains received image data.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_csi_csirfifo
    },
    {
        "CSIRXCNT",
        DESC("This register works for EOF interrupt generation.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csirxcnt
    },
    {
        "CSISR",
        DESC("This read/write register shows sensor interface status, and which kind"
        " of interrupt is being generated.")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_csi_csisr
    },
    {
        "CSIDMASA_STATFIFO",
        DESC("This register provides the start address for the embedded DMA controll"
        "er of STATFIFO.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csidmasa_statfifo
    },
    {
        "CSIDMATS_STATFIFO",
        DESC("This register provides the total transfer size for the embedded DMA co"
        "ntroller of STATFIFO.")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csidmats_statfifo
    },
    {
        "CSIDMASA_FB1",
        DESC("This register provides the start address in the frame buffer1 for the "
        "embedded DMA controller of RxFIFO.")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csidmasa_fb1
    },
    {
        "CSIDMASA_FB2",
        DESC("This register provides the start address in the frame buffer2 for the "
        "embedded DMA controller of RxFIFO.")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csidmasa_fb2
    },
    {
        "CSIFBUF_PARA",
        DESC("This register provides the stride of the frame buffer to show how many"
        " words to skip before starting to write the next row of the image.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csifbuf_para
    },
    {
        "CSIIMAG_PARA",
        DESC("This register provides the width and the height of the image from the "
        "sensor.")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_csi_csiimag_para
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CSU
#endif

// Bitfields in register CSU_CSL0.
static const field_t hw_csu_csl0[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL1.
static const field_t hw_csu_csl1[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL2.
static const field_t hw_csu_csl2[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL3.
static const field_t hw_csu_csl3[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL4.
static const field_t hw_csu_csl4[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL5.
static const field_t hw_csu_csl5[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL6.
static const field_t hw_csu_csl6[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL7.
static const field_t hw_csu_csl7[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL8.
static const field_t hw_csu_csl8[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL9.
static const field_t hw_csu_csl9[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL10.
static const field_t hw_csu_csl10[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL11.
static const field_t hw_csu_csl11[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL12.
static const field_t hw_csu_csl12[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL13.
static const field_t hw_csu_csl13[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL14.
static const field_t hw_csu_csl14[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL15.
static const field_t hw_csu_csl15[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL16.
static const field_t hw_csu_csl16[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL17.
static const field_t hw_csu_csl17[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL18.
static const field_t hw_csu_csl18[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL19.
static const field_t hw_csu_csl19[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL20.
static const field_t hw_csu_csl20[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL21.
static const field_t hw_csu_csl21[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL22.
static const field_t hw_csu_csl22[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL23.
static const field_t hw_csu_csl23[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL24.
static const field_t hw_csu_csl24[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL25.
static const field_t hw_csu_csl25[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL26.
static const field_t hw_csu_csl26[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL27.
static const field_t hw_csu_csl27[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL28.
static const field_t hw_csu_csl28[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL29.
static const field_t hw_csu_csl29[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL30.
static const field_t hw_csu_csl30[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL31.
static const field_t hw_csu_csl31[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL32.
static const field_t hw_csu_csl32[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL33.
static const field_t hw_csu_csl33[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL34.
static const field_t hw_csu_csl34[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL35.
static const field_t hw_csu_csl35[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL36.
static const field_t hw_csu_csl36[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL37.
static const field_t hw_csu_csl37[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL38.
static const field_t hw_csu_csl38[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_CSL39.
static const field_t hw_csu_csl39[] =
{
    {
        "SUR_S2",
        DESC("Secure user read access control for the second slave")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S2",
        DESC("Secure supervisor read access control for the second slave")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S2",
        DESC("Non-secure user read access control for the second slave")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S2",
        DESC("Non-secure supervisor read access control for the second slave")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S2",
        DESC("Secure user write access control for the second slave")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S2",
        DESC("Secure supervisor write access control for the second slave")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S2",
        DESC("Non-secure user write access control for the second slave")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S2",
        DESC("Non-secure supervisor write access control for the second slave")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S2",
        DESC("Lock bit corresponding to the second slave.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUR_S1",
        DESC("Secure user read access control for the first slave")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSR_S1",
        DESC("Secure supervisor read access control for the first slave")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUR_S1",
        DESC("Non-secure user read access control for the first slave")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSR_S1",
        DESC("Non-secure supervisor read access control for the first slave")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUW_S1",
        DESC("Secure user write access control for the first slave")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSW_S1",
        DESC("Secure supervisor write access control for the first slave")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUW_S1",
        DESC("Non-secure user write access control for the first slave")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSW_S1",
        DESC("Non-secure supervisor write access control for the first slave")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_S1",
        DESC("Lock bit corresponding to the first slave.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_HP0.
static const field_t hw_csu_hp0[] =
{
    {
        "HP",
        DESC("Privilege indicator bits")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L",
        DESC("Lock bit set by secure software")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP1",
        DESC("Privilege indicator bits")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1",
        DESC("Lock bit set by secure software")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP2",
        DESC("Privilege indicator bits")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2",
        DESC("Lock bit set by secure software")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP3",
        DESC("Privilege indicator bits")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L3",
        DESC("Lock bit set by secure software")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP4",
        DESC("Privilege indicator bits")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L4",
        DESC("Lock bit set by secure software")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP5",
        DESC("Privilege indicator bits")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L5",
        DESC("Lock bit set by secure software")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP6",
        DESC("Privilege indicator bits")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L6",
        DESC("Lock bit set by secure software")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP7",
        DESC("Privilege indicator bits")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L7",
        DESC("Lock bit set by secure software")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP8",
        DESC("Privilege indicator bits")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L8",
        DESC("Lock bit set by secure software")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP9",
        DESC("Privilege indicator bits")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L9",
        DESC("Lock bit set by secure software")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP10",
        DESC("Privilege indicator bits")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L10",
        DESC("Lock bit set by secure software")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP11",
        DESC("Privilege indicator bits")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L11",
        DESC("Lock bit set by secure software")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP12",
        DESC("Privilege indicator bits")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L12",
        DESC("Lock bit set by secure software")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP13",
        DESC("Privilege indicator bits")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L13",
        DESC("Lock bit set by secure software")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP14",
        DESC("Privilege indicator bits")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L14",
        DESC("Lock bit set by secure software")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP15",
        DESC("Privilege indicator bits")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L15",
        DESC("Lock bit set by secure software")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_HP1.
static const field_t hw_csu_hp1[] =
{
    {
        "HP",
        DESC("Privilege indicator bits")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L",
        DESC("Lock bit set by secure software")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP1",
        DESC("Privilege indicator bits")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1",
        DESC("Lock bit set by secure software")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP2",
        DESC("Privilege indicator bits")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2",
        DESC("Lock bit set by secure software")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP3",
        DESC("Privilege indicator bits")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L3",
        DESC("Lock bit set by secure software")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP4",
        DESC("Privilege indicator bits")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L4",
        DESC("Lock bit set by secure software")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP5",
        DESC("Privilege indicator bits")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L5",
        DESC("Lock bit set by secure software")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP6",
        DESC("Privilege indicator bits")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L6",
        DESC("Lock bit set by secure software")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP7",
        DESC("Privilege indicator bits")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L7",
        DESC("Lock bit set by secure software")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP8",
        DESC("Privilege indicator bits")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L8",
        DESC("Lock bit set by secure software")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP9",
        DESC("Privilege indicator bits")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L9",
        DESC("Lock bit set by secure software")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP10",
        DESC("Privilege indicator bits")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L10",
        DESC("Lock bit set by secure software")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP11",
        DESC("Privilege indicator bits")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L11",
        DESC("Lock bit set by secure software")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP12",
        DESC("Privilege indicator bits")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L12",
        DESC("Lock bit set by secure software")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP13",
        DESC("Privilege indicator bits")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L13",
        DESC("Lock bit set by secure software")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP14",
        DESC("Privilege indicator bits")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L14",
        DESC("Lock bit set by secure software")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP15",
        DESC("Privilege indicator bits")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L15",
        DESC("Lock bit set by secure software")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSU_SA.
static const field_t hw_csu_sa[] =
{
    {
        "NSA",
        DESC("Non-Secure Access Policy indicator bits")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L",
        DESC("Lock bit set by secure software")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA1",
        DESC("Non-Secure Access Policy indicator bits")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1",
        DESC("Lock bit set by secure software")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA2",
        DESC("Non-Secure Access Policy indicator bits")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2",
        DESC("Lock bit set by secure software")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA3",
        DESC("Non-Secure Access Policy indicator bits")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L3",
        DESC("Lock bit set by secure software")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA4",
        DESC("Non-Secure Access Policy indicator bits")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L4",
        DESC("Lock bit set by secure software")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA5",
        DESC("Non-Secure Access Policy indicator bits")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L5",
        DESC("Lock bit set by secure software")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA6",
        DESC("Non-Secure Access Policy indicator bits")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L6",
        DESC("Lock bit set by secure software")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA7",
        DESC("Non-Secure Access Policy indicator bits")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L7",
        DESC("Lock bit set by secure software")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA8",
        DESC("Non-Secure Access Policy indicator bits")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L8",
        DESC("Lock bit set by secure software")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA9",
        DESC("Non-Secure Access Policy indicator bits")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L9",
        DESC("Lock bit set by secure software")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA10",
        DESC("Non-Secure Access Policy indicator bits")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L10",
        DESC("Lock bit set by secure software")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA11",
        DESC("Non-Secure Access Policy indicator bits")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L11",
        DESC("Lock bit set by secure software")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA12",
        DESC("Non-Secure Access Policy indicator bits")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L12",
        DESC("Lock bit set by secure software")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA13",
        DESC("Non-Secure Access Policy indicator bits")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L13",
        DESC("Lock bit set by secure software")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA14",
        DESC("Non-Secure Access Policy indicator bits")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L14",
        DESC("Lock bit set by secure software")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSA15",
        DESC("Non-Secure Access Policy indicator bits")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L15",
        DESC("Lock bit set by secure software")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CSU module.
static const reg_t hw_csu[] =
{
    {
        "CSL0",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl0
    },
    {
        "CSL1",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl1
    },
    {
        "CSL2",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl2
    },
    {
        "CSL3",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl3
    },
    {
        "CSL4",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl4
    },
    {
        "CSL5",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl5
    },
    {
        "CSL6",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl6
    },
    {
        "CSL7",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl7
    },
    {
        "CSL8",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl8
    },
    {
        "CSL9",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl9
    },
    {
        "CSL10",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl10
    },
    {
        "CSL11",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl11
    },
    {
        "CSL12",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl12
    },
    {
        "CSL13",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl13
    },
    {
        "CSL14",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl14
    },
    {
        "CSL15",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl15
    },
    {
        "CSL16",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl16
    },
    {
        "CSL17",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl17
    },
    {
        "CSL18",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl18
    },
    {
        "CSL19",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl19
    },
    {
        "CSL20",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl20
    },
    {
        "CSL21",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl21
    },
    {
        "CSL22",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl22
    },
    {
        "CSL23",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl23
    },
    {
        "CSL24",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl24
    },
    {
        "CSL25",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl25
    },
    {
        "CSL26",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl26
    },
    {
        "CSL27",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl27
    },
    {
        "CSL28",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl28
    },
    {
        "CSL29",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl29
    },
    {
        "CSL30",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl30
    },
    {
        "CSL31",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl31
    },
    {
        "CSL32",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl32
    },
    {
        "CSL33",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl33
    },
    {
        "CSL34",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl34
    },
    {
        "CSL35",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl35
    },
    {
        "CSL36",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl36
    },
    {
        "CSL37",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl37
    },
    {
        "CSL38",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl38
    },
    {
        "CSL39",
        DESC("There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers.")
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csu_csl39
    },
    {
        "HP0",
        DESC("The HP register may be programmed to determine the privilege (either U"
        "ser Mode or Supervisor Mode) for up to sixteen different masters.")
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_csu_hp0
    },
    {
        "HP1",
        DESC("The HP register may be programmed to determine the privilege (either U"
        "ser Mode or Supervisor Mode) for up to sixteen different masters.")
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_csu_hp1
    },
    {
        "SA",
        DESC("The Secure Access register may be programmed to specify the access pol"
        "icy (either Secure or Non-secure) for up to sixteen different masters.")
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_csu_sa
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark DBGMON
#endif

// Bitfields in register DBGMON_HW_DBGMON_CTRL.
static const field_t hw_dbgmon_hw_dbgmon_ctrl[] =
{
    {
        "RUN",
        DESC("Set this bit to one to enable the DBGMON operation")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNAP",
        DESC("Set this bit to snapshot the registers selected by REQSEL to SNVS doma"
        "in registers")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR",
        DESC("Set this bit to clear the registers in SOC domain.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_SNVS",
        DESC("Set this bit to clear the registers in SNVS domain")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_TRAPMODE",
        DESC("The bit defines the address trap function.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ID_TRAPMODE",
        DESC("The bit defines the ID trap function.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REQSEL",
        DESC("This field defines which sets of AXI transaction will be snaped to SNV"
        "S domain registers.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORKMODE",
        DESC("This field defines whether ignore the transaction in IRQ")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_MASKEN",
        DESC("This field control the address mask function,")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_IRQ_SEL",
        DESC("Select the source of WDOG IRQ.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        DESC("This bit must be set to zero for normal oepration.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        DESC("Set to zero for normal operation.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DBGMON_HW_DBGMON_MASTER_EN.
static const field_t hw_dbgmon_hw_dbgmon_master_en[] =
{
    {
        "MID0",
        DESC("Set to 1 to enable monitoring on MasterID 0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID1",
        DESC("Set to 1 to enable monitoring on MasterID 1.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID2",
        DESC("Set to 1 to enable monitoring on MasterID 2.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID3",
        DESC("Set to 1 to enable monitoring on MasterID 3.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID4",
        DESC("Set to 1 to enable monitoring on MasterID 4.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID5",
        DESC("Set to 1 to enable monitoring on MasterID 5")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID6",
        DESC("Set to 1 to enable monitoring on MasterID 6.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID7",
        DESC("Set to 1 to enable monitoring on MasterID 7.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID8",
        DESC("Set to 1 to enable monitoring on MasterID 8.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID9",
        DESC("Set to 1 to enable monitoring on MasterID 9.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID10",
        DESC("Set to 1 to enable monitoring on MasterID 10.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID11",
        DESC("Set to 1 to enable monitoring on MasterID 11.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID12",
        DESC("Set to 1 to enable monitoring on MasterID 12.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID13",
        DESC("Set to 1 to enable monitoring on MasterID 13.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID14",
        DESC("Set to 1 to enable monitoring on MasterID 14.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MID15",
        DESC("Set to 1 to enable monitoring on MasterID 15.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DBGMON_HW_DBGMON_IRQ.
static const field_t hw_dbgmon_hw_dbgmon_irq[] =
{
    {
        "ADDR_TRAP_IRQEN",
        DESC("Address trap interrupt control.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ID_TRAP_IRQEN",
        DESC("ID trap interrupt control.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_TRAP_IRQ",
        DESC("This bit indicates the Address trap interrupt is happening.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ID_TRAP_IRQ",
        DESC("This bit indicates the ID trap interrupt is happening.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_MID",
        DESC("This field indicate which master sends the interrupt, will not update "
        "until all interrupts are cleared.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DBGMON_HW_DBGMON_TRAP_ADDR_LOW.
static const field_t hw_dbgmon_hw_dbgmon_trap_addr_low[] =
{
    {
        "ADDRESS",
        DESC("This field contains 32-bit low address for the address trap range")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DBGMON_HW_DBGMON_TRAP_ADDR_HIGH.
static const field_t hw_dbgmon_hw_dbgmon_trap_addr_high[] =
{
    {
        "ADDRESS",
        DESC("This field contains 32-bit high address for the address trap range")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DBGMON_HW_DBGMON_TRAP_ID.
static const field_t hw_dbgmon_hw_dbgmon_trap_id[] =
{
    {
        "TRAP_ID_LOW",
        DESC("This field contains 16-bit low ID for ID trap range")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRAP_ID_HIGH",
        DESC("This field contains 16-bit high ID for ID trap range")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DBGMON_HW_DBGMON_SNVS_ADDR.
static const field_t hw_dbgmon_hw_dbgmon_snvs_addr[] =
{
    {
        "ADDR",
        DESC("This field contains 32-bit Address in SNVS domain register")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DBGMON_HW_DBGMON_SNVS_DATA.
static const field_t hw_dbgmon_hw_dbgmon_snvs_data[] =
{
    {
        "DATA",
        DESC("This field contains 32-bit Data of AXI transaction in SNVS domain regi"
        "ster")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DBGMON_HW_DBGMON_SNVS_INFO.
static const field_t hw_dbgmon_hw_dbgmon_snvs_info[] =
{
    {
        "COMPLETE",
        DESC("The field indicates whether the AXI transaction in SNVS domain complet"
        "e.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDWR",
        DESC("The field indicates the read/write attribute of AXI transaction in SNV"
        "S domain.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ID",
        DESC("The field contain the ID of the AXI transaction in SNVS domain")
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DBGMON_HW_DBGMON_VERSION.
static const field_t hw_dbgmon_hw_dbgmon_version[] =
{
    {
        "STEP",
        DESC("Fixed read-only value reflecting the stepping of the RTL version")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        DESC("Fixed read-only value reflecting the MINOR field of the RTL version")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        DESC("Fixed read-only value reflecting the MAJOR field of the RTL version")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a DBGMON module.
static const reg_t hw_dbgmon[] =
{
    {
        "HW_DBGMON_CTRL",
        DESC("")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_dbgmon_hw_dbgmon_ctrl
    },
    {
        "HW_DBGMON_MASTER_EN",
        DESC("")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_dbgmon_hw_dbgmon_master_en
    },
    {
        "HW_DBGMON_IRQ",
        DESC("")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_dbgmon_hw_dbgmon_irq
    },
    {
        "HW_DBGMON_TRAP_ADDR_LOW",
        DESC("")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dbgmon_hw_dbgmon_trap_addr_low
    },
    {
        "HW_DBGMON_TRAP_ADDR_HIGH",
        DESC("")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dbgmon_hw_dbgmon_trap_addr_high
    },
    {
        "HW_DBGMON_TRAP_ID",
        DESC("")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dbgmon_hw_dbgmon_trap_id
    },
    {
        "HW_DBGMON_SNVS_ADDR",
        DESC("")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_dbgmon_hw_dbgmon_snvs_addr
    },
    {
        "HW_DBGMON_SNVS_DATA",
        DESC("")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_dbgmon_hw_dbgmon_snvs_data
    },
    {
        "HW_DBGMON_SNVS_INFO",
        DESC("")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_dbgmon_hw_dbgmon_snvs_info
    },
    {
        "HW_DBGMON_VERSION",
        DESC("")
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_dbgmon_hw_dbgmon_version
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark DCP
#endif

// Bitfields in register DCP_CTRL.
static const field_t hw_dcp_ctrl[] =
{
    {
        "CHANNEL_INTERRUPT_ENABLE",
        DESC("Per-channel interrupt enable bit.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_CONTEXT_SWITCHING",
        DESC("Enable automatic context switching for the channels.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_CONTEXT_CACHING",
        DESC("Software should set this bit to enable caching of contexts between ope"
        "rations.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GATHER_RESIDUAL_WRITES",
        DESC("Software should set this bit to enable ragged writes to unaligned buff"
        "ers to be gathered between multiple write operations.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESENT_SHA",
        DESC("Indicates whether the SHA1/SHA2 functions are present.")
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRESENT_CRYPTO",
        DESC("Indicates whether the crypto (Cipher/Hash) functions are present.")
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        DESC("This bit must be set to zero for normal operation.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        DESC("Set this bit to zero to enable normal DCP operation.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_STAT.
static const field_t hw_dcp_stat[] =
{
    {
        "IRQ",
        DESC("Indicates which channels have pending interrupt requests.")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READY_CHANNELS",
        DESC("Indicates which channels are ready to proceed with a transfer (active "
        "channel also included).")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CUR_CHANNEL",
        DESC("Current (active) channel (encoded).")
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTP_KEY_READY",
        DESC("When set, indicates that the OTP key has been shifted from the fuse bl"
        "ock and is ready for use.")
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CHANNELCTRL.
static const field_t hw_dcp_channelctrl[] =
{
    {
        "ENABLE_CHANNEL",
        DESC("Setting a bit in this field will enabled the DMA channel associated wi"
        "th it.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HIGH_PRIORITY_CHANNEL",
        DESC("Setting a bit in this field causes the corresponding channel to have h"
        "igh-priority arbitration.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_IRQ_MERGED",
        DESC("Indicates that the interrupt for channel 0 should be merged with the o"
        "ther interrupts on the shared dcp_irq interrupt.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CAPABILITY0.
static const field_t hw_dcp_capability0[] =
{
    {
        "NUM_KEYS",
        DESC("Encoded value indicating the number of key storage locations implement"
        "ed in the design.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NUM_CHANNELS",
        DESC("Encoded value indicating the number of channels implemented in the des"
        "ign.")
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DISABLE_UNIQUE_KEY",
        DESC("Write to a 1 disable the per-device unique key.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_DECRYPT",
        DESC("Write to a 1 to disable decryption.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CAPABILITY1.
static const field_t hw_dcp_capability1[] =
{
    {
        "CIPHER_ALGORITHMS",
        DESC("One-hot field indicating which cipher algorithms are available.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HASH_ALGORITHMS",
        DESC("One-hot field indicating which hashing features are implemented in HW.")
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CONTEXT.
static const field_t hw_dcp_context[] =
{
    {
        "ADDR",
        DESC("Context pointer address.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_KEY.
static const field_t hw_dcp_key[] =
{
    {
        "SUBWORD",
        DESC("Key subword pointer.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INDEX",
        DESC("Key index pointer.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_KEYDATA.
static const field_t hw_dcp_keydata[] =
{
    {
        "DATA",
        DESC("Word 0 data for key.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_PACKET0.
static const field_t hw_dcp_packet0[] =
{
    {
        "ADDR",
        DESC("Next Pointer Register,")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_PACKET1.
static const field_t hw_dcp_packet1[] =
{
    {
        "INTERRUPT",
        DESC("Reflects whether the channel should issue an interrupt upon completion"
        " of the packet.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DECR_SEMAPHORE",
        DESC("Reflects whether the channel's semaphore should be decremented at the "
        "end of the current operation.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        DESC("Reflects whether the next command pointer register should be loaded in"
        "to the channel's current descriptor pointer.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN_CONTIGUOUS",
        DESC("Reflects whether the next packet's address is located following this p"
        "acket's payload.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE_MEMCOPY",
        DESC("Reflects whether the selected hashing function should be enabled for t"
        "his operation.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE_CIPHER",
        DESC("Reflects whether the selected cipher function should be enabled for th"
        "is operation.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE_HASH",
        DESC("Reflects whether the selected hashing function should be enabled for t"
        "his operation.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE_BLIT",
        DESC("Reflects whether the DCP should perform a blit operation.")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CIPHER_ENCRYPT",
        DESC("When the cipher block is enabled, this bit indicates whether the opera"
        "tion is encryption or decryption.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CIPHER_INIT",
        DESC("Reflects whether the cipher block should load the initialization vecto"
        "r from the payload for this operation.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTP_KEY",
        DESC("Reflects whether a hardware-based key should be used.")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PAYLOAD_KEY",
        DESC("When set, indicates the payload contains the key.")
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HASH_INIT",
        DESC("Reflects whether the current hashing block is the initial block in the"
        " hashing operation, so the hash registers should be initialized before"
        " the operation.")
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HASH_TERM",
        DESC("Reflects whether the current hashing block is the final block in the h"
        "ashing operation, so the hash padding should be applied by hardware.")
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHECK_HASH",
        DESC("Reflects whether the calculated hash value should be compared against "
        "the hash provided in the payload.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HASH_OUTPUT",
        DESC("When hashing is enabled, this bit controls whether the input or output"
        " data is hashed.")
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CONSTANT_FILL",
        DESC("When this bit is set (MEMCOPY and BLIT modes only), the DCP will simpl"
        "y fill the destination buffer with the value found in the  Source Addr"
        "ess field.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEST_SEMA_IRQ",
        DESC("This bit is used to test the channel semaphore transition to 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KEY_BYTESWAP",
        DESC("Reflects whether the DCP engine will swap key bytes (big-endian key).")
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KEY_WORDSWAP",
        DESC("Reflects whether the DCP engine will swap key words (big-endian key).")
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INPUT_BYTESWAP",
        DESC("Reflects whether the DCP engine will byteswap input data (big-endian d"
        "ata).")
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INPUT_WORDSWAP",
        DESC("Reflects whether the DCP engine will wordswap input data (big-endian d"
        "ata).")
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUTPUT_BYTESWAP",
        DESC("Reflects whether the DCP engine will byteswap output data (big-endian "
        "data).")
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUTPUT_WORDSWAP",
        DESC("Reflects whether the DCP engine will wordswap output data (big-endian "
        "data).")
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAG",
        DESC("Packet Tag")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_PACKET2.
static const field_t hw_dcp_packet2[] =
{
    {
        "CIPHER_SELECT",
        DESC("Cipher Selection Field")
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CIPHER_MODE",
        DESC("Cipher Mode Selection Field.")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KEY_SELECT",
        DESC("Key Selection Field.")
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HASH_SELECT",
        DESC("Hash Selection Field")
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CIPHER_CFG",
        DESC("Cipher configuration bits.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_PACKET3.
static const field_t hw_dcp_packet3[] =
{
    {
        "ADDR",
        DESC("Source Buffer Address Pointer.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_PACKET4.
static const field_t hw_dcp_packet4[] =
{
    {
        "ADDR",
        DESC("Destination Buffer Address Pointer.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_PACKET5.
static const field_t hw_dcp_packet5[] =
{
    {
        "COUNT",
        DESC("Byte Count register.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_PACKET6.
static const field_t hw_dcp_packet6[] =
{
    {
        "ADDR",
        DESC("This regiser reflects the payload pointer for the current control pack"
        "et.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH0CMDPTR.
static const field_t hw_dcp_ch0cmdptr[] =
{
    {
        "ADDR",
        DESC("Pointer to descriptor structure to be processed for channel 0.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH0SEMA.
static const field_t hw_dcp_ch0sema[] =
{
    {
        "INCREMENT",
        DESC("The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DCP hardware subst"
        "racts happening on the same clock are protected.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE",
        DESC("This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH0STAT.
static const field_t hw_dcp_ch0stat[] =
{
    {
        "HASH_MISMATCH",
        DESC("The bit indicates that a hashing check operation mismatched for contro"
        "l packets that enable the HASH_CHECK bit.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_SETUP",
        DESC("This bit indicates that the hardware has detected an invalid programmi"
        "ng configuration such as a buffer length that is not a multiple of the"
        " natural data size for the operation.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_PACKET",
        DESC("This bit indicates that a a bus error occurred when reading the packet"
        " or payload or when writing status back to the packet payload.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_SRC",
        DESC("This bit indicates a bus error occurred when reading from the source b"
        "uffer.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_DST",
        DESC("This bit indicates a bus error occurred when storing to the destinatio"
        "n buffer.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_PAGEFAULT",
        DESC("This bit indicates a page fault occurred while converting a virtual ad"
        "dress to a physical address..")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_CODE",
        DESC("Indicates additional error codes for some error conditions.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAG",
        DESC("Indicates the tag from the last completed packet in the command struct"
        "ure")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH0OPTS.
static const field_t hw_dcp_ch0opts[] =
{
    {
        "RECOVERY_TIMER",
        DESC("This field indicates the recovery time for the channel.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH1CMDPTR.
static const field_t hw_dcp_ch1cmdptr[] =
{
    {
        "ADDR",
        DESC("Pointer to descriptor structure to be processed for channel 1.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH1SEMA.
static const field_t hw_dcp_ch1sema[] =
{
    {
        "INCREMENT",
        DESC("The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DCP hardware subst"
        "racts happening on the same clock are protected.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE",
        DESC("This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH1STAT.
static const field_t hw_dcp_ch1stat[] =
{
    {
        "HASH_MISMATCH",
        DESC("The bit indicates that a hashing check operation mismatched for contro"
        "l packets that enable the HASH_CHECK bit.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_SETUP",
        DESC("This bit indicates that the hardware detected an invalid programming c"
        "onfiguration such as a buffer length that is not a multiple of the nat"
        "ural data size for the operation.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_PACKET",
        DESC("This bit indicates that a bus error occurs when reading the packet or "
        "payload or when writing status back to the packet paylaod.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_SRC",
        DESC("This bit indicates a bus error occurred when reading from the source b"
        "uffer.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_DST",
        DESC("This bit indicates a bus error occurred when storing to the destinatio"
        "n buffer.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_PAGEFAULT",
        DESC("This bit indicates a page fault occurred while converting a virtual ad"
        "dress to a physical address..")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_CODE",
        DESC("Indicates additional error codes for some error conditions.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAG",
        DESC("Indicates the tag from the last completed packet in the command struct"
        "ure")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH1OPTS.
static const field_t hw_dcp_ch1opts[] =
{
    {
        "RECOVERY_TIMER",
        DESC("This field indicates the recovery time for the channel.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH2CMDPTR.
static const field_t hw_dcp_ch2cmdptr[] =
{
    {
        "ADDR",
        DESC("Pointer to descriptor structure to be processed for channel 2.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH2SEMA.
static const field_t hw_dcp_ch2sema[] =
{
    {
        "INCREMENT",
        DESC("The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DCP hardware subst"
        "racts happening on the same clock are protected.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE",
        DESC("This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH2STAT.
static const field_t hw_dcp_ch2stat[] =
{
    {
        "HASH_MISMATCH",
        DESC("The bit indicates that a hashing check operation mismatched for contro"
        "l packets that enable the HASH_CHECK bit.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_SETUP",
        DESC("This bit indicates that the hardware detected an invalid programming c"
        "onfiguration such as a buffer length that is not a multiple of the nat"
        "ural data size for the operation.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_PACKET",
        DESC("This bit indicates that a bus error occurred when reading the packet o"
        "r payload or when writing status back to the packet paylaod.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_SRC",
        DESC("This bit indicates a bus error occurred when reading from the source b"
        "uffer.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_DST",
        DESC("This bit indicates a bus error occurred when storing to the destinatio"
        "n buffer.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_PAGEFAULT",
        DESC("This bit indicates a page fault occurred while converting a virtual ad"
        "dress to a physical address..")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_CODE",
        DESC("Indicates additional error codes for some error conditions.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAG",
        DESC("Indicates the tag from the last completed packet in the command struct"
        "ure")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH2OPTS.
static const field_t hw_dcp_ch2opts[] =
{
    {
        "RECOVERY_TIMER",
        DESC("This field indicates the recovery time for the channel.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH3CMDPTR.
static const field_t hw_dcp_ch3cmdptr[] =
{
    {
        "ADDR",
        DESC("Pointer to descriptor structure to be processed for channel 3.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH3SEMA.
static const field_t hw_dcp_ch3sema[] =
{
    {
        "INCREMENT",
        DESC("The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DCP hardware subst"
        "racts happening on the same clock are protected.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE",
        DESC("This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH3STAT.
static const field_t hw_dcp_ch3stat[] =
{
    {
        "HASH_MISMATCH",
        DESC("The bit indicates that a hashing check operation mismatched for contro"
        "l packets that enable the HASH_CHECK bit.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_SETUP",
        DESC("This bit indicates that the hardware detected an invalid programming c"
        "onfiguration such as a buffer length that is not a multiple of the nat"
        "ural data size for the operation.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_PACKET",
        DESC("This bit indicates that a bus error occurred when reading the packet o"
        "r payload or when writing status back to the packet paylaod.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_SRC",
        DESC("This bit indicates a bus error occurred when reading from the source b"
        "uffer.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_DST",
        DESC("This bit indicates a bus error occurred when storing to the destinatio"
        "n buffer.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_PAGEFAULT",
        DESC("This bit indicates a page fault occurred while converting a virtual ad"
        "dress to a physical address..")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_CODE",
        DESC("Indicates additional error codes for some error conditions.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAG",
        DESC("Indicates the tag from the last completed packet in the command struct"
        "ure")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_CH3OPTS.
static const field_t hw_dcp_ch3opts[] =
{
    {
        "RECOVERY_TIMER",
        DESC("This field indicates the recovery time for the channel.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_DBGSELECT.
static const field_t hw_dcp_dbgselect[] =
{
    {
        "INDEX",
        DESC("Selects a value to read via the debug data register.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_DBGDATA.
static const field_t hw_dcp_dbgdata[] =
{
    {
        "DATA",
        DESC("Debug Data")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_PAGETABLE.
static const field_t hw_dcp_pagetable[] =
{
    {
        "ENABLE",
        DESC("Page Table Enable control.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FLUSH",
        DESC("Page Table Flush control.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BASE",
        DESC("Page Table Base Address.")
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCP_VERSION.
static const field_t hw_dcp_version[] =
{
    {
        "STEP",
        DESC("Fixed read-onlyl value reflecting the stepping of version of the desig"
        "n implementation.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        DESC("Fixed read-onlyl value reflecting the MINOR version of the design impl"
        "ementation.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        DESC("Fixed read-onlyl value reflecting the MAJOR version of the design impl"
        "ementation.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a DCP module.
static const reg_t hw_dcp[] =
{
    {
        "CTRL",
        DESC("The CTRL register contains controls for the DCP module.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_dcp_ctrl
    },
    {
        "STAT",
        DESC("The DCP Interrupt Status register provides channel interrupt status in"
        "formation.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dcp_stat
    },
    {
        "CHANNELCTRL",
        DESC("The DCP Channel Control register provides controls for channel arbitra"
        "tion and channel enables.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dcp_channelctrl
    },
    {
        "CAPABILITY0",
        DESC("This register contains additional information about the DCP module imp"
        "lementation parameters.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dcp_capability0
    },
    {
        "CAPABILITY1",
        DESC("This register contains information about the algorithms available on t"
        "he implementation.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_dcp_capability1
    },
    {
        "CONTEXT",
        DESC("This register contains a pointer to the memory region to be used for D"
        "CP context swap operations.")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcp_context
    },
    {
        "KEY",
        DESC("This register contains a pointer to the key location to be written.")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dcp_key
    },
    {
        "KEYDATA",
        DESC("This register provides write access to the key/key subword specified b"
        "y the Key Index Register.")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcp_keydata
    },
    {
        "PACKET0",
        DESC("This register displays the values for the current work packet offset 0"
        "x00 (Next Command) field.")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_dcp_packet0
    },
    {
        "PACKET1",
        DESC("This register displays the values for the current work packet offset 0"
        "x04 (control) field.")
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        false, // Writable
        25, // Number of bitfields
        hw_dcp_packet1
    },
    {
        "PACKET2",
        DESC("This register displays the values for the current work packet offset 0"
        "x08 (Control1) field.")
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_dcp_packet2
    },
    {
        "PACKET3",
        DESC("This register displays the values for the current work packet offset 0"
        "x0C (Source Address) field.")
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_dcp_packet3
    },
    {
        "PACKET4",
        DESC("This register displays the values for the current work packet offset 0"
        "x10 (Destination Address) field.")
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_dcp_packet4
    },
    {
        "PACKET5",
        DESC("This register displays the values for the current work packet offset 0"
        "x14 (Buffer Size) field.")
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_dcp_packet5
    },
    {
        "PACKET6",
        DESC("This register displays the values for the current work packet offset 0"
        "x1C (Payload Pointer) field.")
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_dcp_packet6
    },
    {
        "CH0CMDPTR",
        DESC("The DCP channel 0 current command address register points to the multi"
        "word descriptor that is to be executed (or currently being executed).")
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcp_ch0cmdptr
    },
    {
        "CH0SEMA",
        DESC("The DCP Channel 0 semaphore register is used to synchronize the ARM pl"
        "atform instruction stream and the DMA chain processing state.")
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dcp_ch0sema
    },
    {
        "CH0STAT",
        DESC("The DCP Channel 0 Interrupt Status register contains the interrupt sta"
        "tus bit and the tag of the last completed operation from the command c"
        "hain.")
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_dcp_ch0stat
    },
    {
        "CH0OPTS",
        DESC("The DCP Channel 0 Options Status register contains optional control in"
        "formation that may be used to further tune the behavior of the channel"
        ".")
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcp_ch0opts
    },
    {
        "CH1CMDPTR",
        DESC("The DCP channel 1 current command address register points to the multi"
        "word descriptor that is to be executed (or currently being executed).")
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcp_ch1cmdptr
    },
    {
        "CH1SEMA",
        DESC("The DCP Channel 1 semaphore register is used to synchronize the ARM pl"
        "atform instruction stream and the DMA chain processing state.")
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dcp_ch1sema
    },
    {
        "CH1STAT",
        DESC("The DCP Channel 1 Interrupt Status register contains the interrupt sta"
        "tus bit and the tag of the last completed operation from the command c"
        "hain.")
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_dcp_ch1stat
    },
    {
        "CH1OPTS",
        DESC("The DCP Channel 1 Options Status register contains optional control in"
        "formation that may be used to further tune the behavior of the channel"
        ".")
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcp_ch1opts
    },
    {
        "CH2CMDPTR",
        DESC("The DCP channel 2 current command address register points to the multi"
        "word descriptor that is to be executed (or currently being executed).")
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcp_ch2cmdptr
    },
    {
        "CH2SEMA",
        DESC("The DCP Channel 2 semaphore register is used to synchronize the ARM pl"
        "atform instruction stream and the DMA chain processing state.")
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dcp_ch2sema
    },
    {
        "CH2STAT",
        DESC("The DCP Channel 2 Interrupt Status register contains the interrupt sta"
        "tus bit and the tag of the last completed operation from the command c"
        "hain.")
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_dcp_ch2stat
    },
    {
        "CH2OPTS",
        DESC("The DCP Channel 2 Options Status register contains optional control in"
        "formation that may be used to further tune the behavior of the channel"
        ".")
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcp_ch2opts
    },
    {
        "CH3CMDPTR",
        DESC("The DCP channel 3 current command address register points to the multi"
        "word descriptor that is to be executed (or currently being executed).")
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcp_ch3cmdptr
    },
    {
        "CH3SEMA",
        DESC("The DCP Channel 3 semaphore register is used to synchronize the ARM pl"
        "atform instruction stream and the DMA chain processing state.")
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dcp_ch3sema
    },
    {
        "CH3STAT",
        DESC("The DCP Channel 3 Interrupt Status register contains the interrupt sta"
        "tus bit and the tag of the last completed operation from the command c"
        "hain.")
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_dcp_ch3stat
    },
    {
        "CH3OPTS",
        DESC("The DCP Channel 3 Options Status register contains optional control in"
        "formation that may be used to further tune the behavior of the channel"
        ".")
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcp_ch3opts
    },
    {
        "DBGSELECT",
        DESC("This register selects a debug register to view.")
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcp_dbgselect
    },
    {
        "DBGDATA",
        DESC("Reading this register returns the debug data value from the selected i"
        "ndex.")
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_dcp_dbgdata
    },
    {
        "PAGETABLE",
        DESC("The DCP Page Table register controls the virtual memory functionality "
        "of the DCP.")
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dcp_pagetable
    },
    {
        "VERSION",
        DESC("Read-only register indicating implemented version of the DCP.")
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_dcp_version
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark DVFSC
#endif

// Bitfields in register DVFSC_THRS.
static const field_t hw_dvfsc_thrs[] =
{
    {
        "PNCTHR",
        DESC("Panic threshold for load tracking")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DWTHR",
        DESC("Down threshold for load tracking")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPTHR",
        DESC("Upper threshold for load tracking")
        22, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_COUN.
static const field_t hw_dvfsc_coun[] =
{
    {
        "UPCNT",
        DESC("UP counter threshold value")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DN_CNT",
        DESC("Down counter threshold value")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_SIG1.
static const field_t hw_dvfsc_sig1[] =
{
    {
        "WSW6",
        DESC("General purpose load tracking signal weight dvfs_w_sig[6]")
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW7",
        DESC("General purpose load tracking signal weight dvfs_w_sig[7]")
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW8",
        DESC("General purpose load tracking signal weight dvfs_w_sig[8]")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW9",
        DESC("General purpose load tracking signal weight dvfs_w_sig[9]")
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW10",
        DESC("General purpose load tracking signal weight dvfs_w_sig[10]")
        14, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW11",
        DESC("General purpose load tracking signal weight dvfs_w_sig[11]")
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW12",
        DESC("General purpose load tracking signal weight dvfs_w_sig[12]")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW13",
        DESC("General purpose load tracking signal weight dvfs_w_sig[13]")
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW14",
        DESC("General purpose load tracking signal weight dvfs_w_sig[14]")
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW15",
        DESC("General purpose load tracking signal weight dvfs_w_sig[15]")
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSSIG0.
static const field_t hw_dvfsc_dvfssig0[] =
{
    {
        "WSW0",
        DESC("General purpose load tracking signal weight dvfs_w_sig[0].")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW1",
        DESC("General purpose load tracking signal weight dvfs_w_sig[1].")
        6, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW2",
        DESC("General purpose load tracking signal weight dvfs_w_sig[2]")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW3",
        DESC("General purpose load tracking signal weight dvfs_w_sig[3]")
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW4",
        DESC("General purpose load tracking signal weight dvfs_w_sig[4]")
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSW5",
        DESC("General purpose load tracking signal weight dvfs_w_sig[5]")
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSGPC0.
static const field_t hw_dvfsc_dvfsgpc0[] =
{
    {
        "GPBC0",
        DESC("GPBC0 - General Purpose bits Counter 0  During period of this counter "
        "the GeP bit 0 will be set and WSW0 will be added to the calculations.")
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C0ACT",
        DESC("C0ACT - Counter 0 active indicator")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "C0STRT",
        DESC("C0STRT - Counter 0 start  Setting of this bit will initialize down cou"
        "nting of the GPC0 value.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSGPC1.
static const field_t hw_dvfsc_dvfsgpc1[] =
{
    {
        "GPBC1",
        DESC("GPBC1 - General Purpose bits Counter 1  During period of this counter "
        "the GeP bit 1 will be set and WSW1 will be added to the calculations.")
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C1ACT",
        DESC("C1ACT - Counter 1 active indicator")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "C1STRT",
        DESC("C1STRT - Counter 1start  Setting of this bit will initialize down coun"
        "ting of the GPC1 value.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSGPBT.
static const field_t hw_dvfsc_dvfsgpbt[] =
{
    {
        "GPB0",
        DESC("General purpose bit 0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB1",
        DESC("General purpose bit 1.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB2",
        DESC("General purpose bit 2.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB3",
        DESC("General purpose bit 3.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB4",
        DESC("General purpose bit 4.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB5",
        DESC("General purpose bit 5.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB6",
        DESC("General purpose bit 6.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB7",
        DESC("General purpose bit 7.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB8",
        DESC("General purpose bit 8.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB9",
        DESC("General purpose bit 9.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB10",
        DESC("General purpose bit 10.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB11",
        DESC("General purpose bit 11.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB12",
        DESC("General purpose bit 12.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB13",
        DESC("General purpose bit 13.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB14",
        DESC("General purpose bit 14.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPB15",
        DESC("General purpose bit 15.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSEMAC.
static const field_t hw_dvfsc_dvfsemac[] =
{
    {
        "EMAC",
        DESC("EMAC - EMA control value")
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFEN0",
        DESC("DVFS tracking for core0 enable.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSVAI0",
        DESC("DVFS Frequency adjustment status of core 0.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFIM0",
        DESC("DVFS Wait for Interrupt of core 0 mask bit")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_CNTR.
static const field_t hw_dvfsc_cntr[] =
{
    {
        "LTBRSR",
        DESC("LTBRSR - Load Tracking Buffer Register Source:")
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LTBRSH",
        DESC("LTBRSH - Load Tracking Buffer Register Shift:")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFUS",
        DESC("PFUS - Periodic Frequency Update Status")
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFUE",
        DESC("PFUE - Period Frequency Update Enable")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV_RATIO",
        DESC("DIV_RATIO - Divider value.")
        11, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MINF",
        DESC("Minimum frequency reached.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAXF",
        DESC("Maximum frequency reached.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSVAI",
        DESC("FSVAI  DVFS Frequency adjustment interrupt.")
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FSVAIM",
        DESC("DVFS Frequency adjustment interrupt mask.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIRQS",
        DESC("PIRQS - Pattern IRQ Source  * write '1' to clear.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFIS",
        DESC("DVFS Interrupt select.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBFL0",
        DESC("Load buffer 0 - full status bit.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBFL1",
        DESC("Load buffer 1 - full status bit.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBMI",
        DESC("Load buffer full mask interrupt.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFEV",
        DESC("Always give a DVFS event.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV3CK",
        DESC("DIV3CK - div_3_clk division ratio inside the DVFS module.")
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSLTR0_0.
static const field_t hw_dvfsc_dvfsltr0_0[] =
{
    {
        "LTS0_0",
        DESC("core 0 Load Tracking Sample 0")
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_1",
        DESC("core 0 Load Tracking Sample 1")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_2",
        DESC("core 0 Load Tracking Sample 2")
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_3",
        DESC("core 0 Load Tracking Sample 3")
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_4",
        DESC("core 0 Load Tracking Sample 4")
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_5",
        DESC("core 0 Load Tracking Sample 5")
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_6",
        DESC("core 0 Load Tracking Sample 6")
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_7",
        DESC("core 0 Load Tracking Sample 7")
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSLTR0_1.
static const field_t hw_dvfsc_dvfsltr0_1[] =
{
    {
        "LTS0_8",
        DESC("core 0 Load Tracking Sample 8")
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_9",
        DESC("core 0 Load Tracking Sample 9")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_10",
        DESC("core 0 Load Tracking Sample 10")
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_11",
        DESC("core 0 Load Tracking Sample 11")
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_12",
        DESC("core 0 Load Tracking Sample 12")
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_13",
        DESC("core 0 Load Tracking Sample 13")
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_14",
        DESC("core 0 Load Tracking Sample 14")
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS0_15",
        DESC("core 0 Load Tracking Sample 15")
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSLTR1_0.
static const field_t hw_dvfsc_dvfsltr1_0[] =
{
    {
        "LTS1_0",
        DESC("core 0 Load Tracking Sample 0")
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_1",
        DESC("core 0 Load Tracking Sample 1")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_2",
        DESC("core 0 Load Tracking Sample 2")
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_3",
        DESC("core 0 Load Tracking Sample 3")
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_4",
        DESC("core 0 Load Tracking Sample 4")
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_5",
        DESC("core 0 Load Tracking Sample 5")
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_6",
        DESC("core 0 Load Tracking Sample 6")
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_7",
        DESC("core 0 Load Tracking Sample 7")
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSLTR1_1.
static const field_t hw_dvfsc_dvfsltr1_1[] =
{
    {
        "LTS1_8",
        DESC("core 0 Load Tracking Sample 8")
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_9",
        DESC("core 0 Load Tracking Sample 9")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_10",
        DESC("core 0 Load Tracking Sample 10")
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_11",
        DESC("core 0 Load Tracking Sample 11")
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_12",
        DESC("core 0 Load Tracking Sample 12")
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_13",
        DESC("core 0 Load Tracking Sample 13")
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_14",
        DESC("core 0 Load Tracking Sample 14")
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LTS1_15",
        DESC("core 0 Load Tracking Sample 15")
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSPT0.
static const field_t hw_dvfsc_dvfspt0[] =
{
    {
        "FPTN0",
        DESC("FPTN0 - Frequency pattern 0 counter  During period of this counter the"
        " frequency will be reduced from the EMA-detected level.")
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PT0A",
        DESC("PT0A - Pattern 0 currently active (read-only)")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSPT1.
static const field_t hw_dvfsc_dvfspt1[] =
{
    {
        "FPTN1",
        DESC("FPTN1 - Frequency pattern 1 counter  During period of this counter the"
        " frequency will be set to the EMA-detected level.")
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PT1A",
        DESC("PT1A - Pattern 1 currently active (read-only)")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSPT2.
static const field_t hw_dvfsc_dvfspt2[] =
{
    {
        "FPTN2",
        DESC("FPTN2 - Frequency pattern 2 counter  During period of this counter the"
        " frequency will be increased to higher, than detected by the EMA-detec"
        "ted level.")
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PT2A",
        DESC("PT2A - Pattern 2 currently active (read-only)")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "P2THR",
        DESC("P2THR - Pattern 2 Threshold  Threshold of current DVFS load (after EMA"
        "), for generating interrupts with PFUS indicators 110, 111.")
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DVFSC_DVFSPT3.
static const field_t hw_dvfsc_dvfspt3[] =
{
    {
        "FPTN3",
        DESC("FPTN3 - Frequency pattern 3 counter  During period of this counter the"
        " frequency will be set to the EMA-detected level.")
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PT3A",
        DESC("PT3A - Pattern 3 currently active (read-only)")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a DVFSC module.
static const reg_t hw_dvfsc[] =
{
    {
        "THRS",
        DESC("")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dvfsc_thrs
    },
    {
        "COUN",
        DESC("")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dvfsc_coun
    },
    {
        "SIG1",
        DESC("")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dvfsc_sig1
    },
    {
        "DVFSSIG0",
        DESC("")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_dvfsc_dvfssig0
    },
    {
        "DVFSGPC0",
        DESC("DVFS general purpose bits weight counter.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dvfsc_dvfsgpc0
    },
    {
        "DVFSGPC1",
        DESC("DVFS general purpose bits weight counter1.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dvfsc_dvfsgpc1
    },
    {
        "DVFSGPBT",
        DESC("")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_dvfsc_dvfsgpbt
    },
    {
        "DVFSEMAC",
        DESC("")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dvfsc_dvfsemac
    },
    {
        "CNTR",
        DESC("DIV3CK division         DIV3CK setting  dividing ratio  sum_3 passing "
        "bits  div_1_clk cumulative divider      00  1  4-0  1*512=512    001  "
        "4  6-2  4*512=2048    010  16  8-4  16*512=8192    011  64  10-6  64*5"
        "12=32768    100  256  12-8  256*512=131072    101  1024  16-10  1024*5"
        "12=524288       Preliminary Divider definition       DIV_RATIO value  "
        "ARM clk division ratio      000000  1    000001  2    000010  3    ...")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_dvfsc_cntr
    },
    {
        "DVFSLTR0_0",
        DESC("")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_dvfsc_dvfsltr0_0
    },
    {
        "DVFSLTR0_1",
        DESC("")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_dvfsc_dvfsltr0_1
    },
    {
        "DVFSLTR1_0",
        DESC("")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_dvfsc_dvfsltr1_0
    },
    {
        "DVFSLTR1_1",
        DESC("")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_dvfsc_dvfsltr1_1
    },
    {
        "DVFSPT0",
        DESC("")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dvfsc_dvfspt0
    },
    {
        "DVFSPT1",
        DESC("")
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dvfsc_dvfspt1
    },
    {
        "DVFSPT2",
        DESC("")
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dvfsc_dvfspt2
    },
    {
        "DVFSPT3",
        DESC("")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dvfsc_dvfspt3
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ECSPI
#endif

// Bitfields in register ECSPI_RXDATA.
static const field_t hw_ecspi_rxdata[] =
{
    {
        "ECSPI_RXDATA",
        DESC("Receive Data.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_TXDATA.
static const field_t hw_ecspi_txdata[] =
{
    {
        "ECSPI_TXDATA",
        DESC("Transmit Data.")
        0, // LSB
        31, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_CONREG.
static const field_t hw_ecspi_conreg[] =
{
    {
        "EN",
        DESC("SPI Block Enable Control.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HT",
        DESC("Hardware Trigger Enable.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XCH",
        DESC("SPI Exchange Bit.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMC",
        DESC("Start Mode Control.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHANNEL_MODE",
        DESC("SPI CHANNEL MODE selects the mode for each SPI channel.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIVIDER",
        DESC("SPI Post Divider.")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRE_DIVIDER",
        DESC("SPI Pre Divider.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRCTL",
        DESC("SPI Data Ready Control.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHANNEL_SELECT",
        DESC("SPI CHANNEL SELECT bits.")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_LENGTH",
        DESC("Burst Length.")
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_CONFIGREG.
static const field_t hw_ecspi_configreg[] =
{
    {
        "SCLK_PHA",
        DESC("SPI Clock/Data Phase Control.")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCLK_POL",
        DESC("SPI Clock Polarity Control.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SS_CTL",
        DESC("SPI SS Wave Form Select.")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SS_POL",
        DESC("SPI SS Polarity Select.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_CTL",
        DESC("DATA CTL.")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCLK_CTL",
        DESC("SCLK CTL.")
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HT_LENGTH",
        DESC("HT LENGTH.")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_INTREG.
static const field_t hw_ecspi_intreg[] =
{
    {
        "TEEN",
        DESC("TXFIFO Empty Interrupt enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDREN",
        DESC("TXFIFO Data Request Interrupt enable.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEN",
        DESC("TXFIFO Full Interrupt enable.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RREN",
        DESC("RXFIFO Ready Interrupt enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDREN",
        DESC("RXFIFO Data Request Interrupt enable.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN",
        DESC("RXFIFO Full Interrupt enable.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROEN",
        DESC("RXFIFO Overflow Interrupt enable.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCEN",
        DESC("Transfer Completed Interrupt enable.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_DMAREG.
static const field_t hw_ecspi_dmareg[] =
{
    {
        "TX_THRESHOLD",
        DESC("TX THRESHOLD.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEDEN",
        DESC("TXFIFO Empty DMA Request Enable.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_THRESHOLD",
        DESC("RX THRESHOLD.")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDEN",
        DESC("RXFIFO DMA Request Enable.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_DMA_LENGTH",
        DESC("RX DMA LENGTH.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXTDEN",
        DESC("RXFIFO TAIL DMA Request Enable.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_STATREG.
static const field_t hw_ecspi_statreg[] =
{
    {
        "TE",
        DESC("TXFIFO Empty.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDR",
        DESC("TXFIFO Data Request.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF",
        DESC("TXFIFO Full.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RR",
        DESC("RXFIFO Ready.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDR",
        DESC("RXFIFO Data Request.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RF",
        DESC("RXFIFO Full.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RO",
        DESC("RXFIFO Overflow.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TC",
        DESC("Transfer Completed Status bit.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_PERIODREG.
static const field_t hw_ecspi_periodreg[] =
{
    {
        "SAMPLE_PERIOD",
        DESC("Sample Period Control.")
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSRC",
        DESC("Clock Source Control.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSD_CTL",
        DESC("Chip Select Delay Control bits.")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_TESTREG.
static const field_t hw_ecspi_testreg[] =
{
    {
        "TXCNT",
        DESC("TXFIFO Counter.")
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXCNT",
        DESC("RXFIFO Counter.")
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBC",
        DESC("Loop Back Control.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_MSGDATA.
static const field_t hw_ecspi_msgdata[] =
{
    {
        "ECSPI_MSGDATA",
        DESC("ECSPI_MSGDATA holds the top word of MSG Data FIFO.")
        0, // LSB
        31, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ECSPI module.
static const reg_t hw_ecspi[] =
{
    {
        "RXDATA",
        DESC("The Receive Data register (ECSPI_RXDATA) is a read-only register that "
        "forms the top word of the 64 x 32 receive FIFO.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ecspi_rxdata
    },
    {
        "TXDATA",
        DESC("The Transmit Data (ECSPI_TXDATA) register is a write-only data registe"
        "r that forms the bottom word of the 64 x 32 TXFIFO.")
        4, // Width in bytes
        0x00000004, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ecspi_txdata
    },
    {
        "CONREG",
        DESC("The Control Register (ECSPI_CONREG) allows software to enable the ECSP"
        "I , configure its operating modes, specify the divider value, and SPI_"
        "RDY control signal, and define the transfer length.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ecspi_conreg
    },
    {
        "CONFIGREG",
        DESC("The Config Register (ECSPI_CONFIGREG) allows software to configure eac"
        "h SPI channel, configure its operating modes, specify the phase and po"
        "larity of the clock, configure the Chip Select (SS), and define the HT"
        " transfer length.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ecspi_configreg
    },
    {
        "INTREG",
        DESC("The Interrupt Control Register (ECSPI_INTREG) enables the generation o"
        "f interrupts to the host processor.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ecspi_intreg
    },
    {
        "DMAREG",
        DESC("The Direct Memory Access Control Register (ECSPI_DMAREG) provides soft"
        "ware a way to use an on-chip DMA controller for ECSPI data.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ecspi_dmareg
    },
    {
        "STATREG",
        DESC("The ECSPI Status Register (ECSPI_STATREG) reflects the status of the E"
        "CSPI's operating condition.")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ecspi_statreg
    },
    {
        "PERIODREG",
        DESC("The Sample Period Control Register (ECSPI_PERIODREG) provides software"
        " a way to insert delays (wait states) between consecutive SPI transfer"
        "s.")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ecspi_periodreg
    },
    {
        "TESTREG",
        DESC("The Test Control Register (ECSPI_TESTREG) provides software a mechanis"
        "m to internally connect the receive and transmit devices of the ECSPI "
        " , and monitor the contents of the receive and transmit FIFOs.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ecspi_testreg
    },
    {
        "MSGDATA",
        DESC("The Message Data Register (ECSPI_MSGDATA) forms the top word of the 16"
        " x 32 MSG Data FIFO.")
        4, // Width in bytes
        0x00000040, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ecspi_msgdata
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark EIM
#endif

// Bitfields in register EIM_CS0GCR1.
static const field_t hw_eim_cs0gcr1[] =
{
    {
        "CSEN",
        DESC("CS Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        DESC("Synchronous Write Data.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        DESC("Synchronous Read Data.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        DESC("Multiplexed Mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        DESC("Write Fix Latency.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        DESC("Read Fix Latency.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        DESC("Configuration Register Enable.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        DESC("Configuration Register Enable Polarity.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        DESC("Burst Length.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        DESC("Write Continuous.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        DESC("Burst Clock Divisor.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        DESC("Burst Clock Start.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        DESC("Data Port Size.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        DESC("Supervisor Protect.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        DESC("CS Recovery.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        DESC("Address UnShifted.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        DESC("Gap Between Chip Selects.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        DESC("Write Protect.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        DESC("Page Size.")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0GCR2.
static const field_t hw_eim_cs0gcr2[] =
{
    {
        "ADH",
        DESC("Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        DESC("Data Acknowledge Poling Start.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        DESC("Data Acknowledge Enable.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        DESC("Data Acknowledge Polarity.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        DESC("Muxed 16 bypass grant.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0RCR1.
static const field_t hw_eim_cs0rcr1[] =
{
    {
        "RCSN",
        DESC("Read CS Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        DESC("Read CS Assertion.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        DESC("OE Negation.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        DESC("OE Assertion.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        DESC("ADV Negation.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        DESC("Read ADV Low.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        DESC("ADV Assertion.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        DESC("Read Wait State Control.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0RCR2.
static const field_t hw_eim_cs0rcr2[] =
{
    {
        "RBEN",
        DESC("Read BE Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        DESC("Read BE enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        DESC("Read BE Assertion.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        DESC("Read Latency.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        DESC("Page Access Time.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        DESC("Asynchronous Page Read.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0WCR1.
static const field_t hw_eim_cs0wcr1[] =
{
    {
        "WCSN",
        DESC("Write CS Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        DESC("Write CS Assertion.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        DESC("WE Negation.")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        DESC("WE Assertion.")
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        DESC("BE[3:0] Negation.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        DESC("BE Assertion.")
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        DESC("ADV Negation.")
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        DESC("ADV Assertion.")
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        DESC("Write Wait State Control.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        DESC("Write Byte Enable Disable.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        DESC("Write ADV Low.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0WCR2.
static const field_t hw_eim_cs0wcr2[] =
{
    {
        "WBCDD",
        DESC("Write Burst Clock Divisor Decrement.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1GCR1.
static const field_t hw_eim_cs1gcr1[] =
{
    {
        "CSEN",
        DESC("CS Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        DESC("Synchronous Write Data.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        DESC("Synchronous Read Data.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        DESC("Multiplexed Mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        DESC("Write Fix Latency.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        DESC("Read Fix Latency.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        DESC("Configuration Register Enable.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        DESC("Configuration Register Enable Polarity.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        DESC("Burst Length.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        DESC("Write Continuous.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        DESC("Burst Clock Divisor.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        DESC("Burst Clock Start.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        DESC("Data Port Size.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        DESC("Supervisor Protect.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        DESC("CS Recovery.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        DESC("Address UnShifted.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        DESC("Gap Between Chip Selects.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        DESC("Write Protect.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        DESC("Page Size.")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1GCR2.
static const field_t hw_eim_cs1gcr2[] =
{
    {
        "ADH",
        DESC("Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        DESC("Data Acknowledge Poling Start.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        DESC("Data Acknowledge Enable.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        DESC("Data Acknowledge Polarity.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        DESC("Muxed 16 bypass grant.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1RCR1.
static const field_t hw_eim_cs1rcr1[] =
{
    {
        "RCSN",
        DESC("Read CS Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        DESC("Read CS Assertion.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        DESC("OE Negation.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        DESC("OE Assertion.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        DESC("ADV Negation.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        DESC("Read ADV Low.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        DESC("ADV Assertion.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        DESC("Read Wait State Control.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1RCR2.
static const field_t hw_eim_cs1rcr2[] =
{
    {
        "RBEN",
        DESC("Read BE Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        DESC("Read BE enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        DESC("Read BE Assertion.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        DESC("Read Latency.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        DESC("Page Access Time.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        DESC("Asynchronous Page Read.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1WCR1.
static const field_t hw_eim_cs1wcr1[] =
{
    {
        "WCSN",
        DESC("Write CS Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        DESC("Write CS Assertion.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        DESC("WE Negation.")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        DESC("WE Assertion.")
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        DESC("BE[3:0] Negation.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        DESC("BE Assertion.")
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        DESC("ADV Negation.")
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        DESC("ADV Assertion.")
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        DESC("Write Wait State Control.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        DESC("Write Byte Enable Disable.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        DESC("Write ADV Low.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1WCR2.
static const field_t hw_eim_cs1wcr2[] =
{
    {
        "WBCDD",
        DESC("Write Burst Clock Divisor Decrement.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2GCR1.
static const field_t hw_eim_cs2gcr1[] =
{
    {
        "CSEN",
        DESC("CS Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        DESC("Synchronous Write Data.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        DESC("Synchronous Read Data.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        DESC("Multiplexed Mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        DESC("Write Fix Latency.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        DESC("Read Fix Latency.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        DESC("Configuration Register Enable.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        DESC("Configuration Register Enable Polarity.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        DESC("Burst Length.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        DESC("Write Continuous.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        DESC("Burst Clock Divisor.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        DESC("Burst Clock Start.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        DESC("Data Port Size.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        DESC("Supervisor Protect.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        DESC("CS Recovery.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        DESC("Address UnShifted.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        DESC("Gap Between Chip Selects.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        DESC("Write Protect.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        DESC("Page Size.")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2GCR2.
static const field_t hw_eim_cs2gcr2[] =
{
    {
        "ADH",
        DESC("Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        DESC("Data Acknowledge Poling Start.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        DESC("Data Acknowledge Enable.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        DESC("Data Acknowledge Polarity.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        DESC("Muxed 16 bypass grant.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2RCR1.
static const field_t hw_eim_cs2rcr1[] =
{
    {
        "RCSN",
        DESC("Read CS Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        DESC("Read CS Assertion.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        DESC("OE Negation.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        DESC("OE Assertion.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        DESC("ADV Negation.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        DESC("Read ADV Low.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        DESC("ADV Assertion.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        DESC("Read Wait State Control.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2RCR2.
static const field_t hw_eim_cs2rcr2[] =
{
    {
        "RBEN",
        DESC("Read BE Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        DESC("Read BE enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        DESC("Read BE Assertion.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        DESC("Read Latency.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        DESC("Page Access Time.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        DESC("Asynchronous Page Read.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2WCR1.
static const field_t hw_eim_cs2wcr1[] =
{
    {
        "WCSN",
        DESC("Write CS Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        DESC("Write CS Assertion.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        DESC("WE Negation.")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        DESC("WE Assertion.")
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        DESC("BE[3:0] Negation.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        DESC("BE Assertion.")
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        DESC("ADV Negation.")
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        DESC("ADV Assertion.")
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        DESC("Write Wait State Control.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        DESC("Write Byte Enable Disable.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        DESC("Write ADV Low.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2WCR2.
static const field_t hw_eim_cs2wcr2[] =
{
    {
        "WBCDD",
        DESC("Write Burst Clock Divisor Decrement.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3GCR1.
static const field_t hw_eim_cs3gcr1[] =
{
    {
        "CSEN",
        DESC("CS Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        DESC("Synchronous Write Data.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        DESC("Synchronous Read Data.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        DESC("Multiplexed Mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        DESC("Write Fix Latency.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        DESC("Read Fix Latency.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        DESC("Configuration Register Enable.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        DESC("Configuration Register Enable Polarity.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        DESC("Burst Length.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        DESC("Write Continuous.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        DESC("Burst Clock Divisor.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        DESC("Burst Clock Start.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        DESC("Data Port Size.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        DESC("Supervisor Protect.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        DESC("CS Recovery.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        DESC("Address UnShifted.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        DESC("Gap Between Chip Selects.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        DESC("Write Protect.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        DESC("Page Size.")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3GCR2.
static const field_t hw_eim_cs3gcr2[] =
{
    {
        "ADH",
        DESC("Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        DESC("Data Acknowledge Poling Start.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        DESC("Data Acknowledge Enable.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        DESC("Data Acknowledge Polarity.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        DESC("Muxed 16 bypass grant.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3RCR1.
static const field_t hw_eim_cs3rcr1[] =
{
    {
        "RCSN",
        DESC("Read CS Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        DESC("Read CS Assertion.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        DESC("OE Negation.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        DESC("OE Assertion.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        DESC("ADV Negation.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        DESC("Read ADV Low.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        DESC("ADV Assertion.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        DESC("Read Wait State Control.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3RCR2.
static const field_t hw_eim_cs3rcr2[] =
{
    {
        "RBEN",
        DESC("Read BE Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        DESC("Read BE enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        DESC("Read BE Assertion.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        DESC("Read Latency.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        DESC("Page Access Time.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        DESC("Asynchronous Page Read.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3WCR1.
static const field_t hw_eim_cs3wcr1[] =
{
    {
        "WCSN",
        DESC("Write CS Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        DESC("Write CS Assertion.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        DESC("WE Negation.")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        DESC("WE Assertion.")
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        DESC("BE[3:0] Negation.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        DESC("BE Assertion.")
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        DESC("ADV Negation.")
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        DESC("ADV Assertion.")
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        DESC("Write Wait State Control.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        DESC("Write Byte Enable Disable.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        DESC("Write ADV Low.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3WCR2.
static const field_t hw_eim_cs3wcr2[] =
{
    {
        "WBCDD",
        DESC("Write Burst Clock Divisor Decrement.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4GCR1.
static const field_t hw_eim_cs4gcr1[] =
{
    {
        "CSEN",
        DESC("CS Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        DESC("Synchronous Write Data.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        DESC("Synchronous Read Data.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        DESC("Multiplexed Mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        DESC("Write Fix Latency.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        DESC("Read Fix Latency.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        DESC("Configuration Register Enable.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        DESC("Configuration Register Enable Polarity.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        DESC("Burst Length.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        DESC("Write Continuous.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        DESC("Burst Clock Divisor.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        DESC("Burst Clock Start.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        DESC("Data Port Size.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        DESC("Supervisor Protect.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        DESC("CS Recovery.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        DESC("Address UnShifted.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        DESC("Gap Between Chip Selects.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        DESC("Write Protect.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        DESC("Page Size.")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4GCR2.
static const field_t hw_eim_cs4gcr2[] =
{
    {
        "ADH",
        DESC("Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        DESC("Data Acknowledge Poling Start.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        DESC("Data Acknowledge Enable.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        DESC("Data Acknowledge Polarity.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        DESC("Muxed 16 bypass grant.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4RCR1.
static const field_t hw_eim_cs4rcr1[] =
{
    {
        "RCSN",
        DESC("Read CS Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        DESC("Read CS Assertion.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        DESC("OE Negation.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        DESC("OE Assertion.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        DESC("ADV Negation.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        DESC("Read ADV Low.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        DESC("ADV Assertion.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        DESC("Read Wait State Control.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4RCR2.
static const field_t hw_eim_cs4rcr2[] =
{
    {
        "RBEN",
        DESC("Read BE Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        DESC("Read BE enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        DESC("Read BE Assertion.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        DESC("Read Latency.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        DESC("Page Access Time.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        DESC("Asynchronous Page Read.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4WCR1.
static const field_t hw_eim_cs4wcr1[] =
{
    {
        "WCSN",
        DESC("Write CS Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        DESC("Write CS Assertion.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        DESC("WE Negation.")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        DESC("WE Assertion.")
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        DESC("BE[3:0] Negation.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        DESC("BE Assertion.")
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        DESC("ADV Negation.")
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        DESC("ADV Assertion.")
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        DESC("Write Wait State Control.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        DESC("Write Byte Enable Disable.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        DESC("Write ADV Low.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4WCR2.
static const field_t hw_eim_cs4wcr2[] =
{
    {
        "WBCDD",
        DESC("Write Burst Clock Divisor Decrement.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5GCR1.
static const field_t hw_eim_cs5gcr1[] =
{
    {
        "CSEN",
        DESC("CS Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        DESC("Synchronous Write Data.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        DESC("Synchronous Read Data.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        DESC("Multiplexed Mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        DESC("Write Fix Latency.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        DESC("Read Fix Latency.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        DESC("Configuration Register Enable.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        DESC("Configuration Register Enable Polarity.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        DESC("Burst Length.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        DESC("Write Continuous.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        DESC("Burst Clock Divisor.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        DESC("Burst Clock Start.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        DESC("Data Port Size.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        DESC("Supervisor Protect.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        DESC("CS Recovery.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        DESC("Address UnShifted.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        DESC("Gap Between Chip Selects.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        DESC("Write Protect.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        DESC("Page Size.")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5GCR2.
static const field_t hw_eim_cs5gcr2[] =
{
    {
        "ADH",
        DESC("Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        DESC("Data Acknowledge Poling Start.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        DESC("Data Acknowledge Enable.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        DESC("Data Acknowledge Polarity.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        DESC("Muxed 16 bypass grant.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5RCR1.
static const field_t hw_eim_cs5rcr1[] =
{
    {
        "RCSN",
        DESC("Read CS Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        DESC("Read CS Assertion.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        DESC("OE Negation.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        DESC("OE Assertion.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        DESC("ADV Negation.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        DESC("Read ADV Low.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        DESC("ADV Assertion.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        DESC("Read Wait State Control.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5RCR2.
static const field_t hw_eim_cs5rcr2[] =
{
    {
        "RBEN",
        DESC("Read BE Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        DESC("Read BE enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        DESC("Read BE Assertion.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        DESC("Read Latency.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        DESC("Page Access Time.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        DESC("Asynchronous Page Read.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5WCR1.
static const field_t hw_eim_cs5wcr1[] =
{
    {
        "WCSN",
        DESC("Write CS Negation.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        DESC("Write CS Assertion.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        DESC("WE Negation.")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        DESC("WE Assertion.")
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        DESC("BE[3:0] Negation.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        DESC("BE Assertion.")
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        DESC("ADV Negation.")
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        DESC("ADV Assertion.")
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        DESC("Write Wait State Control.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        DESC("Write Byte Enable Disable.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        DESC("Write ADV Low.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5WCR2.
static const field_t hw_eim_cs5wcr2[] =
{
    {
        "WBCDD",
        DESC("Write Burst Clock Divisor Decrement.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_WCR.
static const field_t hw_eim_wcr[] =
{
    {
        "BCM",
        DESC("Burst Clock Mode.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBCD",
        DESC("General Burst Clock Divisor.")
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONT_BCLK_SEL",
        DESC("When this bit is set BCLK pin output continuous clock.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTEN",
        DESC("Interrupt Enable.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTPOL",
        DESC("Interrupt Polarity.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_EN",
        DESC("Memory WDog enable.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_LIMIT",
        DESC("Memory Watch Dog (WDog) cycle limit.")
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRUN_ACLK_EN",
        DESC("")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_DCR.
static const field_t hw_eim_dcr[] =
{
    {
        "DLL_CTRL_ENABLE",
        DESC("")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_RESET",
        DESC("")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_FORCE_UPD",
        DESC("")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OFFSET_DEC",
        DESC("")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OFFSET",
        DESC("")
        4, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_CTRL_GATE_UPDATE",
        DESC("")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE",
        DESC("Use override value in DLL_CTRL_SLV_OVERRIDE_VAL bit field instead of D"
        "LL locked value as delay.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE_VAL",
        DESC("")
        9, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_REF_INITIAL_VAL",
        DESC("")
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_UPDATE_INT",
        DESC("Update interval of slave DLL.")
        23, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_REF_UPDATE_INT",
        DESC("Update interval of reference DLL.")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_DSR.
static const field_t hw_eim_dsr[] =
{
    {
        "DLL_STS_SLV_LOCK",
        DESC("")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_STS_REF_LOCK",
        DESC("")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_STS_SLV_SEL",
        DESC("")
        2, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_STS_REF_SEL",
        DESC("")
        9, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_WIAR.
static const field_t hw_eim_wiar[] =
{
    {
        "IPS_REQ",
        DESC("IPS request.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPS_ACK",
        DESC("IPS ACK.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT",
        DESC("Interrupt.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERRST",
        DESC("READY After Reset.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EN",
        DESC("ACLK enable.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_EAR.
static const field_t hw_eim_ear[] =
{
    {
        "ERROR_ADDR",
        DESC("Error Address.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a EIM module.
static const reg_t hw_eim[] =
{
    {
        "CS0GCR1",
        DESC("")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs0gcr1
    },
    {
        "CS0GCR2",
        DESC("")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs0gcr2
    },
    {
        "CS0RCR1",
        DESC("")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs0rcr1
    },
    {
        "CS0RCR2",
        DESC("")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs0rcr2
    },
    {
        "CS0WCR1",
        DESC("")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs0wcr1
    },
    {
        "CS0WCR2",
        DESC("")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs0wcr2
    },
    {
        "CS1GCR1",
        DESC("")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs1gcr1
    },
    {
        "CS1GCR2",
        DESC("")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs1gcr2
    },
    {
        "CS1RCR1",
        DESC("")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs1rcr1
    },
    {
        "CS1RCR2",
        DESC("")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs1rcr2
    },
    {
        "CS1WCR1",
        DESC("")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs1wcr1
    },
    {
        "CS1WCR2",
        DESC("")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs1wcr2
    },
    {
        "CS2GCR1",
        DESC("")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs2gcr1
    },
    {
        "CS2GCR2",
        DESC("")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs2gcr2
    },
    {
        "CS2RCR1",
        DESC("")
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs2rcr1
    },
    {
        "CS2RCR2",
        DESC("")
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs2rcr2
    },
    {
        "CS2WCR1",
        DESC("")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs2wcr1
    },
    {
        "CS2WCR2",
        DESC("")
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs2wcr2
    },
    {
        "CS3GCR1",
        DESC("")
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs3gcr1
    },
    {
        "CS3GCR2",
        DESC("")
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs3gcr2
    },
    {
        "CS3RCR1",
        DESC("")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs3rcr1
    },
    {
        "CS3RCR2",
        DESC("")
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs3rcr2
    },
    {
        "CS3WCR1",
        DESC("")
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs3wcr1
    },
    {
        "CS3WCR2",
        DESC("")
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs3wcr2
    },
    {
        "CS4GCR1",
        DESC("")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs4gcr1
    },
    {
        "CS4GCR2",
        DESC("")
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs4gcr2
    },
    {
        "CS4RCR1",
        DESC("")
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs4rcr1
    },
    {
        "CS4RCR2",
        DESC("")
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs4rcr2
    },
    {
        "CS4WCR1",
        DESC("")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs4wcr1
    },
    {
        "CS4WCR2",
        DESC("")
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs4wcr2
    },
    {
        "CS5GCR1",
        DESC("")
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs5gcr1
    },
    {
        "CS5GCR2",
        DESC("")
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs5gcr2
    },
    {
        "CS5RCR1",
        DESC("")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs5rcr1
    },
    {
        "CS5RCR2",
        DESC("")
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs5rcr2
    },
    {
        "CS5WCR1",
        DESC("")
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs5wcr1
    },
    {
        "CS5WCR2",
        DESC("")
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs5wcr2
    },
    {
        "WCR",
        DESC("")
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_wcr
    },
    {
        "DCR",
        DESC("")
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_dcr
    },
    {
        "DSR",
        DESC("")
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_eim_dsr
    },
    {
        "WIAR",
        DESC("")
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_wiar
    },
    {
        "EAR",
        DESC("")
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_ear
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LCDIF
#endif

// Bitfields in register LCDIF_CTRL.
static const field_t hw_lcdif_ctrl[] =
{
    {
        "RUN",
        DESC("When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        DESC("Used only when WORD_LENGTH = 3, i.e.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        DESC("Used only when WORD_LENGTH = 2, i.e.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        DESC("When this bit is 1 and WORD_LENGTH = 0, it implies that the the 16-bit"
        " data is in ARGB555 format.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASTER",
        DESC("Set this bit to make the eLCDIF act as a bus master.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PXP_HANDSHAKE",
        DESC("If this bit is set and LCDIF_MASTER bit is set, the eLCDIF will act as"
        " bus master and the handshake mechanism between eLCDIF and ePXP will b"
        "e turned on.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB_TO_YCBCR422_CSC",
        DESC("Set this bit to 1 to enable conversion from RGB to YCbCr colorspace.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        DESC("Input data format.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        DESC("LCD Data bus transfer width.")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        DESC("This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        DESC("This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SELECT",
        DESC("Command Mode polarity bit.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        DESC("Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_MODE",
        DESC("Setting this bit to 1 will make the eLCDIF hardware go into VSYNC mode"
        ".")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        DESC("When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVI_MODE",
        DESC("Set this bit to 1 to get into theITU-R BT.656 digital video interface "
        "mode.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        DESC("The data to be transmitted is shifted left or right by this number of "
        "bits.")
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        DESC("Use this bit to determine the direction of shift of transmit data.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT_FOR_VSYNC_EDGE",
        DESC("Setting this bit to 1 will make the hardware wait for the triggering V"
        "SYNC edge before starting write transfers to the LCD.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_WRITEB",
        DESC("By default, eLCDIF is in the write mode.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        DESC("Zero implies input data is in RGB color space.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        DESC("This bit must be set to zero for normal operation.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        DESC("This bit must be set to zero to enable normal operation of the eLCDIF.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1.
static const field_t hw_lcdif_ctrl1[] =
{
    {
        "RESET",
        DESC("Reset bit for the external LCD controller.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE86",
        DESC("This bit is used to select between the 8080 and 6800 series of micropr"
        "ocessor modes.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY_ENABLE",
        DESC("This bit enables the use of the interface's busy signal input.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        DESC("This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        DESC("This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        DESC("This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        DESC("This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        DESC("This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        DESC("This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        DESC("This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        DESC("This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        DESC("This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        DESC("If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        DESC("Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        DESC("The default is to grab the odd lines first and then the even lines.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        DESC("Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        DESC("Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        DESC("This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        DESC("This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMBINE_MPU_WR_STRB",
        DESC("If this bit is not set, the write strobe will be driven on LCD_WR_RWn "
        "pin in the 8080 mode and on the LCD_RD_E pin in the 6800 mode.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2.
static const field_t hw_lcdif_ctrl2[] =
{
    {
        "INITIAL_DUMMY_READ",
        DESC("The value in this field determines the number of dummy 8/16/18/24-bit "
        "subwords that have to be read back from the LCD panel/controller.")
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_NUM_PACKED_SUBWORDS",
        DESC("Indicates the number of valid 8/16/18/24-bit subwords that will be pac"
        "ked into the 32-bit word in read mode.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_6_BIT_INPUT",
        DESC("Setting this bit to 1 indicates to eLCDIF that even though LCD_DATABUS"
        "_WIDTH is set to 8 bits, the input data is actually only 6 bits wide a"
        "nd exists on D5-D0.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_OUTPUT_IN_RGB_FORMAT",
        DESC("Setting this bit will enable the eLCDIF to convert the incoming data t"
        "o the RGB format given by WORD_LENGTH bitfield.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_PACK_DIR",
        DESC("The default value of 0 indicates data is stored in the little endian f"
        "ormat.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        DESC("This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,..).")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODD_LINE_PATTERN",
        DESC("This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,..).")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_LEN_8",
        DESC("By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        DESC("This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.")
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_TRANSFER_COUNT.
static const field_t hw_lcdif_transfer_count[] =
{
    {
        "H_COUNT",
        DESC("Total valid data (pixels) in each horizontal line.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V_COUNT",
        DESC("Number of horizontal lines per frame which contain valid data.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CUR_BUF.
static const field_t hw_lcdif_cur_buf[] =
{
    {
        "ADDR",
        DESC("-")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_NEXT_BUF.
static const field_t hw_lcdif_next_buf[] =
{
    {
        "ADDR",
        DESC("-")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_TIMING.
static const field_t hw_lcdif_timing[] =
{
    {
        "DATA_SETUP",
        DESC("Data bus setup time in CLK_DIS_LCDIFn cycles.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_HOLD",
        DESC("Data bus hold time in CLK_DIS_LCDIFn cycles.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_SETUP",
        DESC("Number of CLK_DIS_LCDIFn cycles that the the DCn signal is active befo"
        "re CEn is asserted.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_HOLD",
        DESC("Number of CLK_DIS_LCDIFn cycles that the DCn signal is active after CE"
        "n is deasserted.")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0.
static const field_t hw_lcdif_vdctrl0[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        DESC("Number of units for which VSYNC signal is active.")
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        DESC("When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        DESC("Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        DESC("Default 0 for counting VSYNC_PULSE_WIDTH in terms of CLK_DIS_LCDIFn cy"
        "cles.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        DESC("Default 0 for counting VSYNC_PERIOD in terms of CLK_DIS_LCDIFn cycles.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_POL",
        DESC("Default 0 active low during valid data transfer on each horizontal lin"
        "e.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        DESC("Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        DESC("Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        DESC("Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        DESC("Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        DESC("0 means the VSYNC signal is an output, 1 means it is an input.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL1.
static const field_t hw_lcdif_vdctrl1[] =
{
    {
        "VSYNC_PERIOD",
        DESC("Total number of units between two positive or two negative edges of th"
        "e VSYNC signal.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL2.
static const field_t hw_lcdif_vdctrl2[] =
{
    {
        "HSYNC_PERIOD",
        DESC("Total number of CLK_DIS_LCDIFn cycles between two positive or two nega"
        "tive edges of the HSYNC signal.")
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_PULSE_WIDTH",
        DESC("Number of CLK_DIS_LCDIFn cycles for which HSYNC signal is active.")
        18, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL3.
static const field_t hw_lcdif_vdctrl3[] =
{
    {
        "VERTICAL_WAIT_CNT",
        DESC("In the VSYNC interface mode, wait for this number of CLK_DIS_LCDIFn cy"
        "cles from the falling VSYNC edge (or rising if VSYNC_POL is 1) before "
        "starting LCD transactions and is applicable only if WAIT_FOR_VSYNC_EDG"
        "E is set.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HORIZONTAL_WAIT_CNT",
        DESC("In the DOTCLK mode, wait for this number of clocks from falling edge ("
        "or rising if HSYNC_POL is 1) of HSYNC signal to account for horizontal"
        " back porch plus the number of DOTCLKs before the moving picture infor"
        "mation begins.")
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_ONLY",
        DESC("This bit must be set to 1 in the VSYNC mode of operation, and 0 in the"
        " DOTCLK mode of operation.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_SYNC_SIGNALS",
        DESC("When this bit is set, the eLCDIF block will internally mux HSYNC with "
        "LCD_D14, DOTCLK with LCD_D13 and ENABLE with LCD_D12, otherwise these "
        "signals will go out on separate pins.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL4.
static const field_t hw_lcdif_vdctrl4[] =
{
    {
        "DOTCLK_H_VALID_DATA_CNT",
        DESC("Total number of CLK_DIS_LCDIFn cycles on each horizontal line that car"
        "ry valid data in DOTCLK mode.")
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC_SIGNALS_ON",
        DESC("Set this field to 1 if the LCD controller requires that the VSYNC or V"
        "SYNC/HSYNC/DOTCLK control signals should be active atleast one frame b"
        "efore the data transfers actually start and remain active atleast one "
        "frame after the data transfers end.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_DLY_SEL",
        DESC("This bitfield selects the amount of time by which the DOTCLK signal sh"
        "ould be delayed before coming out of the LCD_DOTCK pin.")
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL0.
static const field_t hw_lcdif_dvictrl0[] =
{
    {
        "H_BLANKING_CNT",
        DESC("Number of blanking samples to be inserted between EAV and SAV during h"
        "orizontal blanking interval.")
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "H_ACTIVE_CNT",
        DESC("Number of active video samples to be transmitted.")
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL1.
static const field_t hw_lcdif_dvictrl1[] =
{
    {
        "F2_START_LINE",
        DESC("Vertical line number from which Field 2 begins.")
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1_END_LINE",
        DESC("Vertical line number at which Field1 ends.")
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1_START_LINE",
        DESC("Vertical line number from which Field 1 begins.")
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL2.
static const field_t hw_lcdif_dvictrl2[] =
{
    {
        "V1_BLANK_END_LINE",
        DESC("Vertical line number in the beginning part of Field2 where first Verti"
        "cal Blanking interval ends.")
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V1_BLANK_START_LINE",
        DESC("Vertical line number towards the end of Field1 where first Vertical Bl"
        "anking interval starts.")
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F2_END_LINE",
        DESC("Vertical line number at which Field 2 ends.")
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL3.
static const field_t hw_lcdif_dvictrl3[] =
{
    {
        "V_LINES_CNT",
        DESC("Total number of vertical lines per frame (generally 525 or 625)")
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V2_BLANK_END_LINE",
        DESC("Vertical line number in the beginning part of Field1 where second Vert"
        "ical Blanking interval ends.")
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V2_BLANK_START_LINE",
        DESC("Vertical line number towards the end of Field2 where second Vertical B"
        "lanking interval starts.")
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL4.
static const field_t hw_lcdif_dvictrl4[] =
{
    {
        "H_FILL_CNT",
        DESC("Number of active video samples that have to be filled with the filler "
        "data in the front and back portions of the active horizontal interval.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CR_FILL_VALUE",
        DESC("Value of CR component of filler data.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CB_FILL_VALUE",
        DESC("Value of CB component of filler data")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "Y_FILL_VALUE",
        DESC("Value of Y component of filler data")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF0.
static const field_t hw_lcdif_csc_coeff0[] =
{
    {
        "CSC_SUBSAMPLE_FILTER",
        DESC("This register describes the filtering and subsampling scheme to be per"
        "formed on the chroma components in order to convert from YCbCr 4:4:4 t"
        "o YCbCr 4:2:2 space.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C0",
        DESC("Two's complement red multiplier coefficient for Y")
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF1.
static const field_t hw_lcdif_csc_coeff1[] =
{
    {
        "C1",
        DESC("Two's complement green multiplier coefficient for Y")
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C2",
        DESC("Two's complement blue multiplier coefficient for Y")
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF2.
static const field_t hw_lcdif_csc_coeff2[] =
{
    {
        "C3",
        DESC("Two's complement red multiplier coefficient for Cb")
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C4",
        DESC("Two's complement green multiplier coefficient for Cb")
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF3.
static const field_t hw_lcdif_csc_coeff3[] =
{
    {
        "C5",
        DESC("Two's complement blue multiplier coefficient for Cb")
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C6",
        DESC("Two's complement red multiplier coefficient for Cr")
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF4.
static const field_t hw_lcdif_csc_coeff4[] =
{
    {
        "C7",
        DESC("Two's complement green multiplier coefficient for Cr")
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C8",
        DESC("Two's complement blue multiplier coefficient for Cr")
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_OFFSET.
static const field_t hw_lcdif_csc_offset[] =
{
    {
        "Y_OFFSET",
        DESC("Two's complement offset for the Y component")
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CBCR_OFFSET",
        DESC("Two's complement offset for the Cb and Cr components")
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_LIMIT.
static const field_t hw_lcdif_csc_limit[] =
{
    {
        "Y_MAX",
        DESC("Upper limit of Y after RGB to 4:2:2 YCbCr conversion")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "Y_MIN",
        DESC("Lower limit of Y after RGB to 4:2:2 YCbCr conversion")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CBCR_MAX",
        DESC("Upper limit of Cb and Cr after RGB to 4:2:2 YCbCr conversion")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CBCR_MIN",
        DESC("Lower limit of Cb and Cr after RGB to 4:2:2 YCbCr conversion")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DATA.
static const field_t hw_lcdif_data[] =
{
    {
        "DATA_ZERO",
        DESC("Byte 0 (least significant byte) of data written to eLCDIF.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ONE",
        DESC("Byte 1 of data written to eLCDIF.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_TWO",
        DESC("Byte 2 of data written to eLCDIF.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_THREE",
        DESC("Byte 3 (most significant byte) of data written to LCDIF.")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_BM_ERROR_STAT.
static const field_t hw_lcdif_bm_error_stat[] =
{
    {
        "ADDR",
        DESC("Virtual address at which bus master error occurred.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CRC_STAT.
static const field_t hw_lcdif_crc_stat[] =
{
    {
        "CRC_VALUE",
        DESC("Calculated CRC value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_STAT.
static const field_t hw_lcdif_stat[] =
{
    {
        "LFIFO_COUNT",
        DESC("Read only view of the current count in Latency buffer (LFIFO).")
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DVI_CURRENT_FIELD",
        DESC("Read only view of the current field being transmitted.")
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUSY",
        DESC("Read only view of the input busy signal from the external LCD controll"
        "er.")
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXFIFO_EMPTY",
        DESC("Read only view of the signal that indicates that LCD write dapatath FI"
        "FO is empty, will be generally used in the read mode of the LCD interf"
        "ace.")
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXFIFO_FULL",
        DESC("Read only view of the signal that indicates that LCD write datapath FI"
        "FO is full, will be generally used in the write mode of the LCD interf"
        "ace.")
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LFIFO_EMPTY",
        DESC("Read only view of the signal that indicates that LCD read dapatath FIF"
        "O is empty, will be generally used in the read mode of the LCD interfa"
        "ce.")
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LFIFO_FULL",
        DESC("Read only view of the signal that indicates that LCD read datapath FIF"
        "O is full, will be generally used in the write mode of the LCD interfa"
        "ce.")
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRESENT",
        DESC("0: eLCDIF not present on this product  1: eLCDIF is present.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VERSION.
static const field_t hw_lcdif_version[] =
{
    {
        "STEP",
        DESC("Fixed read-only value reflecting the stepping of RTL version.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        DESC("Fixed read-only value reflecting the MINOR field of RTL version.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        DESC("Fixed read-only value reflecting the MAJOR field of RTL version.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG0.
static const field_t hw_lcdif_debug0[] =
{
    {
        "MST_WORDS",
        DESC("Read only view of the current bursts issued by the AXI bus master.")
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST_OUTSTANDING_REQS",
        DESC("Read only view of the current outstanding requests issued by the AXI b"
        "us master.")
        4, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST_AVALID",
        DESC("Read only view of the mst_avalid signal issued by the AXI bus master.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CUR_REQ_STATE",
        DESC("Read only view of the request state machine.")
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_B1_DONE",
        DESC("Buffer1 done signal issued by eLCDIF.")
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_LCDIF_B1_READY",
        DESC("Buffer1 ready signal issued by ePXP.")
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_B0_DONE",
        DESC("Buffer0 done signal issued by eLCDIF.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_LCDIF_B0_READY",
        DESC("Buffer0 ready signal issued by ePXP.")
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CUR_STATE",
        DESC("Read only view of the current state machine state in the current mode "
        "of operation.")
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EMPTY_WORD",
        DESC("Indicates that the current word is empty.")
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CUR_FRAME_TX",
        DESC("This bit is 1 for the time the current frame is being transmitted in t"
        "he VSYNC mode.")
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VSYNC",
        DESC("Read only view of VSYNC signal.")
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HSYNC",
        DESC("Read only view of HSYNC signal.")
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE",
        DESC("Read only view of ENABLE signal.")
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYNC_SIGNALS_ON_REG",
        DESC("Read only view of internal sync_signals_on_reg signal.")
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT_FOR_VSYNC_EDGE_OUT",
        DESC("Read only view of WAIT_FOR_VSYNC_EDGE bit in the VSYNC mode after it c"
        "omes out of the TXFIFO.")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STREAMING_END_DETECTED",
        DESC("Read only view of the DOTCLK_MODE or DVI_MODE bit going from 1 to 0.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG1.
static const field_t hw_lcdif_debug1[] =
{
    {
        "V_DATA_COUNT",
        DESC("Read only view of the current state of the vertical data counter.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "H_DATA_COUNT",
        DESC("Read only view of the current state of the horizontal data counter.")
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG2.
static const field_t hw_lcdif_debug2[] =
{
    {
        "MST_ADDRESS",
        DESC("Read only view of the current address issued by the AXI bus master.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_THRES.
static const field_t hw_lcdif_thres[] =
{
    {
        "PANIC",
        DESC("This value should be set to a value of pixels, from 0 to 511.")
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FASTCLOCK",
        DESC("This value should be set to a value of pixels, from 0 to 511.")
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LCDIF module.
static const reg_t hw_lcdif[] =
{
    {
        "CTRL",
        DESC("The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        23, // Number of bitfields
        hw_lcdif_ctrl
    },
    {
        "CTRL1",
        DESC("The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        20, // Number of bitfields
        hw_lcdif_ctrl1
    },
    {
        "CTRL2",
        DESC("The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_lcdif_ctrl2
    },
    {
        "TRANSFER_COUNT",
        DESC("This register tells the eLCDIF how much data will be sent for this fra"
        "me, or transaction.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_transfer_count
    },
    {
        "CUR_BUF",
        DESC("This register indicates the address of the current frame being transmi"
        "tted by eLCDIF.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_cur_buf
    },
    {
        "NEXT_BUF",
        DESC("This register indicates the address of next frame that will be transmi"
        "tted by eLCDIF.")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_next_buf
    },
    {
        "TIMING",
        DESC("The LCD interface timing register controls the various setup and hold "
        "times enforced by the LCD interface in the 6800/8080 MPU and VSYNC mod"
        "es of operation.")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_timing
    },
    {
        "VDCTRL0",
        DESC("This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_lcdif_vdctrl0
    },
    {
        "VDCTRL1",
        DESC("This register is used to control the VSYNC signal in the VSYNC and DOT"
        "CLK modes of the block.")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_vdctrl1
    },
    {
        "VDCTRL2",
        DESC("This register is used to control the HSYNC signal in the DOTCLK mode o"
        "f the block.")
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_vdctrl2
    },
    {
        "VDCTRL3",
        DESC("This register is used to determine the vertical and horizontal wait co"
        "unts.")
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_vdctrl3
    },
    {
        "VDCTRL4",
        DESC("This register is used to control the DOTCLK mode of the block.")
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_lcdif_vdctrl4
    },
    {
        "DVICTRL0",
        DESC("The Digital Video interface Control0 register provides the overall con"
        "trol of the Digital Video interface.")
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_dvictrl0
    },
    {
        "DVICTRL1",
        DESC("The Digital Video interface Control1 register provides the overall con"
        "trol of the Digital Video interface.")
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_lcdif_dvictrl1
    },
    {
        "DVICTRL2",
        DESC("The Digital Video interface Control2 register provides the overall con"
        "trol of the Digital Video interface.")
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_lcdif_dvictrl2
    },
    {
        "DVICTRL3",
        DESC("The Digital Video interface Control3 register provides the overall con"
        "trol of the Digital Video interface.")
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_lcdif_dvictrl3
    },
    {
        "DVICTRL4",
        DESC("The Digital Video interface Control4 register provides the overall con"
        "trol of the Digital Video interface.")
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_dvictrl4
    },
    {
        "CSC_COEFF0",
        DESC("LCDIF_CSC_COEFF0 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.")
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_csc_coeff0
    },
    {
        "CSC_COEFF1",
        DESC("LCDIF_CSC_COEFF1 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.")
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_csc_coeff1
    },
    {
        "CSC_COEFF2",
        DESC("LCDIF_CSC_COEFF2 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.")
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_csc_coeff2
    },
    {
        "CSC_COEFF3",
        DESC("LCDIF_CSC_COEFF3 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.")
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_csc_coeff3
    },
    {
        "CSC_COEFF4",
        DESC("LCDIF_CSC_COEFF4 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.")
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_csc_coeff4
    },
    {
        "CSC_OFFSET",
        DESC("LCDIF_CSC_ register provides overall control over color space conversi"
        "on from RGB to 4:2:2 YCbCr.")
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_csc_offset
    },
    {
        "CSC_LIMIT",
        DESC("LCDIF_CSC_CTRL0 register provides overall control over color space con"
        "version from RGB to 4:2:2 YCbCr.")
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_limit
    },
    {
        "DATA",
        DESC("This register is used to transfer data using the PIO interface mode of"
        " operation.")
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_data
    },
    {
        "BM_ERROR_STAT",
        DESC("This register reflects the virtual address at which the AXI master rec"
        "eived an error response from the slave.")
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_bm_error_stat
    },
    {
        "CRC_STAT",
        DESC("This register reflects the CRC value of each frame sent out by eLCDIF.")
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_crc_stat
    },
    {
        "STAT",
        DESC("The LCD interface status register can be used to check the current sta"
        "tus of the eLCDIF block.")
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_lcdif_stat
    },
    {
        "VERSION",
        DESC("The LCD interface version register can be used to read the version of "
        "the eLCDIF IP being used in this SoC.")
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lcdif_version
    },
    {
        "DEBUG0",
        DESC("The LCD interface debug0 register provides a diagnostic view of the st"
        "ate machine and other useful internal signals.")
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        false, // Writable
        17, // Number of bitfields
        hw_lcdif_debug0
    },
    {
        "DEBUG1",
        DESC("The LCD interface debug1 register provides a diagnostic view of the st"
        "ate machine and other useful internal signals.")
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lcdif_debug1
    },
    {
        "DEBUG2",
        DESC("The LCD interface debug2 register provides a diagnostic view of the st"
        "ate machine and other useful internal signals.")
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lcdif_debug2
    },
    {
        "THRES",
        DESC("This register is used to activate control signals when the number of p"
        "ixels reaches the programmed threshold.")
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_thres
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark EPDC
#endif

// Bitfields in register EPDC_CTRL.
static const field_t hw_epdc_ctrl[] =
{
    {
        "BURST_LEN_8",
        DESC("0- EPDC display fifo logic will issue AXI bursts of length 16.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_DATA_SWIZZLE",
        DESC("Specifies how to swap the bytes for the LUT data before store to LUTRA"
        "M.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPD_DATA_SWIZZLE",
        DESC("Specifies how to swap the bytes for the UPD data before the WB constru"
        "ction.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        DESC("This bit must be set to zero for normal operation.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        DESC("Set this bit to zero to enable normal EPDC operation.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_WVADDR.
static const field_t hw_epdc_wvaddr[] =
{
    {
        "ADDR",
        DESC("Start address of waveform tables.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_WB_ADDR.
static const field_t hw_epdc_wb_addr[] =
{
    {
        "ADDR",
        DESC("Address for EPDC working buffer.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_RES.
static const field_t hw_epdc_res[] =
{
    {
        "HORIZONTAL",
        DESC("Horizontal Resolution (in pixels)")
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VERTICAL",
        DESC("Vertical Resoltion (in pixels)")
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_FORMAT.
static const field_t hw_epdc_format[] =
{
    {
        "TFT_PIXEL_FORMAT",
        DESC("EPDC TFT Pixel Format.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF_PIXEL_FORMAT",
        DESC("EPDC Input Buffer Pixel format.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEFAULT_TFT_PIXEL",
        DESC("Default TFT pixel value.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF_PIXEL_SCALE",
        DESC("Selects method of conversion from 8-bit input")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_FIFOCTRL.
static const field_t hw_epdc_fifoctrl[] =
{
    {
        "FIFO_L_LEVEL",
        DESC("Lower level value of FIFO watermark.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_H_LEVEL",
        DESC("Upper level value of FIFO watermark.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_INIT_LEVEL",
        DESC("This register sets the watermark for the pixel-fifo.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRIORITY",
        DESC("Enable watermark-based priority elevation mechanism.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_UPD_ADDR.
static const field_t hw_epdc_upd_addr[] =
{
    {
        "ADDR",
        DESC("Address for incoming region update.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_UPD_STRIDE.
static const field_t hw_epdc_upd_stride[] =
{
    {
        "STRIDE",
        DESC("line stride for incoming region update")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_UPD_CORD.
static const field_t hw_epdc_upd_cord[] =
{
    {
        "XCORD",
        DESC("X co-ordinate for incoming region update")
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCORD",
        DESC("Y co-ordinate for incoming region update")
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_UPD_SIZE.
static const field_t hw_epdc_upd_size[] =
{
    {
        "WIDTH",
        DESC("Width (in pixels)")
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HEIGHT",
        DESC("Height (in pixels)")
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_UPD_CTRL.
static const field_t hw_epdc_upd_ctrl[] =
{
    {
        "UPDATE_MODE",
        DESC("Update Mode")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRY_RUN",
        DESC("Enable Dry Run mode(set to 1).")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTOWV",
        DESC("enable automatical waveform mode selection")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTOWV_PAUSE",
        DESC("")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NO_LUT_CANCEL",
        DESC("EPDC will cancel LUT loading for void update (no real update needed be"
        "cause of partial or collision), set this bit to 1 to disable this feat"
        "ure")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAVEFORM_MODE",
        DESC("Waveform Mode 0-255")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_SEL",
        DESC("LUT select 0-63")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USE_FIXED",
        DESC("Use fixed pixel values (requires programming of EPDC_UPD_FIXED)")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_UPD_FIXED.
static const field_t hw_epdc_upd_fixed[] =
{
    {
        "FIXCP",
        DESC("CP value if fixecp_en is set to 1.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIXNP",
        DESC("NP value if fixenp_en is set to 1.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIXCP_EN",
        DESC("If set to 1, current updated region has the CP value defined by FIXCP")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIXNP_EN",
        DESC("If set to 1, current updated region has the NP value defined by FIXNP")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_TEMP.
static const field_t hw_epdc_temp[] =
{
    {
        "TEMPERATURE",
        DESC("Temperature Value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_AUTOWV_LUT.
static const field_t hw_epdc_autowv_lut[] =
{
    {
        "ADDR",
        DESC("ADDR")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA",
        DESC("DATA")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_TCE_CTRL.
static const field_t hw_epdc_tce_ctrl[] =
{
    {
        "PIXELS_PER_SDCLK",
        DESC("Number of TFT pixels per SDCLK period.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDDO_WIDTH",
        DESC("Selects either 8 or 16 bit SDDO bus format")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DUAL_SCAN",
        DESC("Enables dual scan-mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCAN_DIR_0",
        DESC("Determines scan direction for each half of the TFT panel")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCAN_DIR_1",
        DESC("Determines scan direction for each half of the TFT panel")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_MODE",
        DESC("If set, the upper 8-bit of the SDDO bus are used for LVDS differential"
        " signalling.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDS_MODE_CE",
        DESC("If set (together with LVDS_MODE=1), SDCE[9:5] shall be driven as the d"
        "ifferential inverse of SDCE[4:0].")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_MODE",
        DESC("If set, SDDO data is driven on both positive and negative edges of SDC"
        "LK.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VCOM_MODE",
        DESC("This field determines the method used to drive the VCOM signal.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VCOM_VAL",
        DESC("When VCOM_MODE = MANUAL, this value is used to manually set the VCOM v"
        "alue for the VCOM[1:0] pins")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSCAN_HOLDOFF",
        DESC("This period (expressed in vertical lines), sets the portion of the ver"
        "tical blanking available for new LUTs to be activated.")
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_TCE_SDCFG.
static const field_t hw_epdc_tce_sdcfg[] =
{
    {
        "PIXELS_PER_CE",
        DESC("Number of pixels (outputs) per source-driver IC.")
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDDO_INVERT",
        DESC("Setting this bit to 1 reverses the polarity of each SDDO bit so 0xAAAA"
        " in 16-bit mode for example becomes 0x5555.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDDO_REFORMAT",
        DESC("This register defines the various re-formatting options to enable more"
        " flexibility in the source-driver interface:")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM_CE",
        DESC("Number of source driver IC chip-enables.")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDSHR",
        DESC("Value for source-driver shift direction output port")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDCLK_HOLD",
        DESC("Setting this bit to 1 holds the SDCLK low during LINE_BEGIN")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_TCE_GDCFG.
static const field_t hw_epdc_tce_gdcfg[] =
{
    {
        "GDSP_MODE",
        DESC("Selects method for driving GDSP pulse.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GDOE_MODE",
        DESC("Selects method for driving GDOE signal.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GDRL",
        DESC("Value for gate-driver right/left shift output port")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIOD_VSCAN",
        DESC("when vscan state is splited, this reg defines the counter period")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_TCE_HSCAN1.
static const field_t hw_epdc_tce_hscan1[] =
{
    {
        "LINE_SYNC",
        DESC("Number of PIXCLK cycles for line sync duration.")
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINE_SYNC_WIDTH",
        DESC("Number of PIXCLK cycles for the SDLE active time.")
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_TCE_HSCAN2.
static const field_t hw_epdc_tce_hscan2[] =
{
    {
        "LINE_BEGIN",
        DESC("Number of PIXCLK cycles for line begin duration.")
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINE_END",
        DESC("Number of PIXCLK cycles for line end duration.")
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_TCE_VSCAN.
static const field_t hw_epdc_tce_vscan[] =
{
    {
        "FRAME_SYNC",
        DESC("Number of lines for frame sync duration.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAME_BEGIN",
        DESC("Number of lines for frame begin duration.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAME_END",
        DESC("Number of lines for frame end duration.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_TCE_OE.
static const field_t hw_epdc_tce_oe[] =
{
    {
        "SDOEZ_DLY",
        DESC("Number of PIXCLK cycles from SDLE falling edge to SDOEZ rising (Must b"
        "e greater than 0)")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDOEZ_WIDTH",
        DESC("Number of PIXCLK cycles from SDOEZ high to SDOEZ falling (Must be grea"
        "ter than 0)")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDOED_DLY",
        DESC("Number of PIXCLK cycles from SDOEZ low to SDOED rising (Must be greate"
        "r than 0)")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDOED_WIDTH",
        DESC("Number of PIXCLK cycles from SDOED high to SDOED falling (Must be grea"
        "ter than 0)")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_TCE_POLARITY.
static const field_t hw_epdc_tce_polarity[] =
{
    {
        "SDCE_POL",
        DESC("0 = Active Low, 1 = Active High.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDLE_POL",
        DESC("0 = Active Low, 1 = Active High.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDOE_POL",
        DESC("0 = Active Low, 1 = Active High.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GDOE_POL",
        DESC("0 = Active Low, 1 = Active High.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GDSP_POL",
        DESC("0 = Active Low, 1 = Active High.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_TCE_TIMING1.
static const field_t hw_epdc_tce_timing1[] =
{
    {
        "SDCLK_SHIFT",
        DESC("This register can be used to implement additional timing setup/hold ad"
        "justment of source driver signals by adjusting the SDCLK up to 4 cycle"
        "s")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDCLK_INVERT",
        DESC("Invert phase of SDCLK")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDLE_SHIFT",
        DESC("This register can be used to implement additional timing setup/hold ad"
        "justment of source driver signals by adjusting the SDCLK up to 3 PIXCL"
        "K cycles")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_TCE_TIMING2.
static const field_t hw_epdc_tce_timing2[] =
{
    {
        "GDSP_OFFSET",
        DESC("This register allows the user to shift the GDSP pulse by N PIXCLKs whe"
        "re N=1 to 65535.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GDCLK_HP",
        DESC("This register controls the GDCLK high-pulse width.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_TCE_TIMING3.
static const field_t hw_epdc_tce_timing3[] =
{
    {
        "GDCLK_OFFSET",
        DESC("This register allows the user to shift the GDCLK from the line time by"
        " N PIXCLK cycles.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GDOE_OFFSET",
        DESC("When using GDOE_MODE=1, this register sets the delay from GDCLK to the"
        " GDOE in terms of N PIXCLK cycles")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_CTRL0.
static const field_t hw_epdc_pigeon_ctrl0[] =
{
    {
        "FD_PERIOD",
        DESC("period of line counter during FD phase")
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LD_PERIOD",
        DESC("period of pclk counter during LD phase")
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_CTRL1.
static const field_t hw_epdc_pigeon_ctrl1[] =
{
    {
        "FRAME_CNT_PERIOD",
        DESC("period of frame counter")
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAME_CNT_CYCLES",
        DESC("max cycles of frame counter")
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_IRQ_MASK1.
static const field_t hw_epdc_irq_mask1[] =
{
    {
        "LUTN_CMPLT_IRQ_EN",
        DESC("LUT0~31 Complete Interrupt Enable")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_IRQ_MASK2.
static const field_t hw_epdc_irq_mask2[] =
{
    {
        "LUTN_CMPLT_IRQ_EN",
        DESC("LUT32~64 Complete Interrupt Enable")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_IRQ1.
static const field_t hw_epdc_irq1[] =
{
    {
        "LUTN_CMPLT_IRQ",
        DESC("LUT 0~31 Complete Interrupt")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_IRQ2.
static const field_t hw_epdc_irq2[] =
{
    {
        "LUTN_CMPLT_IRQ",
        DESC("LUT 32~64 Complete Interrupt")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_IRQ_MASK.
static const field_t hw_epdc_irq_mask[] =
{
    {
        "WB_CMPLT_IRQ_EN",
        DESC("Enable WB complete interrupt")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COL_IRQ_EN",
        DESC("Enable collision detection interrupts for all LUTs")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCE_UNDERRUN_IRQ_EN",
        DESC("Enable pixel FIFO under-run condition detection.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAME_END_IRQ_EN",
        DESC("If this bit is set, EPDC will assert the current frame end interrupt.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUS_ERROR_IRQ_EN",
        DESC("Enable AXI BUS ERROR interrupt detection.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCE_IDLE_IRQ_EN",
        DESC("Enable TCE Idle interrupt detection.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPD_DONE_IRQ_EN",
        DESC("Enable UPD complete interrupt")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_IRQ_EN",
        DESC("Enable power interrupt")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_IRQ.
static const field_t hw_epdc_irq[] =
{
    {
        "WB_CMPLT_IRQ",
        DESC("Working buffer process complete Interrupt")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_COL_IRQ",
        DESC("Collision detection interrupt.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCE_UNDERRUN_IRQ",
        DESC("Interrupt to indicate that a pixel FIFO under-run has occured.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAME_END_IRQ",
        DESC("Interrupt to indicate EPDC has completed the current frame and is in t"
        "he vertical blanking period.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUS_ERROR_IRQ",
        DESC("Interrupt to indicate AXI BUS error occurs.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCE_IDLE_IRQ",
        DESC("Interrupt to indicate that the TCE has completed TFT frame scans and i"
        "s in an idle state.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPD_DONE_IRQ",
        DESC("Working buffer process complete Interrupt")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_IRQ",
        DESC("Power Interrupt")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_STATUS_LUTS1.
static const field_t hw_epdc_status_luts1[] =
{
    {
        "LUTN_STS",
        DESC("LUT 0~31 Status : 1=ACTIVE, 0=IDLE")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_STATUS_LUTS2.
static const field_t hw_epdc_status_luts2[] =
{
    {
        "LUTN_STS",
        DESC("LUT 32~63 Status : 1=ACTIVE, 0=IDLE")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_STATUS_NEXTLUT.
static const field_t hw_epdc_status_nextlut[] =
{
    {
        "NEXT_LUT",
        DESC("Next available LUT value")
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXT_LUT_VALID",
        DESC("This bitfield can be used to check against a LUTs full condition")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_STATUS_COL1.
static const field_t hw_epdc_status_col1[] =
{
    {
        "LUTN_COL_STS",
        DESC("LUTn Collision Status")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_STATUS_COL2.
static const field_t hw_epdc_status_col2[] =
{
    {
        "LUTN_COL_STS",
        DESC("LUTn Collision Status")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_STATUS.
static const field_t hw_epdc_status[] =
{
    {
        "WB_BUSY",
        DESC("Working buffer process is busy cannot accept new update requests.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LUTS_BUSY",
        DESC("Provides a summary status of LUTs.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LUTS_UNDERRUN",
        DESC("Provides a summary status of LUT fill.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UPD_VOID",
        DESC("shows the update buffer is void (don't need any real pixel update)")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HISTOGRAM_NP",
        DESC("Indicates which histogram matched the processed bitmap(NP).")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HISTOGRAM_CP",
        DESC("Indicates which histogram matched the existing bitmap(CP).")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_UPD_COL_CORD.
static const field_t hw_epdc_upd_col_cord[] =
{
    {
        "XCORD",
        DESC("X co-ordinate for collision region of the latest completed update")
        0, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YCORD",
        DESC("Y co-ordinate for collision region of the latest completed update")
        16, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_UPD_COL_SIZE.
static const field_t hw_epdc_upd_col_size[] =
{
    {
        "WIDTH",
        DESC("Width (in pixels)")
        0, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HEIGHT",
        DESC("Height (in pixels)")
        16, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_HIST1_PARAM.
static const field_t hw_epdc_hist1_param[] =
{
    {
        "VALUE0",
        DESC("value for 1-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_HIST2_PARAM.
static const field_t hw_epdc_hist2_param[] =
{
    {
        "VALUE0",
        DESC("Black value for 2-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE1",
        DESC("White value for 2-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_HIST4_PARAM.
static const field_t hw_epdc_hist4_param[] =
{
    {
        "VALUE0",
        DESC("GRAY0 (Black) value for 4-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE1",
        DESC("GRAY1 value for 4-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE2",
        DESC("GRAY2 value for 4-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE3",
        DESC("GRAY3 (White) value for 4-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_HIST8_PARAM0.
static const field_t hw_epdc_hist8_param0[] =
{
    {
        "VALUE0",
        DESC("GRAY0 (Black) value for 8-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE1",
        DESC("GRAY1 value for 8-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE2",
        DESC("GRAY2 value for 8-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE3",
        DESC("GRAY3 value for 8-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_HIST8_PARAM1.
static const field_t hw_epdc_hist8_param1[] =
{
    {
        "VALUE4",
        DESC("GRAY4 value for 8-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE5",
        DESC("GRAY5 value for 8-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE6",
        DESC("GRAY6 value for 8-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE7",
        DESC("GRAY7 (White) value for 8-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_HIST16_PARAM0.
static const field_t hw_epdc_hist16_param0[] =
{
    {
        "VALUE0",
        DESC("GRAY0 (Black) value for 16-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE1",
        DESC("GRAY1 value for 16-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE2",
        DESC("GRAY2 value for 16-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE3",
        DESC("GRAY3 value for 16-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_HIST16_PARAM1.
static const field_t hw_epdc_hist16_param1[] =
{
    {
        "VALUE4",
        DESC("GRAY4 value for 16-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE5",
        DESC("GRAY5 value for 16-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE6",
        DESC("GRAY6 value for 16-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE7",
        DESC("GRAY7 value for 16-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_HIST16_PARAM2.
static const field_t hw_epdc_hist16_param2[] =
{
    {
        "VALUE8",
        DESC("GRAY8 value for 16-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE9",
        DESC("GRAY9 value for 16-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE10",
        DESC("GRAY10 value for 16-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE11",
        DESC("GRAY11 value for 16-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_HIST16_PARAM3.
static const field_t hw_epdc_hist16_param3[] =
{
    {
        "VALUE12",
        DESC("GRAY12 value for 16-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE13",
        DESC("GRAY13 value for 16-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE14",
        DESC("GRAY14 value for 16-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE15",
        DESC("GRAY15 (White) value for 16-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_GPIO.
static const field_t hw_epdc_gpio[] =
{
    {
        "BDR",
        DESC("Controls ipp_epdc_bdr[1:0] output")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWRCTRL",
        DESC("Controls ipp_epdc_pwrctrl[3:0] output")
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWRCOM",
        DESC("Controls ipp_epdc_pwrcom output")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWRWAKE",
        DESC("Controls ipp_epdc_pwrwake output")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWRSTAT",
        DESC("reflect ipp_epdc_pwrstat input")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_VERSION.
static const field_t hw_epdc_version[] =
{
    {
        "STEP",
        DESC("Fixed read-only value reflecting the stepping of the RTL version.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        DESC("Fixed read-only value reflecting the MINOR field of the RTL version.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        DESC("Fixed read-only value reflecting the MAJOR field of the RTL version.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_0_0.
static const field_t hw_epdc_pigeon_0_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_0_1.
static const field_t hw_epdc_pigeon_0_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_0_2.
static const field_t hw_epdc_pigeon_0_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_1_0.
static const field_t hw_epdc_pigeon_1_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_1_1.
static const field_t hw_epdc_pigeon_1_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_1_2.
static const field_t hw_epdc_pigeon_1_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_2_0.
static const field_t hw_epdc_pigeon_2_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_2_1.
static const field_t hw_epdc_pigeon_2_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_2_2.
static const field_t hw_epdc_pigeon_2_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_3_0.
static const field_t hw_epdc_pigeon_3_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_3_1.
static const field_t hw_epdc_pigeon_3_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_3_2.
static const field_t hw_epdc_pigeon_3_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_4_0.
static const field_t hw_epdc_pigeon_4_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_4_1.
static const field_t hw_epdc_pigeon_4_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_4_2.
static const field_t hw_epdc_pigeon_4_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_5_0.
static const field_t hw_epdc_pigeon_5_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_5_1.
static const field_t hw_epdc_pigeon_5_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_5_2.
static const field_t hw_epdc_pigeon_5_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_6_0.
static const field_t hw_epdc_pigeon_6_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_6_1.
static const field_t hw_epdc_pigeon_6_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_6_2.
static const field_t hw_epdc_pigeon_6_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_7_0.
static const field_t hw_epdc_pigeon_7_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_7_1.
static const field_t hw_epdc_pigeon_7_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_7_2.
static const field_t hw_epdc_pigeon_7_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_8_0.
static const field_t hw_epdc_pigeon_8_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_8_1.
static const field_t hw_epdc_pigeon_8_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_8_2.
static const field_t hw_epdc_pigeon_8_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_9_0.
static const field_t hw_epdc_pigeon_9_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_9_1.
static const field_t hw_epdc_pigeon_9_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_9_2.
static const field_t hw_epdc_pigeon_9_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_10_0.
static const field_t hw_epdc_pigeon_10_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_10_1.
static const field_t hw_epdc_pigeon_10_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_10_2.
static const field_t hw_epdc_pigeon_10_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_11_0.
static const field_t hw_epdc_pigeon_11_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_11_1.
static const field_t hw_epdc_pigeon_11_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_11_2.
static const field_t hw_epdc_pigeon_11_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_12_0.
static const field_t hw_epdc_pigeon_12_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_12_1.
static const field_t hw_epdc_pigeon_12_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_12_2.
static const field_t hw_epdc_pigeon_12_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_13_0.
static const field_t hw_epdc_pigeon_13_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_13_1.
static const field_t hw_epdc_pigeon_13_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_13_2.
static const field_t hw_epdc_pigeon_13_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_14_0.
static const field_t hw_epdc_pigeon_14_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_14_1.
static const field_t hw_epdc_pigeon_14_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_14_2.
static const field_t hw_epdc_pigeon_14_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_15_0.
static const field_t hw_epdc_pigeon_15_0[] =
{
    {
        "EN",
        DESC("enable pigeon mode on this signal")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL",
        DESC("polarity of signal output")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_SEL",
        DESC("event to incrment local counter")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFSET",
        DESC("offset on pclk unit.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT_SEL",
        DESC("select global counters as mask condition, use together with MASK_CNT")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CNT",
        DESC("When the global counter selected through MASK_CNT_SEL matches value in"
        " this reg, pigeon local counter start ticking.")
        12, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATE_MASK",
        DESC("state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination "
        "of scan states as reference point for local counter to start ticking")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_15_1.
static const field_t hw_epdc_pigeon_15_1[] =
{
    {
        "SET_CNT",
        DESC("assert signal output when counter match this value")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_CNT",
        DESC("deassert signal output when counter match this value")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_PIGEON_15_2.
static const field_t hw_epdc_pigeon_15_2[] =
{
    {
        "SIG_LOGIC",
        DESC("logic operation with another signal  sigout : final output signal of t"
        "his generator  mask : final mask of this generator  this_sig : interme"
        "diate signal of this generator before logic operation  other_masks : i"
        "ntermediate mask result of this generator before logic operation  sig_"
        "another : signal selected other generators")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIG_ANOTHER",
        DESC("select another signal for logic operation or as mask or counter tick e"
        "vent")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPDC_WB_ADDR_TCE.
static const field_t hw_epdc_wb_addr_tce[] =
{
    {
        "ADDR",
        DESC("Address for EPDC working buffer (only for TCE).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a EPDC module.
static const reg_t hw_epdc[] =
{
    {
        "CTRL",
        DESC("EPDC Main control register  This register controls various high-level "
        "functions of the EPDC")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_epdc_ctrl
    },
    {
        "WVADDR",
        DESC("EPDC Waveform Address Pointer  N/A   EXAMPLE   N/A")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_wvaddr
    },
    {
        "WB_ADDR",
        DESC("EPDC Working Buffer Address  This register controls various functions "
        "throughout the digital portion of the chip.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_wb_addr
    },
    {
        "RES",
        DESC("EPDC Screen Resolution.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_res
    },
    {
        "FORMAT",
        DESC("EPDC Pixel format control register.")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_epdc_format
    },
    {
        "FIFOCTRL",
        DESC("Allows for programmability of pixel FIFO watermarks used in conjunctio"
        "n with system arbitration hardware  This register houses FIFO control "
        "bits")
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_epdc_fifoctrl
    },
    {
        "UPD_ADDR",
        DESC("EPDC Update Region Address  When stride feature not enabled(EPDC_UPD_S"
        "TRIDE==0), it must be aligned to 64-bit boundary, this is default beha"
        "vior to keep compatible like before; When stride feature is enabled(EP"
        "DC_UPD_STRIDE!=0), it can start from any byte address, no alignment re"
        "quirement, but still recomended be aligned get best bus performance.")
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_upd_addr
    },
    {
        "UPD_STRIDE",
        DESC("EPDC Update Region Stride  When UPD_STRIDE==0 (stride feature disabled"
        "), UPD buffer line must start from 64-bit boundary and end on 64-bit b"
        "oundary(padding if not).")
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_upd_stride
    },
    {
        "UPD_CORD",
        DESC("EPDC Update Command Co-ordinate  N/A   EXAMPLE   N/A")
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_upd_cord
    },
    {
        "UPD_SIZE",
        DESC("EPDC Update Command Size  This register controls various functions thr"
        "oughout the digital portion of the chip.")
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_upd_size
    },
    {
        "UPD_CTRL",
        DESC("EPDC Update Command Control.")
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_epdc_upd_ctrl
    },
    {
        "UPD_FIXED",
        DESC("EPDC Update Control register for fixed-pixel updates (enabled via EPDC"
        "_UPD_CTRL[USE_FIXED])")
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_epdc_upd_fixed
    },
    {
        "TEMP",
        DESC("EPDC Temperature Compensation Register  N/A   EXAMPLE   N/A")
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_temp
    },
    {
        "AUTOWV_LUT",
        DESC("This register is used to access the waveform mode lookup table.")
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_autowv_lut
    },
    {
        "TCE_CTRL",
        DESC("TCE general control register  This register houses Horizontal scan tim"
        "ing.")
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_epdc_tce_ctrl
    },
    {
        "TCE_SDCFG",
        DESC("Source-driver configuration register")
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_epdc_tce_sdcfg
    },
    {
        "TCE_GDCFG",
        DESC("This register houses gate-driver configuration.")
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_epdc_tce_gdcfg
    },
    {
        "TCE_HSCAN1",
        DESC("Horizontal scan timing registers.")
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_tce_hscan1
    },
    {
        "TCE_HSCAN2",
        DESC("Horizontal scan timing registers.")
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_tce_hscan2
    },
    {
        "TCE_VSCAN",
        DESC("Vertical scan timing registers  This register houses vertical scan tim"
        "ing.")
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_epdc_tce_vscan
    },
    {
        "TCE_OE",
        DESC("This register contain delay programming values for the SDOEZ and SDOED"
        " source driver control signals  This register contain delay programmin"
        "g values for the SDOZ and SDOE source driver control signals")
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_epdc_tce_oe
    },
    {
        "TCE_POLARITY",
        DESC("This registers allows for programming the polarity of source/gate driv"
        "er control signals  This register houses FIFO control bits")
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_epdc_tce_polarity
    },
    {
        "TCE_TIMING1",
        DESC("This register contains various timing adjustment controls  This regist"
        "er houses general purpose timing adjustment registers")
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_epdc_tce_timing1
    },
    {
        "TCE_TIMING2",
        DESC("This register contains various timing adjustment controls  This regist"
        "er houses general purpose timing adjustment registers")
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_tce_timing2
    },
    {
        "TCE_TIMING3",
        DESC("This register contains various timing adjustment controls  This regist"
        "er houses general purpose timing adjustment registers")
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_tce_timing3
    },
    {
        "PIGEON_CTRL0",
        DESC("This register contains global counter settings for Pigeon Mode  This r"
        "egister houses general purpose timing adjustment registers")
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_ctrl0
    },
    {
        "PIGEON_CTRL1",
        DESC("This register contains global counter setting for pigeon mode  This re"
        "gister houses general purpose timing adjustment registers")
        4, // Width in bytes
        0x00000390, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_ctrl1
    },
    {
        "IRQ_MASK1",
        DESC("Controls masking EPDC LUT complete interrupts  This register controls "
        "LUT0~31 IRQ masks for EPDC interrupts")
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_irq_mask1
    },
    {
        "IRQ_MASK2",
        DESC("Controls masking EPDC LUT complete interrupts  This register controls "
        "LUT0~31 IRQ masks for EPDC interrupts")
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_irq_mask2
    },
    {
        "IRQ1",
        DESC("EPDC LUT Completion IRQs.")
        4, // Width in bytes
        0x000003e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_irq1
    },
    {
        "IRQ2",
        DESC("EPDC LUT Completion IRQs.")
        4, // Width in bytes
        0x000003f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_irq2
    },
    {
        "IRQ_MASK",
        DESC("Controls masking for all EPDC interrupts  This register controls IRQ m"
        "asks for all EPDC interrupts")
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_epdc_irq_mask
    },
    {
        "IRQ",
        DESC("EPDC LUT Completion IRQs.")
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_epdc_irq
    },
    {
        "STATUS_LUTS1",
        DESC("EPDC Status Register - LUTS 0~31")
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_status_luts1
    },
    {
        "STATUS_LUTS2",
        DESC("EPDC Status Register - LUTS 0~31")
        4, // Width in bytes
        0x00000450, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_status_luts2
    },
    {
        "STATUS_NEXTLUT",
        DESC("Holds value of next available LUT.")
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_status_nextlut
    },
    {
        "STATUS_COL1",
        DESC("EPDC LUT Collision Status Register and works in conjuction with EPDC_I"
        "RQ[LUT_COL_IRQ].")
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_status_col1
    },
    {
        "STATUS_COL2",
        DESC("EPDC LUT Collision Status Register and works in conjuction with EPDC_I"
        "RQ[LUT_COL_IRQ].")
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_status_col2
    },
    {
        "STATUS",
        DESC("Register to house non LUT specific status bits  This register houses g"
        "eneral status bits")
        4, // Width in bytes
        0x000004a0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_epdc_status
    },
    {
        "UPD_COL_CORD",
        DESC("EPDC Collision Region Co-ordinate, cleared when new update issued  Thi"
        "s register only valid after WB completion and collision happens.")
        4, // Width in bytes
        0x000004c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_upd_col_cord
    },
    {
        "UPD_COL_SIZE",
        DESC("EPDC Collision Region Size of the latest completed update cleared when"
        " new update issued  This register only valid after WB completion and c"
        "ollision happens.")
        4, // Width in bytes
        0x000004e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_upd_col_size
    },
    {
        "HIST1_PARAM",
        DESC("This register specifies the valid values for a 1-level(single color) h"
        "istogram.")
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_hist1_param
    },
    {
        "HIST2_PARAM",
        DESC("This register specifies the valid values for a 2-level histogram.")
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_hist2_param
    },
    {
        "HIST4_PARAM",
        DESC("This register specifies the valid values for a 4-level histogram.")
        4, // Width in bytes
        0x00000620, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_epdc_hist4_param
    },
    {
        "HIST8_PARAM0",
        DESC("This register specifies four of the valid values for an 8-level histog"
        "ram.")
        4, // Width in bytes
        0x00000630, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_epdc_hist8_param0
    },
    {
        "HIST8_PARAM1",
        DESC("This register specifies four of the valid values for an 8-level histog"
        "ram.")
        4, // Width in bytes
        0x00000640, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_epdc_hist8_param1
    },
    {
        "HIST16_PARAM0",
        DESC("This register specifies four of the valid values for a 16-level histog"
        "ram.")
        4, // Width in bytes
        0x00000650, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_epdc_hist16_param0
    },
    {
        "HIST16_PARAM1",
        DESC("This register specifies four of the valid values for a 16-level histog"
        "ram.")
        4, // Width in bytes
        0x00000660, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_epdc_hist16_param1
    },
    {
        "HIST16_PARAM2",
        DESC("This register specifies four of the valid values for a 16-level histog"
        "ram.")
        4, // Width in bytes
        0x00000670, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_epdc_hist16_param2
    },
    {
        "HIST16_PARAM3",
        DESC("This register specifies four of the valid values for a 16-level histog"
        "ram.")
        4, // Width in bytes
        0x00000680, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_epdc_hist16_param3
    },
    {
        "GPIO",
        DESC("GPIO register to control ipp_epdc_bdr[1:0], ipp_epdc_pwr[3:0] and ipp_"
        "epdc_pwrcom output signals  Houses software control signal reisters")
        4, // Width in bytes
        0x00000700, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_epdc_gpio
    },
    {
        "VERSION",
        DESC("This register reflects the version number for the EPDC.")
        4, // Width in bytes
        0x000007f0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_epdc_version
    },
    {
        "PIGEON_0_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_0_0
    },
    {
        "PIGEON_0_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_0_1
    },
    {
        "PIGEON_0_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_0_2
    },
    {
        "PIGEON_1_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000840, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_1_0
    },
    {
        "PIGEON_1_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000850, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_1_1
    },
    {
        "PIGEON_1_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000860, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_1_2
    },
    {
        "PIGEON_2_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_2_0
    },
    {
        "PIGEON_2_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000890, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_2_1
    },
    {
        "PIGEON_2_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x000008a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_2_2
    },
    {
        "PIGEON_3_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x000008c0, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_3_0
    },
    {
        "PIGEON_3_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x000008d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_3_1
    },
    {
        "PIGEON_3_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x000008e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_3_2
    },
    {
        "PIGEON_4_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000900, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_4_0
    },
    {
        "PIGEON_4_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000910, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_4_1
    },
    {
        "PIGEON_4_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000920, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_4_2
    },
    {
        "PIGEON_5_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000940, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_5_0
    },
    {
        "PIGEON_5_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000950, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_5_1
    },
    {
        "PIGEON_5_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000960, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_5_2
    },
    {
        "PIGEON_6_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000980, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_6_0
    },
    {
        "PIGEON_6_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000990, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_6_1
    },
    {
        "PIGEON_6_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x000009a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_6_2
    },
    {
        "PIGEON_7_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x000009c0, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_7_0
    },
    {
        "PIGEON_7_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x000009d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_7_1
    },
    {
        "PIGEON_7_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x000009e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_7_2
    },
    {
        "PIGEON_8_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000a00, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_8_0
    },
    {
        "PIGEON_8_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000a10, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_8_1
    },
    {
        "PIGEON_8_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000a20, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_8_2
    },
    {
        "PIGEON_9_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000a40, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_9_0
    },
    {
        "PIGEON_9_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000a50, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_9_1
    },
    {
        "PIGEON_9_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000a60, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_9_2
    },
    {
        "PIGEON_10_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000a80, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_10_0
    },
    {
        "PIGEON_10_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000a90, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_10_1
    },
    {
        "PIGEON_10_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000aa0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_10_2
    },
    {
        "PIGEON_11_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000ac0, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_11_0
    },
    {
        "PIGEON_11_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000ad0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_11_1
    },
    {
        "PIGEON_11_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000ae0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_11_2
    },
    {
        "PIGEON_12_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000b00, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_12_0
    },
    {
        "PIGEON_12_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000b10, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_12_1
    },
    {
        "PIGEON_12_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000b20, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_12_2
    },
    {
        "PIGEON_13_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000b40, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_13_0
    },
    {
        "PIGEON_13_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000b50, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_13_1
    },
    {
        "PIGEON_13_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000b60, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_13_2
    },
    {
        "PIGEON_14_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000b80, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_14_0
    },
    {
        "PIGEON_14_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000b90, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_14_1
    },
    {
        "PIGEON_14_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000ba0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_14_2
    },
    {
        "PIGEON_15_0",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000bc0, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_epdc_pigeon_15_0
    },
    {
        "PIGEON_15_1",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000bd0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_15_1
    },
    {
        "PIGEON_15_2",
        DESC("parameters for timing signal generation")
        4, // Width in bytes
        0x00000be0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_epdc_pigeon_15_2
    },
    {
        "WB_ADDR_TCE",
        DESC("EPDC Working Buffer Address used by TCE only")
        4, // Width in bytes
        0x00000c10, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epdc_wb_addr_tce
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark EPIT
#endif

// Bitfields in register EPIT_CR.
static const field_t hw_epit_cr[] =
{
    {
        "EN",
        DESC("This bit enables the EPIT.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENMOD",
        DESC("EPIT enable mode.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCIEN",
        DESC("Output compare interrupt enable.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RLD",
        DESC("Counter reload control.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALAR",
        DESC("Counter clock prescaler value.")
        4, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        DESC("Software reset.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IOVW",
        DESC("EPIT counter overwrite enable.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        DESC("This bit is used to keep the EPIT functional in debug mode.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAITEN",
        DESC("This read/write control bit enables the operation of the EPIT during w"
        "ait mode.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        DESC("EPIT stop mode enable.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM",
        DESC("EPIT output mode.This bit field determines the mode of EPIT output on "
        "the output pin.")
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKSRC",
        DESC("Select clock source  These bits determine which clock input is to be s"
        "elected for running the counter.")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_SR.
static const field_t hw_epit_sr[] =
{
    {
        "OCIF",
        DESC("Output compare interrupt flag.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_LR.
static const field_t hw_epit_lr[] =
{
    {
        "LOAD",
        DESC("Load value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_CMPR.
static const field_t hw_epit_cmpr[] =
{
    {
        "COMPARE",
        DESC("Compare Value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_CNR.
static const field_t hw_epit_cnr[] =
{
    {
        "COUNT",
        DESC("Counter value.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a EPIT module.
static const reg_t hw_epit[] =
{
    {
        "CR",
        DESC("The EPIT control register (EPIT_CR) is used to configure the operating"
        " settings of the EPIT.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_epit_cr
    },
    {
        "SR",
        DESC("The EPIT status register (EPIT_SR) has a single status bit for the out"
        "put compare event.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epit_sr
    },
    {
        "LR",
        DESC("The EPIT load register (EPIT_LR) contains the value that is to be load"
        "ed into the counter when EPIT counter reaches zero if the RLD bit in E"
        "PIT_CR is set.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epit_lr
    },
    {
        "CMPR",
        DESC("The EPIT compare register (EPIT_CMPR) holds the value that determines "
        "when a compare event is generated.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epit_cmpr
    },
    {
        "CNR",
        DESC("The EPIT counter register (EPIT_CNR) contains the current count value "
        "and can be read at any time without disturbing the counter.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_epit_cnr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark FEC
#endif

// Bitfields in register FEC_EIR.
static const field_t hw_fec_eir[] =
{
    {
        "UN",
        DESC("Transmit FIFO underrun.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        DESC("Collision retry limit.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LC",
        DESC("Late collision.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EBERR",
        DESC("Ethernet bus error.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MII",
        DESC("MII interrupt.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXB",
        DESC("Receive buffer interrupt.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXF",
        DESC("Receive frame interrupt.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB",
        DESC("Transmit buffer interrupt.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXF",
        DESC("Transmit frame interrupt.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRA",
        DESC("Graceful stop complete.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABT",
        DESC("Babbling transmit error.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABR",
        DESC("Babbling receive error.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBERR",
        DESC("Heartbeat error.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_EIMR.
static const field_t hw_fec_eimr[] =
{
    {
        "UN",
        DESC("Interrupt mask.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        DESC("Interrupt mask.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LC",
        DESC("Interrupt mask.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EBERR",
        DESC("Interrupt mask.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MII",
        DESC("Interrupt mask.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXB",
        DESC("Interrupt mask.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXF",
        DESC("Interrupt mask.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB",
        DESC("Interrupt mask.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXF",
        DESC("Interrupt mask.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRA",
        DESC("Interrupt mask.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABT",
        DESC("Interrupt mask.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABR",
        DESC("Interrupt mask.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBERR",
        DESC("Interrupt mask.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_RDAR.
static const field_t hw_fec_rdar[] =
{
    {
        "R_DES_ACTIVE",
        DESC("Set to one when this register is written, regardless of the value writ"
        "ten.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_TDAR.
static const field_t hw_fec_tdar[] =
{
    {
        "X_DES_ACTIVE",
        DESC("Set to one when this register is written, regardless of the value writ"
        "ten.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_ECR.
static const field_t hw_fec_ecr[] =
{
    {
        "RESET",
        DESC("When this bit is set, the equivalent of a hardware reset is performed "
        "but it is local to the FEC, ETHER_EN is cleared and all other FEC regi"
        "sters take their reset values.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETHER_EN",
        DESC("When this bit is set, the FEC is enabled, and reception and transmissi"
        "on are possible.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_MMFR.
static const field_t hw_fec_mmfr[] =
{
    {
        "DATA",
        DESC("Management frame data.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TA",
        DESC("Turn around.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RA",
        DESC("Register address.")
        18, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        DESC("PHY address.")
        23, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OP",
        DESC("Operation code.")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ST",
        DESC("Start of frame delimiter.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_MSCR.
static const field_t hw_fec_mscr[] =
{
    {
        "MII_SPEED",
        DESC("MII_SPEED controls the frequency of the MII management interface clock"
        " (FEC_MDC) relative to the system clock.")
        1, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS_PREAMBLE",
        DESC("Asserting this bit causes preamble (0xFFFF_FFFF) not to be prepended t"
        "o the MII management frame.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_MIBC.
static const field_t hw_fec_mibc[] =
{
    {
        "MB_IDLE",
        DESC("A read-only status bit.")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIB_DISABLE",
        DESC("A read/write control bit.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_RCR.
static const field_t hw_fec_rcr[] =
{
    {
        "LOOP",
        DESC("Internal loopback.When LOOP is set to 1, transmitted frames are looped"
        " back internal to the device and the transmit output signals are not a"
        "sserted.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRT",
        DESC("Disable receive on transmit.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MII_MODE",
        DESC("Media independent interface mode.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROM",
        DESC("Promiscuous mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BC_REJ",
        DESC("Broadcast frame reject.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCE",
        DESC("Flow control enable.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAX_FL",
        DESC("Maximum frame length.")
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_TCR.
static const field_t hw_fec_tcr[] =
{
    {
        "GTS",
        DESC("Graceful transmit stop.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBC",
        DESC("Heartbeat control.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FDEN",
        DESC("Full duplex enable.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFC_PAUSE",
        DESC("Transmit frame control pause.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFC_PAUSE",
        DESC("Receive frame control pause.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_PALR.
static const field_t hw_fec_palr[] =
{
    {
        "PADDR1",
        DESC("Bytes 0 (bits 31:24), 1 (bits 23:16), 2 (bits 15:8) and 3 (bits 7:0) o"
        "f the 6-byte individual address to be used for exact match, and the so"
        "urce address field in pause frames.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_PAUR.
static const field_t hw_fec_paur[] =
{
    {
        "TYPE",
        DESC("Type field in pause frames.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PADDR2",
        DESC("Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual addre"
        "ss to be used for exact match, and the source address field in pause f"
        "rames.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_OPDR.
static const field_t hw_fec_opdr[] =
{
    {
        "PAUSE_DUR",
        DESC("Pause duration field used in pause frames.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPCODE",
        DESC("Opcode field used in pause frames.")
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_IAUR.
static const field_t hw_fec_iaur[] =
{
    {
        "IADDR1",
        DESC("The upper 32 bits of the 64-bit hash table used in the address recogni"
        "tion process for receive frames with a unicast address.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_IALR.
static const field_t hw_fec_ialr[] =
{
    {
        "IADDR2",
        DESC("The lower 32 bits of the 64-bit hash table used in the address recogni"
        "tion process for receive frames with a unicast address.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_GAUR.
static const field_t hw_fec_gaur[] =
{
    {
        "GADDR1",
        DESC("The GADDR1 register contains the upper 32 bits of the 64-bit hash tabl"
        "e used in the address recognition process for receive frames with a mu"
        "lticast address.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_GALR.
static const field_t hw_fec_galr[] =
{
    {
        "GADDR2",
        DESC("The GADDR2 register contains the lower 32 bits of the 64-bit hash tabl"
        "e used in the address recognition process for receive frames with a mu"
        "lticast address.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_TFWR.
static const field_t hw_fec_tfwr[] =
{
    {
        "X_WMRK",
        DESC("Number of bytes written to transmit FIFO before transmission of a fram"
        "e begins")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_FRBR.
static const field_t hw_fec_frbr[] =
{
    {
        "R_BOUND",
        DESC("Read-only.")
        2, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_FRSR.
static const field_t hw_fec_frsr[] =
{
    {
        "R_FSTART",
        DESC("Address of first receive FIFO location.")
        2, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_ERDSR.
static const field_t hw_fec_erdsr[] =
{
    {
        "R_DES_START",
        DESC("Pointer to start of receive buffer descriptor queue.")
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_ETDSR.
static const field_t hw_fec_etdsr[] =
{
    {
        "X_DES_START",
        DESC("Pointer to start of transmit buffer descriptor queue.")
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FEC_EMRBR.
static const field_t hw_fec_emrbr[] =
{
    {
        "R_BUF_SIZE",
        DESC("Receive buffer size.")
        4, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a FEC module.
static const reg_t hw_fec[] =
{
    {
        "EIR",
        DESC("The FEC_EIR bit assignments are shown below.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_fec_eir
    },
    {
        "EIMR",
        DESC("The FEC_EIMR controls which of the interrupt events flagged in the FEC"
        "_EIR are allowed to generate actual interrupts.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_fec_eimr
    },
    {
        "RDAR",
        DESC("FEC_RDAR is a user-writeable command register which indicates that the"
        " receive descriptor ring has been updated, and that empty receive buff"
        "ers have been produced by the driver with the empty bit in RxBD set.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fec_rdar
    },
    {
        "TDAR",
        DESC("The FEC_TDAR is a command register,which is written by the user, to in"
        "dicate that the transmit descriptor ring has been updated (transmit bu"
        "ffers have been produced by the driver with the ready bit set in the b"
        "uffer descriptor).")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fec_tdar
    },
    {
        "ECR",
        DESC("The ECR is used to enable/disable the FEC_ ECR which is a read/write u"
        "ser register, though both fields in this register can also be altered "
        "by hardware.")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_fec_ecr
    },
    {
        "MMFR",
        DESC("The FEC_MMFR is used to communicate with the attached MII compatible P"
        "HY device(s) by providing read/write access to their MII registers.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_fec_mmfr
    },
    {
        "MSCR",
        DESC("The FEC_MSCR provides control of the frequency of the MII clock (FEC_M"
        "DC signal), and allows a preamble drop on the MII management frame .")
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_fec_mscr
    },
    {
        "MIBC",
        DESC("The MIB control register is a read/write register which is used to pro"
        "vide control of and to observe the state of the Message Information Bl"
        "ock (MIB).")
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_fec_mibc
    },
    {
        "RCR",
        DESC("The FEC_RCR is programmed by the user, and controls the operational mo"
        "de of the receive block.")
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_fec_rcr
    },
    {
        "TCR",
        DESC("This register is read/write register which is written by the user to c"
        "onfigure the transmit block.")
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_fec_tcr
    },
    {
        "PALR",
        DESC("The FEC_PALR, which is written by the user, contains the lower 32 bits"
        " (bytes 0,1,2,3) of the 48-bit address used in the address recognition"
        " process to check for possible match between the DA field of receive f"
        "rames and an individual DA.")
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fec_palr
    },
    {
        "PAUR",
        DESC("The FEC_PAUR, which is written by the user, and contains the upper 16 "
        "bits (bytes 4 and 5) of the 48-bit address used in the address recogni"
        "tion process to check for possible match between the DA field of recei"
        "ve frames and an individual DA.")
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_fec_paur
    },
    {
        "OPDR",
        DESC("FEC_OPDR contains the 16-bit Opcode, and 16-bit pause duration fields "
        "used in transmission of a pause frame.")
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_fec_opdr
    },
    {
        "IAUR",
        DESC("The FEC_IAUR, which is written by the user, contains the upper 32 bits"
        " of the 64-bit individual address hash table used in the address recog"
        "nition process to check for possible match between the DA field of rec"
        "eive frames and an individual DA.")
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fec_iaur
    },
    {
        "IALR",
        DESC("The FEC_IALR, which is written by the user, contains the lower 32 bits"
        " of the 64-bit individual address hash table used in the address recog"
        "nition process to check for possible match with the DA field of receiv"
        "e frames with an individual DA.")
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fec_ialr
    },
    {
        "GAUR",
        DESC("The FEC_GAUR, which is written by the user, contains the upper 32 bits"
        " of the 64-bit hash table used in the address recognition process for "
        "receive frames with a multicast address.")
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fec_gaur
    },
    {
        "GALR",
        DESC("The FEC_GALR, which is written by the user, contains the lower 32 bits"
        " of the 64-bit hash table used in the address recognition process for "
        "receive frames with a multicast address.")
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fec_galr
    },
    {
        "TFWR",
        DESC("The FEC_TFWR is programmed by the user to control the amount of data r"
        "equired in the transmit FIFO before transmission of a frame can begin.")
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fec_tfwr
    },
    {
        "FRBR",
        DESC("The FEC_FRBR register can be read to determine the upper address bound"
        " of the FIFO RAM.")
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_fec_frbr
    },
    {
        "FRSR",
        DESC("FEC_FRSR is an 8-bit register programmed by the user to indicate the s"
        "tarting address of the receive FIFO.")
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fec_frsr
    },
    {
        "ERDSR",
        DESC("The register, which is written by the user, provides a pointer to the "
        "start of the circular receive buffer descriptor queue in external memo"
        "ry.")
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fec_erdsr
    },
    {
        "ETDSR",
        DESC("The register, which is written by the user, provides a pointer to the "
        "start of the circular transmit buffer descriptor queue in external mem"
        "ory.")
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fec_etdsr
    },
    {
        "EMRBR",
        DESC("The FEC_EMRBR is a user-programmable register which dictates the maxim"
        "um size of all receive buffers.")
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fec_emrbr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPC
#endif

// Bitfields in register GPC_CNTR.
static const field_t hw_gpc_cntr[] =
{
    {
        "GPU_VPU_PDN_REQ",
        DESC("GPU Power Down request.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_VPU_PUP_REQ",
        DESC("GPU Power Up request.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFS0CR",
        DESC("DVFS0 (ARM) Change request (bit is read-only)")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPCIRQM",
        DESC("GPC interrupt/event masking")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_PGR.
static const field_t hw_gpc_pgr[] =
{
    {
        "DRCIC",
        DESC("Debug ref cir in mux control")
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR1.
static const field_t hw_gpc_imr1[] =
{
    {
        "IMR1",
        DESC("IRQ[63:32] masking bits: 1-irq masked, 0-irq is not masked")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR2.
static const field_t hw_gpc_imr2[] =
{
    {
        "IMR2",
        DESC("IRQ[95:64] masking bits: 1-irq masked, 0-irq is not masked")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR3.
static const field_t hw_gpc_imr3[] =
{
    {
        "IMR3",
        DESC("IRQ[127:96] masking bits: 1-irq masked, 0-irq is not masked")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR4.
static const field_t hw_gpc_imr4[] =
{
    {
        "IMR4",
        DESC("IRQ[159:128] masking bits: 1-irq masked, 0-irq is not masked")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR1.
static const field_t hw_gpc_isr1[] =
{
    {
        "ISR1",
        DESC("IRQ[63:32] status, read only")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR2.
static const field_t hw_gpc_isr2[] =
{
    {
        "ISR2",
        DESC("IRQ[95:64] status, read only")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR3.
static const field_t hw_gpc_isr3[] =
{
    {
        "ISR3",
        DESC("IRQ[127:96] status, read only")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR4.
static const field_t hw_gpc_isr4[] =
{
    {
        "ISR4",
        DESC("IRQ[159:128] status, read only")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPC module.
static const reg_t hw_gpc[] =
{
    {
        "CNTR",
        DESC("CNTR - Interface control register")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gpc_cntr
    },
    {
        "PGR",
        DESC("PGR - Power Gating Register")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_pgr
    },
    {
        "IMR1",
        DESC("IMR1 Register - masking of irq[63:32].")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr1
    },
    {
        "IMR2",
        DESC("IMR2 Register - masking of irq[95:64].")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr2
    },
    {
        "IMR3",
        DESC("IMR3 Register - masking of irq[127:96].")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr3
    },
    {
        "IMR4",
        DESC("IMR4 Register - masking of irq[159:128].")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr4
    },
    {
        "ISR1",
        DESC("ISR1 Register - status of irq [63:32].")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr1
    },
    {
        "ISR2",
        DESC("ISR2 Register - status of irq [95:64].")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr2
    },
    {
        "ISR3",
        DESC("ISR3 Register - status of irq [127:96].")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr3
    },
    {
        "ISR4",
        DESC("ISR4 Register - status of irq [159:128].")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr4
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPIO
#endif

// Bitfields in register GPIO_DR.
static const field_t hw_gpio_dr[] =
{
    {
        "DR",
        DESC("Data bits.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_GDIR.
static const field_t hw_gpio_gdir[] =
{
    {
        "GDIR",
        DESC("GPIO direction bits.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_PSR.
static const field_t hw_gpio_psr[] =
{
    {
        "PSR",
        DESC("GPIO pad status bits (status bits).")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_ICR1.
static const field_t hw_gpio_icr1[] =
{
    {
        "ICR0",
        DESC("Interrupt configuration 1 fields.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR1",
        DESC("Interrupt configuration 1 fields.")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR2",
        DESC("Interrupt configuration 1 fields.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR3",
        DESC("Interrupt configuration 1 fields.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR4",
        DESC("Interrupt configuration 1 fields.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR5",
        DESC("Interrupt configuration 1 fields.")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR6",
        DESC("Interrupt configuration 1 fields.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR7",
        DESC("Interrupt configuration 1 fields.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR8",
        DESC("Interrupt configuration 1 fields.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR9",
        DESC("Interrupt configuration 1 fields.")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR10",
        DESC("Interrupt configuration 1 fields.")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR11",
        DESC("Interrupt configuration 1 fields.")
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR12",
        DESC("Interrupt configuration 1 fields.")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR13",
        DESC("Interrupt configuration 1 fields.")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR14",
        DESC("Interrupt configuration 1 fields.")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR15",
        DESC("Interrupt configuration 1 fields.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_ICR2.
static const field_t hw_gpio_icr2[] =
{
    {
        "ICR16",
        DESC("Interrupt configuration 2 fields.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR17",
        DESC("Interrupt configuration 2 fields.")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR18",
        DESC("Interrupt configuration 2 fields.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR19",
        DESC("Interrupt configuration 2 fields.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR20",
        DESC("Interrupt configuration 2 fields.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR21",
        DESC("Interrupt configuration 2 fields.")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR22",
        DESC("Interrupt configuration 2 fields.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR23",
        DESC("Interrupt configuration 2 fields.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR24",
        DESC("Interrupt configuration 2 fields.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR25",
        DESC("Interrupt configuration 2 fields.")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR26",
        DESC("Interrupt configuration 2 fields.")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR27",
        DESC("Interrupt configuration 2 fields.")
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR28",
        DESC("Interrupt configuration 2 fields.")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR29",
        DESC("Interrupt configuration 2 fields.")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR30",
        DESC("Interrupt configuration 2 fields.")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR31",
        DESC("Interrupt configuration 2 fields.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_IMR.
static const field_t hw_gpio_imr[] =
{
    {
        "IMR",
        DESC("Interrupt Mask bits.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_ISR.
static const field_t hw_gpio_isr[] =
{
    {
        "ISR",
        DESC("Interrupt status bits - Bit n of this register is asserted (active hig"
        "h) when the active condition (as determined by the corresponding ICR b"
        "it) is detected on the GPIO input and is waiting for service.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_EDGE_SEL.
static const field_t hw_gpio_edge_sel[] =
{
    {
        "GPIO_EDGE_SEL",
        DESC("Edge select.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPIO module.
static const reg_t hw_gpio[] =
{
    {
        "DR",
        DESC("The 32-bit GPIO_DR register stores data that is ready to be driven to "
        "the output lines.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_dr
    },
    {
        "GDIR",
        DESC("GPIO_GDIR functions as direction control when the IOMUXC is in GPIO mo"
        "de.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_gdir
    },
    {
        "PSR",
        DESC("GPIO_PSR is a read-only register.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpio_psr
    },
    {
        "ICR1",
        DESC("GPIO_ICR1 contains 16 two-bit fields, where each field specifies the i"
        "nterrupt configuration for a different input signal.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_gpio_icr1
    },
    {
        "ICR2",
        DESC("GPIO_ICR2 contains 16 two-bit fields, where each field specifies the i"
        "nterrupt configuration for a different input signal.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_gpio_icr2
    },
    {
        "IMR",
        DESC("GPIO_IMR contains masking bits for each interrupt line.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_imr
    },
    {
        "ISR",
        DESC("The GPIO_ISR functions as an interrupt status indicator.")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_isr
    },
    {
        "EDGE_SEL",
        DESC("GPIO_EDGE_SEL may be used to override the ICR registers' configuration"
        ".")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_edge_sel
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPT
#endif

// Bitfields in register GPT_CR.
static const field_t hw_gpt_cr[] =
{
    {
        "EN",
        DESC("GPT Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENMOD",
        DESC("GPT Enable mode.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        DESC("GPT debug mode enable.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAITEN",
        DESC("GPT Wait Mode enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEEN",
        DESC("GPT Doze Mode Enable.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        DESC("GPT Stop Mode enable.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKSRC",
        DESC("Clock Source select.")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRR",
        DESC("Free-Run or Restart mode.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "_24MEN",
        DESC("Enable 24MHz clock input from crystal.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        DESC("Software reset.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IM1",
        DESC("See IM2")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IM2",
        DESC("IM2 (bits 19-18, Input Capture Channel 2 operating mode)  IM1 (bits 17"
        "-16, Input Capture Channel 1 operating mode)  The IM n bit field deter"
        "mines the transition on the input pin (for Input capture channel n ), "
        "which will trigger a capture event.")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM1",
        DESC("See OM3")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM2",
        DESC("See OM3")
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM3",
        DESC("OM3 (bits 28-26) controls the Output Compare Channel 3 operating mode.")
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FO1",
        DESC("See F03")
        29, // LSB
        29, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FO2",
        DESC("See F03")
        30, // LSB
        30, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FO3",
        DESC("FO3 Force Output Compare Channel 3  FO2 Force Output Compare Channel 2"
        "  FO1 Force Output Compare Channel 1  The FO n bit causes the pin acti"
        "on programmed for the timer Output Compare n pin (according to the OM "
        "n bits in this register).")
        31, // LSB
        31, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_PR.
static const field_t hw_gpt_pr[] =
{
    {
        "PRESCALER",
        DESC("Prescaler bits.")
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALER24M",
        DESC("Prescaler bits.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_SR.
static const field_t hw_gpt_sr[] =
{
    {
        "OF1",
        DESC("See OF3")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF2",
        DESC("See OF3")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF3",
        DESC("OF3 Output Compare 3 Flag  OF2 Output Compare 2 Flag  OF1 Output Compa"
        "re 1 Flag  The OF n bit indicates that a compare event has occurred on"
        " Output Compare channel n .")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF1",
        DESC("See IF2")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF2",
        DESC("IF2 Input capture 2 Flag  IF1 Input capture 1 Flag  The IF n bit indic"
        "ates that a capture event has occurred on Input Capture channel n .")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROV",
        DESC("Rollover Flag.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_IR.
static const field_t hw_gpt_ir[] =
{
    {
        "OF1IE",
        DESC("See OF3IE")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF2IE",
        DESC("See OF3IE")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF3IE",
        DESC("OF3IE Output Compare 3 Interrupt Enable  OF2IE Output Compare 2 Interr"
        "upt Enable  OF1IE Output Compare 1 Interrupt Enable  The OF n IE bit c"
        "ontrols the Output Compare Channel n interrupt.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF1IE",
        DESC("See IF2IE")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF2IE",
        DESC("IF2IE Input capture 2 Interrupt Enable  IF1IE Input capture 1 Interrup"
        "t Enable  The IF n IE bit controls the IF n IE Input Capture n Interru"
        "pt Enable.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROVIE",
        DESC("Rollover Interrupt Enable.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_OCR1.
static const field_t hw_gpt_ocr1[] =
{
    {
        "COMP",
        DESC("Compare Value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_OCR2.
static const field_t hw_gpt_ocr2[] =
{
    {
        "COMP",
        DESC("Compare Value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_OCR3.
static const field_t hw_gpt_ocr3[] =
{
    {
        "COMP",
        DESC("Compare Value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_ICR1.
static const field_t hw_gpt_icr1[] =
{
    {
        "CAPT",
        DESC("Capture Value.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_ICR2.
static const field_t hw_gpt_icr2[] =
{
    {
        "CAPT",
        DESC("Capture Value.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_CNT.
static const field_t hw_gpt_cnt[] =
{
    {
        "COUNT",
        DESC("Counter Value.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPT module.
static const reg_t hw_gpt[] =
{
    {
        "CR",
        DESC("The GPT Control Register (GPT_CR) is used to program and configure GPT"
        " operations.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_gpt_cr
    },
    {
        "PR",
        DESC("The GPT Prescaler Register (GPT_PR) contains bits that determine the d"
        "ivide value of the clock that runs the counter.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpt_pr
    },
    {
        "SR",
        DESC("The GPT Status Register (GPT_SR) contains bits that indicate that a co"
        "unter has rolled over, and if any event has occurred on the Input Capt"
        "ure and Output Compare channels.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpt_sr
    },
    {
        "IR",
        DESC("The GPT Interrupt Register (GPT_IR) contains bits that control whether"
        " interrupts are generated after rollover, input capture and output com"
        "pare events.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpt_ir
    },
    {
        "OCR1",
        DESC("The GPT Compare Register 1 (GPT_OCR1) holds the value that determines "
        "when a compare event will be generated on Output Compare Channel 1.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_ocr1
    },
    {
        "OCR2",
        DESC("The GPT Compare Register 2 (GPT_OCR2) holds the value that determines "
        "when a compare event will be generated on Output Compare Channel 2.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_ocr2
    },
    {
        "OCR3",
        DESC("The GPT Compare Register 3 (GPT_OCR3) holds the value that determines "
        "when a compare event will be generated on Output Compare Channel 3.")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_ocr3
    },
    {
        "ICR1",
        DESC("The GPT Input Capture Register 1 (GPT_ICR1) is a read-only register th"
        "at holds the value that was in the counter during the last capture eve"
        "nt on Input Capture Channel 1.")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpt_icr1
    },
    {
        "ICR2",
        DESC("The GPT Input capture Register 2 (GPT_ICR2) is a read-only register wh"
        "ich holds the value that was in the counter during the last capture ev"
        "ent on input capture channel 2.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpt_icr2
    },
    {
        "CNT",
        DESC("The GPT Counter Register (GPT_CNT) is the main counter's register.")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpt_cnt
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPU2D
#endif

// Bitfields in register GPU2D_AQHICLOCKCONTROL.
static const field_t hw_gpu2d_aqhiclockcontrol[] =
{
    {
        "MULTI_PIPE_USE_SINGLE_AXI",
        DESC("Force all the transactions to go to one AXI.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MULTI_PIPE_REG_SELECT",
        DESC("Determines which HI/MC to use while reading registers.")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISOLATE_GPU",
        DESC("Isolate GPU bit")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE_VG",
        DESC("VG pipe is idle.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE2_D",
        DESC("2D pipe is idle.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE3_D",
        DESC("3D pipe is idle.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOFT_RESET",
        DESC("Soft resets the IP.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_DEBUG_REGISTERS",
        DESC("Disable debug registers.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_RAM_CLOCK_GATING",
        DESC("Disables clock gating for rams.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSCALE_CMD_LOAD",
        DESC("")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSCALE_VAL",
        DESC("")
        23, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK2D_DIS",
        DESC("Disable 2D clock.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK3D_DIS",
        DESC("Disable 3D clock.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AQHIIDLE.
static const field_t hw_gpu2d_aqhiidle[] =
{
    {
        "AXI_LP",
        DESC("AXI is in low power mode.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_TS",
        DESC("TS is idle.")
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_FP",
        DESC("FP is idle.")
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_IM",
        DESC("IM is idle.")
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_VG",
        DESC("VG is idle.")
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_TX",
        DESC("TX is idle.")
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_RA",
        DESC("RA is idle.")
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_SE",
        DESC("SE is idle.")
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_PA",
        DESC("PA is idle.")
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_SH",
        DESC("SH is idle.")
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_PE",
        DESC("PE is idle.")
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_DE",
        DESC("DE is idle.")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE_FE",
        DESC("FE is idle.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AQAXICONFIG.
static const field_t hw_gpu2d_aqaxiconfig[] =
{
    {
        "ARCACHE",
        DESC("")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWCACHE",
        DESC("")
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARID",
        DESC("")
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWID",
        DESC("")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AQAXISTATUS.
static const field_t hw_gpu2d_aqaxistatus[] =
{
    {
        "WR_ERR_ID",
        DESC("")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_ERR_ID",
        DESC("")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DET_WR_ERR",
        DESC("")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DET_RD_ERR",
        DESC("")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AQINTRACKNOWLEDGE.
static const field_t hw_gpu2d_aqintracknowledge[] =
{
    {
        "INTR_VEC",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AQINTRENBL.
static const field_t hw_gpu2d_aqintrenbl[] =
{
    {
        "INTR_ENBL_VEC",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AQIDENT.
static const field_t hw_gpu2d_aqident[] =
{
    {
        "CUSTOMER",
        DESC("Customer value.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TECHNOLOGY",
        DESC("Technology value.")
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        DESC("Revision value.")
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRODUCT",
        DESC("Product value.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FAMILY",
        DESC("Family value.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_FEATURES.
static const field_t hw_gpu2d_features[] =
{
    {
        "FE20_BIT_INDEX",
        DESC("Supports 20 bit index.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RS_YUV_TARGET",
        DESC("Supports resolving into YUV target.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYTE_WRITE_3D",
        DESC("3D PE has byte write capability.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FE20",
        DESC("FE 2.0 is present.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VGTS",
        DESC("VG tessellator is present.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIPE_VG",
        DESC("VG pipe is present.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MEM32_BIT_SUPPORT",
        DESC("32 bit memory address support.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YUY2_RENDER_TARGET",
        DESC("YUY2 support in PE and YUY2 to RGB conversion in resolve.")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALF_TX_CACHE",
        DESC("TX cache is half.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALF_PE_CACHE",
        DESC("PE cache is half.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YUY2_AVERAGING",
        DESC("YUY2 averaging support in resolve.")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NO_SCALER",
        DESC("IP does not have 2D scaler.")
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYTE_WRITE_2D",
        DESC("Supports byte write in 2D.")
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUFFER_INTERLEAVING",
        DESC("IP supports interleaving depth and color buffers.")
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NO422_TEXTURE",
        DESC("IP does not have 422 texture input format.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NO_EZ",
        DESC("IP does not have early-Z.")
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIN_AREA",
        DESC("IP is configured to have minimum area.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CG",
        DESC("Second level clock gating is available.")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YUV420_TILER",
        DESC("YUV 4:2:0 tiler is available.")
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HIGH_DYNAMIC_RANGE",
        DESC("Shows if the IP has HDR support.")
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FAST_SCALER",
        DESC("Shows if the IP has HD scaler.")
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ETC1_TEXTURE_COMPRESSION",
        DESC("ETC1 texture compression.")
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIPE_2D",
        DESC("Shows if there is 2D engine.")
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC",
        DESC("Shows if there is a display controller in the IP.")
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MSAA",
        DESC("MSAA support.")
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YUV420_FILTER",
        DESC("YUV 4:2:0 support in filter blit.")
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZCOMPRESSION",
        DESC("Depth and color compression.")
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_MODE",
        DESC("Debug registers.")
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DXT_TEXTURE_COMPRESSION",
        DESC("DXT texture compression.")
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIPE_3D",
        DESC("3D pipe.")
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPECIAL_ANTI_ALIASING",
        DESC("Full-screen anti-aliasing.")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FAST_CLEAR",
        DESC("Fast clear.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPID.
static const field_t hw_gpu2d_chipid[] =
{
    {
        "ID",
        DESC("Id.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPREV.
static const field_t hw_gpu2d_chiprev[] =
{
    {
        "REV",
        DESC("Revision.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPDATE.
static const field_t hw_gpu2d_chipdate[] =
{
    {
        "DATE",
        DESC("Date.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPTIME.
static const field_t hw_gpu2d_chiptime[] =
{
    {
        "TIME",
        DESC("Time.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPCUSTOMER.
static const field_t hw_gpu2d_chipcustomer[] =
{
    {
        "GROUP",
        DESC("Group.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPANY",
        DESC("Company.")
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_MINORFEATURES0.
static const field_t hw_gpu2d_minorfeatures0[] =
{
    {
        "FLIP_Y",
        DESC("Y flipping capability is added to resolve.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DUAL_RETURN_BUS",
        DESC("Dual Return Bus from HI to clients.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENDIANNESS_CONFIG",
        DESC("Configurable endianness support.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEXTURE8_K",
        DESC("Supports 8Kx8K textures.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECT_TEXTURE_CONVERTER",
        DESC("Driver hack is not needed.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPECIAL_MSAA_LOD",
        DESC("Special LOD calculation when MSAA is on.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FAST_CLEAR_FLUSH",
        DESC("Proper flush is done in fast clear cache.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "_2DPE20",
        DESC("2D PE 2.0 is present.")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECT_AUTO_DISABLE",
        DESC("Auto disable in FC is correct.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RENDER_8K",
        DESC("Supports 8K render target.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TILE_STATUS_2BITS",
        DESC("2 bits are used instead of 4 bits for tile status.")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEPARATE_TILE_STATUS_WHEN_INTERLEAVED",
        DESC("Use 2 separate tile status buffers in interleaved mode.")
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SUPER_TILED_32X32",
        DESC("32x32 super tile is available.")
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VG_20",
        DESC("Major updates to VG pipe (TS buffer tiling.")
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TS_EXTENDED_COMMANDS",
        DESC("New commands added to the tessellator.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPRESSION_FIFO_FIXED",
        DESC("If this bit is not set, the FIFO counter should be set to 50.")
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EXTRA_SHADER_INSTRUCTIONS0",
        DESC("Floor, ceil, and sign instructions are available.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VG_FILTER",
        DESC("VG filter is available.")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VG_21",
        DESC("Minor updates to VG pipe (Event generation from VG, TS, PE).")
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SHADER_GETS_W",
        DESC("W is sent to SH from RA.")
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EXTRA_SHADER_INSTRUCTIONS1",
        DESC("Sqrt, sin, cos instructions are available.")
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEFAULT_REG0",
        DESC("Unavailable registers will return 0.")
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MC_20",
        DESC("New style MC with separate paths for color and depth.")
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SHADER_MSAA_SIDEBAND",
        DESC("Put the MSAA data into sideband fifo.")
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUG_FIXES0",
        DESC("")
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VAA",
        DESC("VAA is available or not.")
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYPASS_IN_MSAA",
        DESC("Shader supports bypass mode when MSAA is enabled.")
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HIERARCHICAL_Z",
        DESC("Hierarchiccal Z is supported.")
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEW_TEXTURE",
        DESC("New texture unit is available.")
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A8_TARGET_SUPPORT",
        DESC("2D engine supports A8 target.")
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECT_STENCIL",
        DESC("Correct stencil behavior in depth only.")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENHANCE_VR",
        DESC("Enhance VR and add a mode to walk 16 pixels in 16-bit mode in Vertical"
        " pass to improve $ hit rate when rotating 90/270.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CACHECONTROL.
static const field_t hw_gpu2d_cachecontrol[] =
{
    {
        "NOT_USED",
        DESC("Reserved")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_RESETMEMCOUNTERS.
static const field_t hw_gpu2d_resetmemcounters[] =
{
    {
        "RESET",
        DESC("")
        0, // LSB
        31, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALREADS.
static const field_t hw_gpu2d_totalreads[] =
{
    {
        "COUNT",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALWRITES.
static const field_t hw_gpu2d_totalwrites[] =
{
    {
        "COUNT",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPSPECS.
static const field_t hw_gpu2d_chipspecs[] =
{
    {
        "VERTEX_OUTPUT_BUFFER_SIZE",
        DESC("Log2 of vertex output buffer size.")
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NUM_PIXEL_PIPES",
        DESC("Number of pixel pipes.")
        4, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NUM_SHADER_CORES",
        DESC("Number of shader cores.")
        7, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VERTEX_CACHE_SIZE",
        DESC("Number of entries in the vertex shader cache.")
        15, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "THREAD_COUNT",
        DESC("Log2 of thread count.")
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEMP_REGISTERS",
        DESC("Log2 of temporary registers.")
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STREAMS",
        DESC("Number of vertex streams.")
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALWRITEBURSTS.
static const field_t hw_gpu2d_totalwritebursts[] =
{
    {
        "COUNT",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALWRITEREQS.
static const field_t hw_gpu2d_totalwritereqs[] =
{
    {
        "COUNT",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALWRITELASTS.
static const field_t hw_gpu2d_totalwritelasts[] =
{
    {
        "COUNT",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALREADBURSTS.
static const field_t hw_gpu2d_totalreadbursts[] =
{
    {
        "COUNT",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALREADREQS.
static const field_t hw_gpu2d_totalreadreqs[] =
{
    {
        "COUNT",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALREADLASTS.
static const field_t hw_gpu2d_totalreadlasts[] =
{
    {
        "COUNT",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_GPOUT0.
static const field_t hw_gpu2d_gpout0[] =
{
    {
        "COUNT",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_GPOUT1.
static const field_t hw_gpu2d_gpout1[] =
{
    {
        "COUNT",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_GPOUT2.
static const field_t hw_gpu2d_gpout2[] =
{
    {
        "COUNT",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_AXICONTROL.
static const field_t hw_gpu2d_axicontrol[] =
{
    {
        "WR_FULL_BURST_MODE",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_MINORFEATURES1.
static const field_t hw_gpu2d_minorfeatures1[] =
{
    {
        "TEXTURE_STRIDE",
        DESC("Texture has stride and memory addressing.")
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUG_FIXES2",
        DESC("")
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUG_FIXES1",
        DESC("")
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VG_DOUBLE_BUFFER",
        DESC("Double buffering support for VG (second TS-->VG semaphore is present).")
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "V2_COMPRESSION",
        DESC("V2 compression.")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSUV_SWIZZLE",
        DESC("Resolve UV swizzle.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALCYCLES.
static const field_t hw_gpu2d_totalcycles[] =
{
    {
        "CYCLES",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_TOTALIDLECYLES.
static const field_t hw_gpu2d_totalidlecyles[] =
{
    {
        "CYCLES",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_CHIPSPECS2.
static const field_t hw_gpu2d_chipspecs2[] =
{
    {
        "CYCLES",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_MODULEPOWERCONTROLS.
static const field_t hw_gpu2d_modulepowercontrols[] =
{
    {
        "TURN_OFF_COUNTER",
        DESC("Counter value for clock gating the module if the module is idle for th"
        "is amount of clock cycles.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TURN_ON_COUNTER",
        DESC("Number of clock cycles to wait after turning on the clock.")
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_STARVE_MODULE_CLOCK_GATING",
        DESC("Disables module level clock gating for starve/idle condition.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_STALL_MODULE_CLOCK_GATING",
        DESC("Disables module level clock gating for stall condition.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_MODULE_CLOCK_GATING",
        DESC("Enables module level clock gating.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_MODULEPOWERMODULECONTROL.
static const field_t hw_gpu2d_modulepowermodulecontrol[] =
{
    {
        "DISABLE_MODULE_CLOCK_GATING_TS",
        DESC("Disables module level clock gating for TS.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_FP",
        DESC("Disables module level clock gating for FP.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_IM",
        DESC("Disables module level clock gating for IM.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_VG",
        DESC("Disables module level clock gating for VG.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_TX",
        DESC("Disables module level clock gating for TX.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_RA",
        DESC("Disables module level clock gating for RA.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_SE",
        DESC("Disables module level clock gating for SE.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_PA",
        DESC("Disables module level clock gating for PA.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_SH",
        DESC("Disables module level clock gating for SH.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_PE",
        DESC("Disables module level clock gating for PE.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_DE",
        DESC("Disables module level clock gating for DE.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_MODULE_CLOCK_GATING_FE",
        DESC("Disables module level clock gating for FE.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPU2D_MODULEPOWERMODULESTATUS.
static const field_t hw_gpu2d_modulepowermodulestatus[] =
{
    {
        "MODULE_CLOCK_GATED_TS",
        DESC("Module level clock gating is ON for TS.")
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_FP",
        DESC("Module level clock gating is ON for FP.")
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_IM",
        DESC("Module level clock gating is ON for IM.")
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_VG",
        DESC("Module level clock gating is ON for VG.")
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_TX",
        DESC("Module level clock gating is ON for TX.")
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_RA",
        DESC("Module level clock gating is ON for RA.")
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_SE",
        DESC("Module level clock gating is ON for SE.")
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_PA",
        DESC("Module level clock gating is ON for PA.")
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_SH",
        DESC("Module level clock gating is ON for SH.")
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_PE",
        DESC("Module level clock gating is ON for PE.")
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_DE",
        DESC("Module level clock gating is ON for DE.")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULE_CLOCK_GATED_FE",
        DESC("Module level clock gating is ON for FE.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPU2D module.
static const reg_t hw_gpu2d[] =
{
    {
        "AQHICLOCKCONTROL",
        DESC("")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_gpu2d_aqhiclockcontrol
    },
    {
        "AQHIIDLE",
        DESC("")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        13, // Number of bitfields
        hw_gpu2d_aqhiidle
    },
    {
        "AQAXICONFIG",
        DESC("")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gpu2d_aqaxiconfig
    },
    {
        "AQAXISTATUS",
        DESC("")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gpu2d_aqaxistatus
    },
    {
        "AQINTRACKNOWLEDGE",
        DESC("Interrupt acknowledge register.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_aqintracknowledge
    },
    {
        "AQINTRENBL",
        DESC("Interrupt enable register.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_aqintrenbl
    },
    {
        "AQIDENT",
        DESC("Identification register.")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_gpu2d_aqident
    },
    {
        "FEATURES",
        DESC("Shows which features are enabled in this chip.")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        32, // Number of bitfields
        hw_gpu2d_features
    },
    {
        "CHIPID",
        DESC("Shows the ID for the chip in BCD.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_chipid
    },
    {
        "CHIPREV",
        DESC("Shows the revision for the chip in BCD.")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_chiprev
    },
    {
        "CHIPDATE",
        DESC("Shows the release date for the IP.")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_chipdate
    },
    {
        "CHIPTIME",
        DESC("Shows the release time for the IP.")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_chiptime
    },
    {
        "CHIPCUSTOMER",
        DESC("Shows the customer and group for the IP.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_gpu2d_chipcustomer
    },
    {
        "MINORFEATURES0",
        DESC("Shows which minor features are enabled in this chip.")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        32, // Number of bitfields
        hw_gpu2d_minorfeatures0
    },
    {
        "CACHECONTROL",
        DESC("")
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_cachecontrol
    },
    {
        "RESETMEMCOUNTERS",
        DESC("Writing 1 will reset the counters and stop counting.")
        4, // Width in bytes
        0x0000003c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_resetmemcounters
    },
    {
        "TOTALREADS",
        DESC("Total reads in terms of 64bits.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalreads
    },
    {
        "TOTALWRITES",
        DESC("Total writes in terms of 64bits.")
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalwrites
    },
    {
        "CHIPSPECS",
        DESC("Specs for the chip.")
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_gpu2d_chipspecs
    },
    {
        "TOTALWRITEBURSTS",
        DESC("Total write Data Count in terms of 64bits.")
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalwritebursts
    },
    {
        "TOTALWRITEREQS",
        DESC("Total write Request Count.")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalwritereqs
    },
    {
        "TOTALWRITELASTS",
        DESC("Total WLAST Count.")
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalwritelasts
    },
    {
        "TOTALREADBURSTS",
        DESC("Total Read Data Count in terms of 64bits.")
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalreadbursts
    },
    {
        "TOTALREADREQS",
        DESC("Total Read Request Count.")
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalreadreqs
    },
    {
        "TOTALREADLASTS",
        DESC("Total RLAST Count.")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalreadlasts
    },
    {
        "GPOUT0",
        DESC("General Purpose output register0.")
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_gpout0
    },
    {
        "GPOUT1",
        DESC("General Purpose output register1.")
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_gpout1
    },
    {
        "GPOUT2",
        DESC("General Purpose output register2.")
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_gpout2
    },
    {
        "AXICONTROL",
        DESC("Special Handling on AXI Bus")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_axicontrol
    },
    {
        "MINORFEATURES1",
        DESC("Shows which features are enabled in this chip.")
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_gpu2d_minorfeatures1
    },
    {
        "TOTALCYCLES",
        DESC("Total cycles.")
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalcycles
    },
    {
        "TOTALIDLECYLES",
        DESC("Total cycles where the GPU is idle.")
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_totalidlecyles
    },
    {
        "CHIPSPECS2",
        DESC("Specs for the chip.")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpu2d_chipspecs2
    },
    {
        "MODULEPOWERCONTROLS",
        DESC("The Power Management register set has just a few registers for control"
        "ling clock gating within the core.")
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_gpu2d_modulepowercontrols
    },
    {
        "MODULEPOWERMODULECONTROL",
        DESC("Module level control registers.")
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gpu2d_modulepowermodulecontrol
    },
    {
        "MODULEPOWERMODULESTATUS",
        DESC("Module level control status.")
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        false, // Writable
        12, // Number of bitfields
        hw_gpu2d_modulepowermodulestatus
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark I2C
#endif

// Bitfields in register I2C_IADR.
static const field_t hw_i2c_iadr[] =
{
    {
        "ADR",
        DESC("Slave address.")
        1, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_IFDR.
static const field_t hw_i2c_ifdr[] =
{
    {
        "IC",
        DESC("I2C clock rate.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_I2CR.
static const field_t hw_i2c_i2cr[] =
{
    {
        "RSTA",
        DESC("Repeat start.")
        2, // LSB
        2, // MSB
        false, // Readable
        true // Writable
    },
    {
        "TXAK",
        DESC("Transmit acknowledge enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MTX",
        DESC("Transmit/receive mode select bit.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSTA",
        DESC("Master/slave mode select bit.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IIEN",
        DESC("I2C interrupt enable.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IEN",
        DESC("I2C enable.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_I2SR.
static const field_t hw_i2c_i2sr[] =
{
    {
        "RXAK",
        DESC("Received acknowledge.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IIF",
        DESC("I2C interrupt.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRW",
        DESC("Slave read/write.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAL",
        DESC("Arbitration lost.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBB",
        DESC("I2C bus busy bit.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAAS",
        DESC("I2C addressed as a slave bit.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ICF",
        DESC("Data transferring bit.")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_I2DR.
static const field_t hw_i2c_i2dr[] =
{
    {
        "DATA",
        DESC("Data Byte.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a I2C module.
static const reg_t hw_i2c[] =
{
    {
        "IADR",
        DESC("")
        2, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2c_iadr
    },
    {
        "IFDR",
        DESC("The I2C_IFDR provides a programmable prescaler to configure the clock "
        "for bit-rate selection.")
        2, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2c_ifdr
    },
    {
        "I2CR",
        DESC("The I2C_I2CR is used to enable the I2C and the I2C interrupt.")
        2, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_i2c_i2cr
    },
    {
        "I2SR",
        DESC("The I2C_I2SR contains bits that indicate transaction direction and sta"
        "tus.")
        2, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_i2c_i2sr
    },
    {
        "I2DR",
        DESC("In master-receive mode, reading the data register allows a read to occ"
        "ur and initiates the next byte to be received.")
        2, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2c_i2dr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark IOMUXC
#endif

// Bitfields in register IOMUXC_GPR0.
static const field_t hw_iomuxc_gpr0[] =
{
    {
        "DMAREQ_MUX_SEL0",
        DESC("Selects between two possible sources for SDMA_EVENT[2]:")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL1",
        DESC("Selects between two possible sources for SDMA_EVENT[3]:")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL2",
        DESC("Selects between two possible sources for SDMA_EVENT[4]:")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL3",
        DESC("Selects between two possible sources for SDMA_EVENT[5]:")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL4",
        DESC("Selects between two possible sources for SDMA_EVENT[10]:")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL5",
        DESC("Selects between two possible sources for SDMA_EVENT[9]:")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL6",
        DESC("Selects between two possible sources for SDMA_EVENT[23]:")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL7",
        DESC("Selects between two possible sources for SDMA_EVENT[14]:")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR1.
static const field_t hw_iomuxc_gpr1[] =
{
    {
        "ACT_CS0",
        DESC("See description for ADDRS3[10]")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS0",
        DESC("See description for ADDRS3[10]")
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_CS1",
        DESC("See description for ADDRS3[10]")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS1",
        DESC("See description for ADDRS3[10]")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_CS2",
        DESC("See description for ADDRS3[10]")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS2",
        DESC("See description for ADDRS3[10]")
        7, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_CS3",
        DESC("See description for ADDRS3[10]")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS3",
        DESC("Active Chip Select and Address Space.")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GINT",
        DESC("Global interrupt \"0\" bit (connected to ARM IRQ#0 and GPC)")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_CLK_SEL",
        DESC("choose enet reference clk mode")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB_EXP_MODE",
        DESC("USB Exposure mode")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADD_DS",
        DESC("set to 0 will make output driver ~10% stronger at highest strength (DS"
        "E=111) for use in case if IO buffer operation at WCS and 200 MHz is ma"
        "rginal")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_CLK_SEL_FROM_ANALOG_LOOPBACK",
        DESC("When ENET_CLK_SEL(GPR1[14]) is program to 0(means get enet txclk from "
        "internal anatop), use these 2 bits to select from 4 options of loopbac"
        "k path.")
        17, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_MON",
        DESC("Exclusive monitor response select of illegal command (of lal gaskets, "
        "except MMDC)")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR2.
static const field_t hw_iomuxc_gpr2[] =
{
    {
        "EPDC_MEM_EN_POWERSAVING",
        DESC("enable power saving features on epdc memory")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_MEM_SHUTDOWN",
        DESC("set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_MEM_DEEPSLEEP",
        DESC("control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_MEM_LIGHTSLEEP",
        DESC("set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDC_MEM_EN_POWERSAVING",
        DESC("enable power saving features on SPDC memory")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDC_MEM_SHUTDOWN",
        DESC("set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDC_MEM_DEEPSLEEP",
        DESC("control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDC_MEM_LIGHTSLEEP",
        DESC("set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_MEM_EN_POWERSAVING",
        DESC("enable power saving features on PXP memory")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_MEM_SHUTDOWN",
        DESC("set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_MEM_DEEPSLEEP",
        DESC("control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_MEM_LIGHTSLEEP",
        DESC("set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_MEM_EN_POWERSAVING",
        DESC("enable power saving features on LCDIF memory")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_MEM_SHUTDOWN",
        DESC("set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_MEM_DEEPSLEEP",
        DESC("control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_MEM_LIGHTSLEEP",
        DESC("set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCP_MEM_EN_POWERSAVING",
        DESC("enable power saving features on DCP memory")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCP_MEM_SHUTDOWN",
        DESC("set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCP_MEM_DEEPSLEEP",
        DESC("control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCP_MEM_LIGHTSLEEP",
        DESC("set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_MEM_EN_POWERSAVING",
        DESC("enable power saving features on L2 memory")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_MEM_SHUTDOWN",
        DESC("set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_MEM_DEEPSLEEP",
        DESC("control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_MEM_LIGHTSLEEP",
        DESC("set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR3.
static const field_t hw_iomuxc_gpr3[] =
{
    {
        "OCRAM_L2_CTL",
        DESC("OCRAM_L2_CTL[3] write address pipeline control bit.")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_L2_STATUS",
        DESC("This field shows the OCRAM_L2 pipeline settings status, controlled by "
        "OCRAM_L2_CTL[3:0] bits respectively.")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TZASC1_BOOT_LOCK",
        DESC("TZASC-1 secure boot lock")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE_DBG_ACK_EN",
        DESC("Mask control of Core debug acknowledge to global debug acknowledge")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_STATUS",
        DESC("This field shows the OCRAM pipeline settings status, controlled by OCR"
        "AM_CTL[24:21] bits respectively.")
        17, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCRAM_CTL",
        DESC("OCRAM_CTL[24] write address pipeline control bit.")
        21, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHCX_RD_CACHE_CTL",
        DESC("Control uSDHCx [1-4] blocks cacheable attribute of AXI read transactio"
        "ns")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHCX_WR_CACHE_CTL",
        DESC("Control uSDHCx [1-4] blocks cacheable attribute of AXI write transacti"
        "ons")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR4.
static const field_t hw_iomuxc_gpr4[] =
{
    {
        "SOC_VERSION",
        DESC("This is status (read only) field.")
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RNGB_STOP_ACK",
        DESC("RNGB stop acknowledge.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDMA_STOP_ACK",
        DESC("SDMA stop acknowledge.")
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR5.
static const field_t hw_iomuxc_gpr5[] =
{
    {
        "ARM_WFI",
        DESC("ARM WFI event out indicating on WFI state of the cores (these are stat"
        "us, read only bits)")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ARM_WFE",
        DESC("ARM WFE event out indication on WFE state of the cores (these are stat"
        "us, read only bits)")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "L2_CLK_STOP",
        DESC("L2 cache clock stop indication (this is a status, read only bit]")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR6.
static const field_t hw_iomuxc_gpr6[] =
{
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR7.
static const field_t hw_iomuxc_gpr7[] =
{
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR8.
static const field_t hw_iomuxc_gpr8[] =
{
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR9.
static const field_t hw_iomuxc_gpr9[] =
{
    {
        "TZASC1_BYP",
        DESC("TZASC-1 BYPASS MUX control")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR10.
static const field_t hw_iomuxc_gpr10[] =
{
    {
        "DBG_EN",
        DESC("ARM non secure (non-invasive) debug enable")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_CLK_EN",
        DESC("ARM Debug clock enable")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEC_ERR_RESP",
        DESC("Security error response enable for all security gaskets (on both AHB a"
        "nd AXI busses)")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_L2_TZ_EN",
        DESC("OCRAM_L2 TrustZone (TZ) enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_L2_TZ_ADDR",
        DESC("OCRAM_L2 TrustZone (TZ) start address.")
        4, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_TZ_EN",
        DESC("OCRAM TrustZone (TZ) enable.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_TZ_ADDR",
        DESC("OCRAM TrustZone (TZ) start address.")
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_DBG_EN",
        DESC("Lock DBG_EN field for changes.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_DBG_CLK_EN",
        DESC("Lock DBG_CLK_EN field for changes.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_SEC_ERR_RESP",
        DESC("Lock SEC_ERR_RESP field for changes.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_OCRAM_L2_TZ_EN",
        DESC("Lock OCRAM_L2_TZ_EN field for changes.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_OCRAM_L2_TZ_ADDR",
        DESC("Lock OCRAM_L2_TZ_ADDR field for changes.")
        20, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_OCRAM_TZ_EN",
        DESC("Lock OCRAM_TZ_EN field for changes.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_OCRAM_TZ_ADDR",
        DESC("Lock OCRAM_TZ_ADDR field for changes.")
        27, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR11.
static const field_t hw_iomuxc_gpr11[] =
{
    {
        "OCRAM_L2_EN",
        DESC("set to use L2 cache as ocram")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK_OCRAM_L2_EN",
        DESC("lock ocram_l2 enable bit")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR12.
static const field_t hw_iomuxc_gpr12[] =
{
    {
        "GPU_AWQOS0",
        DESC("QOS control for write channel of gpu port m_g_0")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_ARQOS0",
        DESC("QOS control for read channel of gpu port m_g_0")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_AWQOS1",
        DESC("QOS control for write channel of gpu port m_g_1")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_ARQOS1",
        DESC("QOS control for read channel of gpu port m_g_1")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_AWQOS2",
        DESC("QOS control for write channel of gpu port m_g_2")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_ARQOS2",
        DESC("QOS control for read channel of gpu port m_g_2")
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMP_APB_CLK_EN",
        DESC("ARM platform APB clock enable")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMP_ATB_CLK_EN",
        DESC("ARM platform ATB clock enable")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMP_AHB_CLK_EN",
        DESC("ARM platform AHB clock enable")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMP_IPG_CLK_EN",
        DESC("ARM platform IPG clock enable")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCP_KEY_SEL",
        DESC("select 128bit dcp key from 256bit's key from snvs/ocotp")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR13.
static const field_t hw_iomuxc_gpr13[] =
{
    {
        "PXP_RD_CACHE_VAL",
        DESC("PXP block cacheable attribute value of AXI read transactions  The valu"
        "e of PXP_RD_CACHE_VAL is affecting the transactions only if PXP_RD_CAC"
        "HE_SEL is set.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_WR_CACHE_VAL",
        DESC("PXP block cacheable attribute value of AXI write transactions  The val"
        "ue of PXP_WR_CACHE_VAL is affecting the transactions only if PXP_WR_CA"
        "CHE_SEL is set.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_RD_CACHE_SEL",
        DESC("This bit selects the cacheable attribute of PXP AXI read transcations)")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_WR_CACHE_SEL",
        DESC("This bit selects the cacheable attribute of PXP AXI write transcations")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_RD_CACHE_VAL",
        DESC("EPDC block cacheable attribute value of AXI read transactions  The val"
        "ue of EPDC_RD_CACHE_VAL is affecting the transactions only if EPDC_RD_"
        "CACHE_SEL is set.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_WR_CACHE_VAL",
        DESC("EPDC block cacheable attribute value of AXI write transactions  The va"
        "lue of EPDC_WR_CACHE_VAL is affecting the transactions only if EPDC_WR"
        "_CACHE_SEL is set.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_RD_CACHE_SEL",
        DESC("This bit selects the cacheable attribute of EPDC AXI read transcations"
        ")")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_WR_CACHE_SEL",
        DESC("This bit selects the cacheable attribute of EPDC AXI write transcation"
        "s")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_RD_CACHE_VAL",
        DESC("LCDIF block cacheable attribute value of AXI read transactions  The va"
        "lue of LCDIF_RD_CACHE_VAL is affecting the transactions only if LCDIF_"
        "RD_CACHE_SEL is set.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_RD_CACHE_SEL",
        DESC("This bit selects the cacheable attribute of LCDIF AXI read transcation"
        "s)")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDMA_STOP_REQ",
        DESC("SDMA stop request")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_aud_mclk[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_AUD_RXC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_aud_rxc[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_AUD_RXD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_aud_rxd[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS.
static const field_t hw_iomuxc_sw_mux_ctl_pad_aud_rxfs[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_AUD_TXC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_aud_txc[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_AUD_TXD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_aud_txd[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS.
static const field_t hw_iomuxc_sw_mux_ctl_pad_aud_txfs[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO.
static const field_t hw_iomuxc_sw_mux_ctl_pad_ecspi1_miso[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI.
static const field_t hw_iomuxc_sw_mux_ctl_pad_ecspi1_mosi[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_ecspi1_sclk[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_ecspi1_ss0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO.
static const field_t hw_iomuxc_sw_mux_ctl_pad_ecspi2_miso[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI.
static const field_t hw_iomuxc_sw_mux_ctl_pad_ecspi2_mosi[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_ecspi2_sclk[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_ecspi2_ss0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_bdr0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_bdr1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D10.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d10[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D11.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d11[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D12.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d12[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D13.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d13[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D14.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d14[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D15.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d15[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d2[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d3[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d4[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d5[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d6[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d7[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D8.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d8[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_D9.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_d9[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_gdclk[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_gdoe[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_gdrl[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_gdsp[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_pwrcom[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl2[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl3[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_pwrint[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_pwrstat[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_pwrwakeup[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_sdce0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_sdce1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_sdce2[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_sdce3[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_sdclk[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_sdle[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_sdoe[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_sdshr[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_vcom0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_epdc_vcom1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV.
static const field_t hw_iomuxc_sw_mux_ctl_pad_fec_crs_dv[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_FEC_MDC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_fec_mdc[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO.
static const field_t hw_iomuxc_sw_mux_ctl_pad_fec_mdio[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_fec_ref_clk[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER.
static const field_t hw_iomuxc_sw_mux_ctl_pad_fec_rx_er[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_fec_rxd0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_fec_rxd1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_fec_tx_clk[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN.
static const field_t hw_iomuxc_sw_mux_ctl_pad_fec_tx_en[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_fec_txd0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_fec_txd1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT.
static const field_t hw_iomuxc_sw_mux_ctl_pad_hsic_dat[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_hsic_strobe[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL.
static const field_t hw_iomuxc_sw_mux_ctl_pad_i2c1_scl[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_i2c1_sda[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL.
static const field_t hw_iomuxc_sw_mux_ctl_pad_i2c2_scl[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_i2c2_sda[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col2[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col3[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col4[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col5[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col6[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_COL7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_col7[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row2[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row3[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row4[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row5[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row6[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_key_row7[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_clk[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat10[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat11[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat12[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat13[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat14[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat15[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat16[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat17[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat18[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat19[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat2[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat20[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat21[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat22[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat23[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat3[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat4[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat5[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat6[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat7[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat8[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_dat9[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_enable[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_hsync[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_RESET.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_reset[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_vsync[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_PWM1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_pwm1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M.
static const field_t hw_iomuxc_sw_mux_ctl_pad_ref_clk_24m[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K.
static const field_t hw_iomuxc_sw_mux_ctl_pad_ref_clk_32k[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_clk[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_CMD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_cmd[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_dat0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_dat1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_dat2[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_dat3[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_dat4[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_dat5[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_dat6[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_dat7[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_clk[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_CMD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_cmd[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_dat0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_dat1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_dat2[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_dat3[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_dat4[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_dat5[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_dat6[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_dat7[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD2_RST.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd2_rst[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_clk[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_CMD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_cmd[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_dat0[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_dat1[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_dat2[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd3_dat3[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART1_RXD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart1_rxd[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART1_TXD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart1_txd[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_WDOG_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_wdog_b[] =
{
    {
        "MUX_MODE",
        DESC("MUX Mode Select Field.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        DESC("Software Input On Field.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_aud_mclk[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: AUD_MCLK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: AUD_MCLK.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: AUD_MCLK.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: AUD_MC"
        "LK.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: AUD_M"
        "CLK.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: AUD_M"
        "CLK.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " AUD_MCLK.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: AUD_MC"
        "LK.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: AUD_M"
        "CLK.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_AUD_RXC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_aud_rxc[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: AUD_RXC.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: AUD_RXC.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: AUD_RXC.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: AUD_RX"
        "C.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: AUD_R"
        "XC.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: AUD_R"
        "XC.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " AUD_RXC.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: AUD_RX"
        "C.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: AUD_R"
        "XC.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_AUD_RXD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_aud_rxd[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: AUD_RXD.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: AUD_RXD.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: AUD_RXD.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: AUD_RX"
        "D.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: AUD_R"
        "XD.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: AUD_R"
        "XD.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " AUD_RXD.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: AUD_RX"
        "D.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: AUD_R"
        "XD.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_aud_rxfs[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: AUD_RXFS.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: AUD_RXFS.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: AUD_RXFS.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: AUD_RX"
        "FS.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: AUD_R"
        "XFS.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: AUD_R"
        "XFS.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " AUD_RXFS.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: AUD_RX"
        "FS.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: AUD_R"
        "XFS.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_AUD_TXC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_aud_txc[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: AUD_TXC.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: AUD_TXC.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: AUD_TXC.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: AUD_TX"
        "C.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: AUD_T"
        "XC.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: AUD_T"
        "XC.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " AUD_TXC.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: AUD_TX"
        "C.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: AUD_T"
        "XC.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_AUD_TXD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_aud_txd[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: AUD_TXD.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: AUD_TXD.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: AUD_TXD.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: AUD_TX"
        "D.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: AUD_T"
        "XD.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: AUD_T"
        "XD.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " AUD_TXD.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: AUD_TX"
        "D.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: AUD_T"
        "XD.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_aud_txfs[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: AUD_TXFS.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: AUD_TXFS.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: AUD_TXFS.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: AUD_TX"
        "FS.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: AUD_T"
        "XFS.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: AUD_T"
        "XFS.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " AUD_TXFS.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: AUD_TX"
        "FS.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: AUD_T"
        "XFS.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a0[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A0.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a1[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A1.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A1.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A10.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a10[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A10.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "10.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A10.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A11.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a11[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A11.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "11.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A11.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A12.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a12[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A12.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "12.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A12.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A13.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a13[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A13.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "13.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A13.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A14.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a14[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A14.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "14.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A14.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A15.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a15[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A15.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "15.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A15.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a2[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A2.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "2.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A2.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a3[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A3.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "3.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A3.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a4[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A4.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "4.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A4.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a5[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A5.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "5.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A5.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a6[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A6.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "6.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A6.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a7[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A7.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "7.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A7.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A8.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a8[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A8.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "8.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A8.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_A9.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_a9[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "A9.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_A"
        "9.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_A9.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_cas[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_CAS.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "CAS.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_C"
        "AS.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_CAS.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_cs0[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "CS0.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_C"
        "S0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_CS0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_cs1[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "CS1.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_C"
        "S1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_CS1.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm0[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_DQM0"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "DQM0.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_D"
        "QM0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_DQM0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm1[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_DQM1"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "DQM1.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_D"
        "QM1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_DQM1.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm2[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_DQM2"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "DQM2.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_D"
        "QM2.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_DQM2.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm3[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_DQM3"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "DQM3.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_D"
        "QM3.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_DQM3.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_ras[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_RAS.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "RAS.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_R"
        "AS.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_RAS.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_reset[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_RESE"
        "T.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "RESET.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "RESET.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "RESET.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " DRAM_RESET.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_R"
        "ESET.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_RESET.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Select one out of next values for pad: DRAM_RESET.")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdba0[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDBA0.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DBA0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDBA0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdba1[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDBA1.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DBA1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDBA1.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdba2[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDBA2.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDBA2.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDBA2.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DBA2.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDBA2.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdcke0[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDCKE0.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDCKE0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDCKE0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " DRAM_SDCKE0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DCKE0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDCKE0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdcke1[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDCKE1.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDCKE1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDCKE1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " DRAM_SDCKE1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DCKE1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDCKE1.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdclk_0[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_SDCL"
        "K_0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDCLK_0.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DCLK_0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDCLK_0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdodt0[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_SDOD"
        "T0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDODT0.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDODT0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDODT0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " DRAM_SDODT0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DODT0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDODT0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdodt1[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_SDOD"
        "T1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDODT1.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDODT1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDODT1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " DRAM_SDODT1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DODT1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDODT1.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs0[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_SDQS"
        "0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Read Only Field")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDQS0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDQS0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " DRAM_SDQS0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Read Only Field  Can be configured using Grou"
        "p Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Read Only Field  Can be configured using "
        "Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs1[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_SDQS"
        "1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Read Only Field")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDQS1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDQS1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " DRAM_SDQS1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Read Only Field  Can be configured using Grou"
        "p Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Read Only Field  Can be configured using "
        "Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs2[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_SDQS"
        "2.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Read Only Field")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDQS2.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDQS2.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " DRAM_SDQS2.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Read Only Field  Can be configured using Grou"
        "p Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Read Only Field  Can be configured using "
        "Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs3[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: DRAM_SDQS"
        "3.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Read Only Field")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: DRAM_"
        "SDQS3.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: DRAM_"
        "SDQS3.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " DRAM_SDQS3.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Read Only Field  Can be configured using Grou"
        "p Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Read Only Field  Can be configured using "
        "Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdwe[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field  Can be configured using Group C"
        "ontrol Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Select one out of next values for pad: DRAM_"
        "SDWE.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field  Can be configured using Gro"
        "up Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: DRAM_S"
        "DWE.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: DR"
        "AM_SDWE.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Read Only Field  Can be configured using Group Con"
        "trol Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO.
static const field_t hw_iomuxc_sw_pad_ctl_pad_ecspi1_miso[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: ECSPI1_MISO.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: ECSPI1_MI"
        "SO.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: ECSPI1_MISO.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: ECSPI1"
        "_MISO.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: ECSPI"
        "1_MISO.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: ECSPI"
        "1_MISO.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " ECSPI1_MISO.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: ECSPI1"
        "_MISO.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: ECSPI"
        "1_MISO.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI.
static const field_t hw_iomuxc_sw_pad_ctl_pad_ecspi1_mosi[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: ECSPI1_MOSI.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: ECSPI1_MO"
        "SI.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: ECSPI1_MOSI.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: ECSPI1"
        "_MOSI.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: ECSPI"
        "1_MOSI.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: ECSPI"
        "1_MOSI.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " ECSPI1_MOSI.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: ECSPI1"
        "_MOSI.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: ECSPI"
        "1_MOSI.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_ecspi1_sclk[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: ECSPI1_SCLK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: ECSPI1_SC"
        "LK.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: ECSPI1_SCLK.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: ECSPI1"
        "_SCLK.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: ECSPI"
        "1_SCLK.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: ECSPI"
        "1_SCLK.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " ECSPI1_SCLK.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: ECSPI1"
        "_SCLK.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: ECSPI"
        "1_SCLK.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_ecspi1_ss0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: ECSPI1_SS0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: ECSPI1_SS"
        "0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: ECSPI1_SS0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: ECSPI1"
        "_SS0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: ECSPI"
        "1_SS0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: ECSPI"
        "1_SS0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " ECSPI1_SS0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: ECSPI1"
        "_SS0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: ECSPI"
        "1_SS0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO.
static const field_t hw_iomuxc_sw_pad_ctl_pad_ecspi2_miso[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: ECSPI2_MISO.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: ECSPI2_MI"
        "SO.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: ECSPI2_MISO.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: ECSPI2"
        "_MISO.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: ECSPI"
        "2_MISO.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: ECSPI"
        "2_MISO.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " ECSPI2_MISO.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: ECSPI2"
        "_MISO.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: ECSPI"
        "2_MISO.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI.
static const field_t hw_iomuxc_sw_pad_ctl_pad_ecspi2_mosi[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: ECSPI2_MOSI.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: ECSPI2_MO"
        "SI.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: ECSPI2_MOSI.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: ECSPI2"
        "_MOSI.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: ECSPI"
        "2_MOSI.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: ECSPI"
        "2_MOSI.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " ECSPI2_MOSI.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: ECSPI2"
        "_MOSI.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: ECSPI"
        "2_MOSI.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_ecspi2_sclk[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: ECSPI2_SCLK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: ECSPI2_SC"
        "LK.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: ECSPI2_SCLK.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: ECSPI2"
        "_SCLK.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: ECSPI"
        "2_SCLK.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: ECSPI"
        "2_SCLK.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " ECSPI2_SCLK.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: ECSPI2"
        "_SCLK.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: ECSPI"
        "2_SCLK.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_ecspi2_ss0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: ECSPI2_SS0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: ECSPI2_SS"
        "0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: ECSPI2_SS0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: ECSPI2"
        "_SS0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: ECSPI"
        "2_SS0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: ECSPI"
        "2_SS0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " ECSPI2_SS0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: ECSPI2"
        "_SS0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: ECSPI"
        "2_SS0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_bdr0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_BDR0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_BDR0"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_BDR0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_B"
        "DR0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "BDR0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "BDR0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_BDR0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_B"
        "DR0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "BDR0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_bdr1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_BDR1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_BDR1"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_BDR1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_B"
        "DR1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "BDR1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "BDR1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_BDR1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_B"
        "DR1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "BDR1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D10.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d10[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D10.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D10.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D10.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "10.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D10.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D10.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D10.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "10.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D10.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D11.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d11[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D11.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D11.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D11.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "11.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D11.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D11.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D11.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "11.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D11.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D12.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d12[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D12.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D12.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D12.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "12.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D12.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D12.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D12.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "12.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D12.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D13.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d13[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D13.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D13.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D13.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "13.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D13.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D13.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D13.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "13.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D13.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D14.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d14[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D14.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D14.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D14.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "14.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D14.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D14.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D14.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "14.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D14.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D15.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d15[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D15.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D15.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D15.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "15.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D15.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D15.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D15.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "15.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D15.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d2[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D2.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D2.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D2.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "2.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D2.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D2.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D2.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "2.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D2.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d3[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D3.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D3.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D3.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "3.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D3.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D3.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D3.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "3.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D3.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d4[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D4.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D4.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D4.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "4.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D4.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D4.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D4.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "4.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D4.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d5[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D5.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D5.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D5.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "5.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D5.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D5.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D5.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "5.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D5.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d6[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D6.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D6.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D6.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "6.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D6.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D6.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D6.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "6.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D6.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d7[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D7.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D7.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D7.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "7.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D7.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D7.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D7.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "7.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D7.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D8.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d8[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D8.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D8.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D8.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "8.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D8.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D8.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D8.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "8.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D8.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_D9.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_d9[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_D9.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_D9.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_D9.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_D"
        "9.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "D9.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "D9.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_D9.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_D"
        "9.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "D9.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_gdclk[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_GDCLK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_GDCL"
        "K.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_GDCLK.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_G"
        "DCLK.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "GDCLK.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "GDCLK.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_GDCLK.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_G"
        "DCLK.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "GDCLK.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_gdoe[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_GDOE.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_GDOE"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_GDOE.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_G"
        "DOE.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "GDOE.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "GDOE.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_GDOE.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_G"
        "DOE.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "GDOE.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_gdrl[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_GDRL.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_GDRL"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_GDRL.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_G"
        "DRL.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "GDRL.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "GDRL.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_GDRL.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_G"
        "DRL.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "GDRL.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_gdsp[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_GDSP.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_GDSP"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_GDSP.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_G"
        "DSP.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "GDSP.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "GDSP.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_GDSP.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_G"
        "DSP.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "GDSP.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_pwrcom[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_PWRCOM.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_PWRC"
        "OM.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_PWRCOM.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_P"
        "WRCOM.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "PWRCOM.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "PWRCOM.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_PWRCOM.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_P"
        "WRCOM.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "PWRCOM.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_PWRCTRL0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_PWRC"
        "TRL0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_PWRCTRL0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_P"
        "WRCTRL0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "PWRCTRL0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "PWRCTRL0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_PWRCTRL0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_P"
        "WRCTRL0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "PWRCTRL0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_PWRCTRL1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_PWRC"
        "TRL1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_PWRCTRL1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_P"
        "WRCTRL1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "PWRCTRL1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "PWRCTRL1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_PWRCTRL1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_P"
        "WRCTRL1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "PWRCTRL1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl2[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_PWRCTRL2.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_PWRC"
        "TRL2.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_PWRCTRL2.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_P"
        "WRCTRL2.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "PWRCTRL2.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "PWRCTRL2.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_PWRCTRL2.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_P"
        "WRCTRL2.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "PWRCTRL2.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl3[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_PWRCTRL3.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_PWRC"
        "TRL3.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_PWRCTRL3.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_P"
        "WRCTRL3.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "PWRCTRL3.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "PWRCTRL3.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_PWRCTRL3.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_P"
        "WRCTRL3.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "PWRCTRL3.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_pwrint[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_PWRINT.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_PWRI"
        "NT.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_PWRINT.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_P"
        "WRINT.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "PWRINT.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "PWRINT.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_PWRINT.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_P"
        "WRINT.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "PWRINT.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_pwrstat[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_PWRSTAT.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_PWRS"
        "TAT.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_PWRSTAT.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_P"
        "WRSTAT.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "PWRSTAT.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "PWRSTAT.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_PWRSTAT.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_P"
        "WRSTAT.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "PWRSTAT.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_pwrwakeup[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_PWRWAKEUP"
        ".")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_PWRW"
        "AKEUP.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_PWRWAKEUP.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_P"
        "WRWAKEUP.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "PWRWAKEUP.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "PWRWAKEUP.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_PWRWAKEUP.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_P"
        "WRWAKEUP.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "PWRWAKEUP.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_sdce0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_SDCE0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_SDCE"
        "0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_SDCE0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_S"
        "DCE0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "SDCE0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "SDCE0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_SDCE0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_S"
        "DCE0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "SDCE0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_sdce1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_SDCE1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_SDCE"
        "1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_SDCE1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_S"
        "DCE1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "SDCE1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "SDCE1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_SDCE1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_S"
        "DCE1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "SDCE1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_sdce2[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_SDCE2.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_SDCE"
        "2.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_SDCE2.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_S"
        "DCE2.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "SDCE2.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "SDCE2.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_SDCE2.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_S"
        "DCE2.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "SDCE2.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_sdce3[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_SDCE3.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_SDCE"
        "3.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_SDCE3.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_S"
        "DCE3.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "SDCE3.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "SDCE3.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_SDCE3.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_S"
        "DCE3.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "SDCE3.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_sdclk[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_SDCLK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_SDCL"
        "K.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_SDCLK.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_S"
        "DCLK.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "SDCLK.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "SDCLK.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_SDCLK.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_S"
        "DCLK.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "SDCLK.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_sdle[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_SDLE.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_SDLE"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_SDLE.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_S"
        "DLE.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "SDLE.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "SDLE.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_SDLE.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_S"
        "DLE.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "SDLE.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_sdoe[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_SDOE.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_SDOE"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_SDOE.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_S"
        "DOE.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "SDOE.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "SDOE.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_SDOE.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_S"
        "DOE.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "SDOE.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_sdshr[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_SDSHR.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_SDSH"
        "R.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_SDSHR.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_S"
        "DSHR.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "SDSHR.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "SDSHR.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_SDSHR.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_S"
        "DSHR.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "SDSHR.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_vcom0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_VCOM0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_VCOM"
        "0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_VCOM0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_V"
        "COM0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "VCOM0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "VCOM0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_VCOM0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_V"
        "COM0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "VCOM0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_epdc_vcom1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: EPDC_VCOM1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: EPDC_VCOM"
        "1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: EPDC_VCOM1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: EPDC_V"
        "COM1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: EPDC_"
        "VCOM1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: EPDC_"
        "VCOM1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " EPDC_VCOM1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: EPDC_V"
        "COM1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: EPDC_"
        "VCOM1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV.
static const field_t hw_iomuxc_sw_pad_ctl_pad_fec_crs_dv[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: FEC_CRS_DV.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: FEC_CRS_D"
        "V.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: FEC_CRS_DV.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: FEC_CR"
        "S_DV.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: FEC_C"
        "RS_DV.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: FEC_C"
        "RS_DV.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " FEC_CRS_DV.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: FEC_CR"
        "S_DV.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: FEC_C"
        "RS_DV.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_FEC_MDC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_fec_mdc[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: FEC_MDC.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: FEC_MDC.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: FEC_MDC.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: FEC_MD"
        "C.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: FEC_M"
        "DC.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: FEC_M"
        "DC.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " FEC_MDC.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: FEC_MD"
        "C.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: FEC_M"
        "DC.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO.
static const field_t hw_iomuxc_sw_pad_ctl_pad_fec_mdio[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: FEC_MDIO.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: FEC_MDIO.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: FEC_MDIO.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: FEC_MD"
        "IO.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: FEC_M"
        "DIO.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: FEC_M"
        "DIO.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " FEC_MDIO.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: FEC_MD"
        "IO.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: FEC_M"
        "DIO.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_fec_ref_clk[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: FEC_REF_CLK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: FEC_REF_C"
        "LK.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: FEC_REF_CLK.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: FEC_RE"
        "F_CLK.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: FEC_R"
        "EF_CLK.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: FEC_R"
        "EF_CLK.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " FEC_REF_CLK.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: FEC_RE"
        "F_CLK.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: FEC_R"
        "EF_CLK.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER.
static const field_t hw_iomuxc_sw_pad_ctl_pad_fec_rx_er[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: FEC_RX_ER.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: FEC_RX_ER"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: FEC_RX_ER.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: FEC_RX"
        "_ER.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: FEC_R"
        "X_ER.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: FEC_R"
        "X_ER.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " FEC_RX_ER.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: FEC_RX"
        "_ER.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: FEC_R"
        "X_ER.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_fec_rxd0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: FEC_RXD0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: FEC_RXD0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: FEC_RXD0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: FEC_RX"
        "D0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: FEC_R"
        "XD0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: FEC_R"
        "XD0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " FEC_RXD0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: FEC_RX"
        "D0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: FEC_R"
        "XD0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_fec_rxd1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: FEC_RXD1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: FEC_RXD1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: FEC_RXD1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: FEC_RX"
        "D1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: FEC_R"
        "XD1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: FEC_R"
        "XD1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " FEC_RXD1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: FEC_RX"
        "D1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: FEC_R"
        "XD1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_fec_tx_clk[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: FEC_TX_CLK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: FEC_TX_CL"
        "K.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: FEC_TX_CLK.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: FEC_TX"
        "_CLK.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: FEC_T"
        "X_CLK.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: FEC_T"
        "X_CLK.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " FEC_TX_CLK.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: FEC_TX"
        "_CLK.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: FEC_T"
        "X_CLK.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN.
static const field_t hw_iomuxc_sw_pad_ctl_pad_fec_tx_en[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: FEC_TX_EN.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: FEC_TX_EN"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: FEC_TX_EN.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: FEC_TX"
        "_EN.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: FEC_T"
        "X_EN.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: FEC_T"
        "X_EN.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " FEC_TX_EN.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: FEC_TX"
        "_EN.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: FEC_T"
        "X_EN.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_fec_txd0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: FEC_TXD0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: FEC_TXD0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: FEC_TXD0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: FEC_TX"
        "D0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: FEC_T"
        "XD0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: FEC_T"
        "XD0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " FEC_TXD0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: FEC_TX"
        "D0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: FEC_T"
        "XD0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_fec_txd1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: FEC_TXD1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: FEC_TXD1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: FEC_TXD1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: FEC_TX"
        "D1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: FEC_T"
        "XD1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: FEC_T"
        "XD1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " FEC_TXD1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: FEC_TX"
        "D1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: FEC_T"
        "XD1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT.
static const field_t hw_iomuxc_sw_pad_ctl_pad_hsic_dat[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: HSIC_DAT.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Read Only Field")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: HSIC_"
        "DAT.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: HSIC_"
        "DAT.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " HSIC_DAT.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: HSIC_D"
        "AT.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: HS"
        "IC_DAT.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Select one out of next values for pad: HSIC_DAT.")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_hsic_strobe[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: HSIC_STRO"
        "BE.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        DESC("On Die Termination Field  Read Only Field")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: HSIC_"
        "STROBE.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: HSIC_"
        "STROBE.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " HSIC_STROBE.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: HSIC_S"
        "TROBE.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for pad: HS"
        "IC_STROBE.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Select one out of next values for pad: HSIC_STROBE"
        ".")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        DESC("Pad Output Delay Field  Read Only Field")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL.
static const field_t hw_iomuxc_sw_pad_ctl_pad_i2c1_scl[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: I2C1_SCL.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: I2C1_SCL.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: I2C1_SCL.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: I2C1_S"
        "CL.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: I2C1_"
        "SCL.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: I2C1_"
        "SCL.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " I2C1_SCL.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: I2C1_S"
        "CL.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: I2C1_"
        "SCL.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_i2c1_sda[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: I2C1_SDA.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: I2C1_SDA.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: I2C1_SDA.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: I2C1_S"
        "DA.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: I2C1_"
        "SDA.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: I2C1_"
        "SDA.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " I2C1_SDA.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: I2C1_S"
        "DA.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: I2C1_"
        "SDA.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL.
static const field_t hw_iomuxc_sw_pad_ctl_pad_i2c2_scl[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: I2C2_SCL.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: I2C2_SCL.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: I2C2_SCL.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: I2C2_S"
        "CL.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: I2C2_"
        "SCL.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: I2C2_"
        "SCL.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " I2C2_SCL.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: I2C2_S"
        "CL.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: I2C2_"
        "SCL.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_i2c2_sda[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: I2C2_SDA.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: I2C2_SDA.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: I2C2_SDA.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: I2C2_S"
        "DA.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: I2C2_"
        "SDA.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: I2C2_"
        "SDA.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " I2C2_SDA.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: I2C2_S"
        "DA.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: I2C2_"
        "SDA.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_mod[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Read Only Field")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Read Only Field")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Read Only Field")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: JTAG_"
        "MOD.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " JTAG_MOD.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: JTAG_M"
        "OD.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Read Only Field")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tck[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Read Only Field")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Read Only Field")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Read Only Field")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: JTAG_"
        "TCK.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " JTAG_TCK.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: JTAG_T"
        "CK.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Read Only Field")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tdi[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Read Only Field")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Read Only Field")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Read Only Field")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: JTAG_"
        "TDI.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " JTAG_TDI.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: JTAG_T"
        "DI.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Read Only Field")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tdo[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Read Only Field")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Read Only Field")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Read Only Field")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: JTAG_"
        "TDO.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Read Only Field")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Read Only Field")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Read Only Field")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tms[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Read Only Field")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Read Only Field")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Read Only Field")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: JTAG_"
        "TMS.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " JTAG_TMS.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: JTAG_T"
        "MS.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Read Only Field")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_trstb[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Read Only Field")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Read Only Field")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Read Only Field")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Read Only Field")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: JTAG_"
        "TRSTB.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Read Only Field")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " JTAG_TRSTB.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: JTAG_T"
        "RSTB.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Read Only Field")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_COL0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_COL0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_COL0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_COL0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_C"
        "OL0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_COL1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_COL1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_COL1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_COL1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_C"
        "OL1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col2[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_COL2.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_COL2.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_COL2.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L2.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL2.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL2.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_COL2.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L2.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_C"
        "OL2.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col3[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_COL3.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_COL3.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_COL3.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L3.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL3.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL3.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_COL3.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L3.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_C"
        "OL3.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col4[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_COL4.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_COL4.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_COL4.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L4.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL4.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL4.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_COL4.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L4.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_C"
        "OL4.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col5[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_COL5.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_COL5.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_COL5.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L5.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL5.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL5.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_COL5.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L5.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_C"
        "OL5.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col6[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_COL6.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_COL6.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_COL6.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L6.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL6.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL6.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_COL6.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L6.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_C"
        "OL6.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_COL7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_col7[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_COL7.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_COL7.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_COL7.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_CO"
        "L7.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_C"
        "OL7.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_C"
        "OL7.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_COL7.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_CO"
        "L7.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_C"
        "OL7.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_ROW0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_ROW0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_ROW0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_ROW0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_R"
        "OW0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_ROW1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_ROW1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_ROW1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_ROW1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_R"
        "OW1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row2[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_ROW2.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_ROW2.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_ROW2.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W2.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW2.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW2.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_ROW2.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W2.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_R"
        "OW2.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row3[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_ROW3.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_ROW3.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_ROW3.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W3.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW3.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW3.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_ROW3.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W3.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_R"
        "OW3.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row4[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_ROW4.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_ROW4.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_ROW4.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W4.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW4.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW4.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_ROW4.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W4.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_R"
        "OW4.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row5[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_ROW5.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_ROW5.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_ROW5.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W5.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW5.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW5.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_ROW5.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W5.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_R"
        "OW5.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row6[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_ROW6.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_ROW6.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_ROW6.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W6.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW6.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW6.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_ROW6.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W6.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_R"
        "OW6.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_key_row7[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: KEY_ROW7.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: KEY_ROW7.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: KEY_ROW7.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: KEY_RO"
        "W7.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: KEY_R"
        "OW7.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: KEY_R"
        "OW7.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " KEY_ROW7.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: KEY_RO"
        "W7.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: KEY_R"
        "OW7.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_clk[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_CLK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_CLK.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_CLK.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_CL"
        "K.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_C"
        "LK.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_C"
        "LK.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_CLK.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_CL"
        "K.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_C"
        "LK.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat10[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT10.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT10"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT10.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T10.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT10.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT10.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT10.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T10.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT10.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat11[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT11.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT11"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT11.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T11.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT11.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT11.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT11.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T11.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT11.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat12[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT12.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT12"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT12.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T12.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT12.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT12.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT12.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T12.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT12.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat13[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT13.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT13"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT13.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T13.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT13.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT13.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT13.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T13.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT13.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat14[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT14.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT14"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT14.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T14.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT14.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT14.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT14.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T14.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT14.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat15[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT15.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT15"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT15.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T15.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT15.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT15.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT15.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T15.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT15.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat16[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT16.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT16"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT16.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T16.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT16.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT16.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT16.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T16.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT16.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat17[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT17.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT17"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT17.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T17.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT17.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT17.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT17.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T17.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT17.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat18[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT18.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT18"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT18.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T18.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT18.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT18.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT18.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T18.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT18.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat19[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT19.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT19"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT19.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T19.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT19.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT19.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT19.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T19.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT19.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat2[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT2.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT2.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT2.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T2.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT2.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT2.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT2.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T2.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT2.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat20[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT20.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT20"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT20.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T20.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT20.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT20.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT20.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T20.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT20.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat21[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT21.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT21"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT21.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T21.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT21.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT21.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT21.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T21.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT21.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat22[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT22.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT22"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT22.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T22.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT22.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT22.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT22.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T22.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT22.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat23[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT23.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT23"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT23.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T23.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT23.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT23.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT23.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T23.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT23.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat3[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT3.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT3.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT3.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T3.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT3.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT3.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT3.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T3.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT3.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat4[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT4.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT4.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT4.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T4.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT4.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT4.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT4.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T4.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT4.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat5[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT5.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT5.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT5.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T5.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT5.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT5.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT5.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T5.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT5.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat6[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT6.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT6.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT6.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T6.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT6.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT6.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT6.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T6.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT6.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat7[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT7.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT7.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT7.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T7.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT7.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT7.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT7.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T7.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT7.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat8[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT8.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT8.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT8.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T8.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT8.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT8.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT8.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T8.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT8.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_dat9[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_DAT9.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_DAT9.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_DAT9.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_DA"
        "T9.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_D"
        "AT9.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_D"
        "AT9.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_DAT9.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_DA"
        "T9.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_D"
        "AT9.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_enable[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_ENABLE.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_ENABL"
        "E.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_ENABLE.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_EN"
        "ABLE.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_E"
        "NABLE.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_E"
        "NABLE.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_ENABLE.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_EN"
        "ABLE.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_E"
        "NABLE.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_hsync[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_HSYNC.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_HSYNC"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_HSYNC.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_HS"
        "YNC.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_H"
        "SYNC.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_H"
        "SYNC.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_HSYNC.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_HS"
        "YNC.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_H"
        "SYNC.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_RESET.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_reset[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_RESET.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_RESET"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_RESET.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_RE"
        "SET.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_R"
        "ESET.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_R"
        "ESET.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_RESET.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_RE"
        "SET.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_R"
        "ESET.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_vsync[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: LCD_VSYNC.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: LCD_VSYNC"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: LCD_VSYNC.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: LCD_VS"
        "YNC.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: LCD_V"
        "SYNC.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: LCD_V"
        "SYNC.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " LCD_VSYNC.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: LCD_VS"
        "YNC.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: LCD_V"
        "SYNC.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_PWM1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_pwm1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: PWM1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: PWM1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: PWM1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: PWM1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: PWM1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: PWM1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " PWM1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: PWM1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: PWM1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M.
static const field_t hw_iomuxc_sw_pad_ctl_pad_ref_clk_24m[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: REF_CLK_24M.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: REF_CLK_2"
        "4M.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: REF_CLK_24M.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: REF_CL"
        "K_24M.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: REF_C"
        "LK_24M.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: REF_C"
        "LK_24M.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " REF_CLK_24M.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: REF_CL"
        "K_24M.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: REF_C"
        "LK_24M.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K.
static const field_t hw_iomuxc_sw_pad_ctl_pad_ref_clk_32k[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: REF_CLK_32K.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: REF_CLK_3"
        "2K.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: REF_CLK_32K.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: REF_CL"
        "K_32K.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: REF_C"
        "LK_32K.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: REF_C"
        "LK_32K.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " REF_CLK_32K.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: REF_CL"
        "K_32K.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: REF_C"
        "LK_32K.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_clk[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD1_CLK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD1_CLK.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD1_CLK.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD1_CL"
        "K.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD1_C"
        "LK.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD1_C"
        "LK.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD1_CLK.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD1_CL"
        "K.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD1_C"
        "LK.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_CMD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_cmd[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD1_CMD.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD1_CMD.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD1_CMD.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD1_CM"
        "D.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD1_C"
        "MD.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD1_C"
        "MD.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD1_CMD.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD1_CM"
        "D.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD1_C"
        "MD.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_dat0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD1_DAT0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD1_DAT0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD1_DAT0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD1_DA"
        "T0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD1_D"
        "AT0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD1_D"
        "AT0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD1_DAT0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD1_DA"
        "T0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD1_D"
        "AT0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_dat1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD1_DAT1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD1_DAT1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD1_DAT1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD1_DA"
        "T1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD1_D"
        "AT1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD1_D"
        "AT1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD1_DAT1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD1_DA"
        "T1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD1_D"
        "AT1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_dat2[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD1_DAT2.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD1_DAT2.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD1_DAT2.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD1_DA"
        "T2.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD1_D"
        "AT2.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD1_D"
        "AT2.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD1_DAT2.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD1_DA"
        "T2.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD1_D"
        "AT2.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_dat3[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD1_DAT3.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD1_DAT3.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD1_DAT3.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD1_DA"
        "T3.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD1_D"
        "AT3.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD1_D"
        "AT3.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD1_DAT3.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD1_DA"
        "T3.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD1_D"
        "AT3.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_dat4[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD1_DAT4.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD1_DAT4.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD1_DAT4.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD1_DA"
        "T4.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD1_D"
        "AT4.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD1_D"
        "AT4.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD1_DAT4.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD1_DA"
        "T4.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD1_D"
        "AT4.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_dat5[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD1_DAT5.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD1_DAT5.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD1_DAT5.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD1_DA"
        "T5.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD1_D"
        "AT5.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD1_D"
        "AT5.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD1_DAT5.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD1_DA"
        "T5.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD1_D"
        "AT5.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_dat6[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD1_DAT6.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD1_DAT6.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD1_DAT6.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD1_DA"
        "T6.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD1_D"
        "AT6.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD1_D"
        "AT6.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD1_DAT6.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD1_DA"
        "T6.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD1_D"
        "AT6.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_dat7[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD1_DAT7.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD1_DAT7.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD1_DAT7.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD1_DA"
        "T7.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD1_D"
        "AT7.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD1_D"
        "AT7.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD1_DAT7.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD1_DA"
        "T7.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD1_D"
        "AT7.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_clk[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD2_CLK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD2_CLK.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD2_CLK.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD2_CL"
        "K.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD2_C"
        "LK.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD2_C"
        "LK.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD2_CLK.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD2_CL"
        "K.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD2_C"
        "LK.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_CMD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_cmd[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD2_CMD.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD2_CMD.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD2_CMD.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD2_CM"
        "D.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD2_C"
        "MD.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD2_C"
        "MD.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD2_CMD.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD2_CM"
        "D.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD2_C"
        "MD.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_dat0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD2_DAT0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD2_DAT0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD2_DAT0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD2_DA"
        "T0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD2_D"
        "AT0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD2_D"
        "AT0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD2_DAT0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD2_DA"
        "T0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD2_D"
        "AT0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_dat1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD2_DAT1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD2_DAT1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD2_DAT1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD2_DA"
        "T1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD2_D"
        "AT1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD2_D"
        "AT1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD2_DAT1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD2_DA"
        "T1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD2_D"
        "AT1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_dat2[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD2_DAT2.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD2_DAT2.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD2_DAT2.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD2_DA"
        "T2.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD2_D"
        "AT2.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD2_D"
        "AT2.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD2_DAT2.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD2_DA"
        "T2.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD2_D"
        "AT2.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_dat3[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD2_DAT3.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD2_DAT3.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD2_DAT3.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD2_DA"
        "T3.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD2_D"
        "AT3.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD2_D"
        "AT3.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD2_DAT3.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD2_DA"
        "T3.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD2_D"
        "AT3.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_dat4[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD2_DAT4.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD2_DAT4.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD2_DAT4.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD2_DA"
        "T4.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD2_D"
        "AT4.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD2_D"
        "AT4.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD2_DAT4.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD2_DA"
        "T4.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD2_D"
        "AT4.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_dat5[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD2_DAT5.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD2_DAT5.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD2_DAT5.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD2_DA"
        "T5.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD2_D"
        "AT5.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD2_D"
        "AT5.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD2_DAT5.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD2_DA"
        "T5.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD2_D"
        "AT5.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_dat6[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD2_DAT6.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD2_DAT6.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD2_DAT6.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD2_DA"
        "T6.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD2_D"
        "AT6.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD2_D"
        "AT6.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD2_DAT6.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD2_DA"
        "T6.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD2_D"
        "AT6.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_dat7[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD2_DAT7.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD2_DAT7.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD2_DAT7.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD2_DA"
        "T7.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD2_D"
        "AT7.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD2_D"
        "AT7.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD2_DAT7.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD2_DA"
        "T7.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD2_D"
        "AT7.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD2_RST.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd2_rst[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD2_RST.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD2_RST.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD2_RST.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD2_RS"
        "T.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD2_R"
        "ST.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD2_R"
        "ST.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD2_RST.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD2_RS"
        "T.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD2_R"
        "ST.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_clk[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD3_CLK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD3_CLK.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD3_CLK.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD3_CL"
        "K.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD3_C"
        "LK.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD3_C"
        "LK.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD3_CLK.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD3_CL"
        "K.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD3_C"
        "LK.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_CMD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_cmd[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD3_CMD.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD3_CMD.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD3_CMD.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD3_CM"
        "D.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD3_C"
        "MD.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD3_C"
        "MD.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD3_CMD.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD3_CM"
        "D.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD3_C"
        "MD.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_dat0[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD3_DAT0.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD3_DAT0.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD3_DAT0.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD3_DA"
        "T0.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD3_D"
        "AT0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD3_D"
        "AT0.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD3_DAT0.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD3_DA"
        "T0.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD3_D"
        "AT0.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_dat1[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD3_DAT1.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD3_DAT1.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD3_DAT1.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD3_DA"
        "T1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD3_D"
        "AT1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD3_D"
        "AT1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD3_DAT1.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD3_DA"
        "T1.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD3_D"
        "AT1.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_dat2[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD3_DAT2.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD3_DAT2.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD3_DAT2.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD3_DA"
        "T2.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD3_D"
        "AT2.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD3_D"
        "AT2.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD3_DAT2.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD3_DA"
        "T2.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD3_D"
        "AT2.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd3_dat3[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: SD3_DAT3.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: SD3_DAT3.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: SD3_DAT3.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: SD3_DA"
        "T3.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: SD3_D"
        "AT3.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: SD3_D"
        "AT3.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " SD3_DAT3.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: SD3_DA"
        "T3.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: SD3_D"
        "AT3.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART1_RXD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart1_rxd[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: UART1_RXD.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: UART1_RXD"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: UART1_RXD.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: UART1_"
        "RXD.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: UART1"
        "_RXD.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: UART1"
        "_RXD.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " UART1_RXD.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: UART1_"
        "RXD.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: UART1"
        "_RXD.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART1_TXD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart1_txd[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: UART1_TXD.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: UART1_TXD"
        ".")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: UART1_TXD.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: UART1_"
        "TXD.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: UART1"
        "_TXD.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: UART1"
        "_TXD.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " UART1_TXD.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: UART1_"
        "TXD.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: UART1"
        "_TXD.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_WDOG_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_wdog_b[] =
{
    {
        "SRE",
        DESC("Slew Rate Field  Select one out of next values for pad: WDOG_B.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for pad: WDOG_B.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        DESC("Speed Field  Select one out of next values for pad: WDOG_B.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        DESC("Open Drain Enable Field  Select one out of next values for pad: WDOG_B"
        ".")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for pad: WDOG_"
        "B.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for pad: WDOG_"
        "B.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        DESC("Pull Up / Down Configure Field  Select one out of next values for pad:"
        " WDOG_B.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for pad: WDOG_B"
        ".")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVE",
        DESC("Low Voltage Enable Field  Select one out of next values for pad: WDOG_"
        "B.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_ADDDS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_addds[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for group: ADDDS ("
        "Pads: DRAM_A0 DRAM_A1 DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14 DRA"
        "M_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7 DRAM_A8 DRAM_A9 "
        "DRAM_SDBA0 DRAM_SDBA1).")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrmode_ctl[] =
{
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for group: "
        "DDRMODE_CTL (Pads: DRAM_SDQS0 DRAM_SDQS1 DRAM_SDQS2 DRAM_SDQS3).")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRPKE.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrpke[] =
{
    {
        "PKE",
        DESC("Pull / Keep Enable Field  Select one out of next values for group: DDR"
        "PKE (Pads: DRAM_A0 DRAM_A1 DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A1"
        "4 DRAM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7 DRAM_A8 DRA"
        "M_A9 DRAM_CAS DRAM_CS0 DRAM_CS1 DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM"
        "_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DR"
        "AM_D2 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 D"
        "RAM_D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5 DR"
        "AM_D6 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_DQM0 DRAM_DQM1 DRAM_DQM2 DRAM_DQM3 "
        "DRAM_RAS DRAM_SDBA0 DRAM_SDBA1 DRAM_SDCLK_0 DRAM_SDWE).")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRPK.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrpk[] =
{
    {
        "PUE",
        DESC("Pull / Keep Select Field  Select one out of next values for group: DDR"
        "PK (Pads: DRAM_A0 DRAM_A1 DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14"
        " DRAM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7 DRAM_A8 DRAM"
        "_A9 DRAM_CAS DRAM_CS0 DRAM_CS1 DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_"
        "D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRA"
        "M_D2 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DR"
        "AM_D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5 DRA"
        "M_D6 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_DQM0 DRAM_DQM1 DRAM_DQM2 DRAM_DQM3 D"
        "RAM_RAS DRAM_SDBA0 DRAM_SDBA1 DRAM_SDCLK_0 DRAM_SDWE).")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRHYS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrhys[] =
{
    {
        "HYS",
        DESC("Hysteresis Enable Field  Select one out of next values for group: DDRH"
        "YS (Pads: DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14"
        " DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 DRAM_D20 DRAM_D2"
        "1 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_"
        "D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7 DRAM_D8 "
        "DRAM_D9 DRAM_SDQS0 DRAM_SDQS1 DRAM_SDQS2 DRAM_SDQS3).")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRMODE.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrmode[] =
{
    {
        "DDR_INPUT",
        DESC("DDR / CMOS Input Mode Field  Select one out of next values for group: "
        "DDRMODE (Pads: DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRA"
        "M_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 DRAM_D20 DR"
        "AM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 "
        "DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7 DRA"
        "M_D8 DRAM_D9).")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B0DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b0ds[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for group: B0DS (P"
        "ads: DRAM_D0 DRAM_D1 DRAM_D2 DRAM_D3 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7).")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_CTLDS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ctlds[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for group: CTLDS ("
        "Pads: DRAM_CS0 DRAM_CS1 DRAM_SDBA2 DRAM_SDCKE0 DRAM_SDCKE1 DRAM_SDWE).")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B1DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b1ds[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for group: B1DS (P"
        "ads: DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D8 DRA"
        "M_D9).")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddr_type[] =
{
    {
        "DDR_SEL",
        DESC("DDR Standard Field  Select one out of next values for group: DDR_TYPE "
        "(Pads: DRAM_A0 DRAM_A1 DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14 DR"
        "AM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7 DRAM_A8 DRAM_A9"
        " DRAM_CAS DRAM_CS0 DRAM_CS1 DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12"
        " DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D"
        "2 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_"
        "D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5 DRAM_D"
        "6 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_DQM0 DRAM_DQM1 DRAM_DQM2 DRAM_DQM3 DRAM"
        "_RAS DRAM_SDBA0 DRAM_SDBA1 DRAM_SDBA2 DRAM_SDCKE0 DRAM_SDCKE1 DRAM_SDC"
        "LK_0 DRAM_SDODT0 DRAM_SDODT1 DRAM_SDQS0 DRAM_SDQS1 DRAM_SDQS2 DRAM_SDQ"
        "S3 DRAM_SDWE).")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B2DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b2ds[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for group: B2DS (P"
        "ads: DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D20 DRAM_D21 DRAM_D22 DR"
        "AM_D23).")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B3DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b3ds[] =
{
    {
        "DSE",
        DESC("Drive Strength Field  Select one out of next values for group: B3DS (P"
        "ads: DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D30 DR"
        "AM_D31).")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USB_OTG_ID_SELECT_INPUT.
static const field_t hw_iomuxc_usb_otg_id_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USB_IPP_IND_H1_ID_SELECT_INPUT.
static const field_t hw_iomuxc_usb_ipp_ind_h1_id_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_da_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_db_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_rxclk_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_rxfs_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_txclk_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p4_input_txfs_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_da_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_db_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_rxclk_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_rxfs_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_txclk_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p5_input_txfs_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p6_input_da_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p6_input_db_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p6_input_rxclk_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p6_input_rxfs_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p6_input_txclk_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT.
static const field_t hw_iomuxc_audmux_p6_input_txfs_amx_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT.
static const field_t hw_iomuxc_ccm_pmic_vfuncional_ready_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_0_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_1_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_2_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_3_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_4_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_5_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_6_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_7_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_8_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_9_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_10_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_11_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_12_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_13_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_14_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_d_15_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_hsync_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_pixclk_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT.
static const field_t hw_iomuxc_csi_ipp_csi_vsync_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_cspi_clk_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_dataready_b_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_miso_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_mosi_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_ss_b_0_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_ss_b_1_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_ss_b_2_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ipp_ind_ss_b_3_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_cspi_clk_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_ind_miso_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_ind_mosi_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_ind_ss_b_0_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ipp_ind_ss_b_1_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_ipp_cspi_clk_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_ipp_ind_dataready_b_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_ipp_ind_miso_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_ipp_ind_mosi_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_ipp_ind_ss_b_0_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_ipp_ind_ss_b_1_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_ipp_ind_ss_b_2_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_ipp_ind_ss_b_3_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_ipp_cspi_clk_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_ipp_ind_miso_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_ipp_ind_mosi_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_ipp_ind_ss_b_0_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_ipp_ind_ss_b_1_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_ipp_ind_ss_b_2_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT.
static const field_t hw_iomuxc_epdc_ipp_epdc_pwrirq_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT.
static const field_t hw_iomuxc_epdc_ipp_epdc_pwrstat_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_FEC_FEC_COL_SELECT_INPUT.
static const field_t hw_iomuxc_fec_fec_col_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_FEC_FEC_MDI_SELECT_INPUT.
static const field_t hw_iomuxc_fec_fec_mdi_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT.
static const field_t hw_iomuxc_fec_fec_rdata_0_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT.
static const field_t hw_iomuxc_fec_fec_rdata_1_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT.
static const field_t hw_iomuxc_fec_fec_rx_clk_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT.
static const field_t hw_iomuxc_fec_fec_rx_dv_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT.
static const field_t hw_iomuxc_fec_fec_rx_er_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT.
static const field_t hw_iomuxc_fec_fec_tx_clk_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT.
static const field_t hw_iomuxc_gpt_ipp_ind_capin1_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT.
static const field_t hw_iomuxc_gpt_ipp_ind_capin2_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT.
static const field_t hw_iomuxc_gpt_ipp_ind_clkin_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c1_ipp_scl_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c1_ipp_sda_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c2_ipp_scl_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c2_ipp_sda_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c3_ipp_scl_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT.
static const field_t hw_iomuxc_i2c3_ipp_sda_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_col_0_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_col_1_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_col_2_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_col_3_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_col_4_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_col_5_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_col_6_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_col_7_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_row_0_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_row_1_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_row_2_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_row_3_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_row_4_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_row_5_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_row_6_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_ipp_ind_row_7_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_busy_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_0_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_1_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_2_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_3_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_4_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_5_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_6_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_7_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_8_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_9_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_10_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_11_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_12_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_13_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_14_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_15_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_16_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_17_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_18_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_19_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_20_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_21_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_22_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT.
static const field_t hw_iomuxc_lcdif_lcdif_rxdata_23_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT.
static const field_t hw_iomuxc_spdif_spdif_in1_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT.
static const field_t hw_iomuxc_spdif_tx_clk2_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart1_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart1_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart2_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart2_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart3_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart3_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart4_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart4_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart5_ipp_uart_rts_b_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT.
static const field_t hw_iomuxc_uart5_ipp_uart_rxd_mux_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT.
static const field_t hw_iomuxc_usb_ipp_ind_otg2_oc_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT.
static const field_t hw_iomuxc_usb_ipp_ind_otg_oc_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc1_ipp_card_det_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc1_ipp_wp_on_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_ipp_card_det_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_ipp_wp_on_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc3_ipp_card_det_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc3_ipp_dat4_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc3_ipp_dat5_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc3_ipp_dat6_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc3_ipp_dat7_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc3_ipp_wp_on_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_card_clk_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_card_det_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_cmd_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_dat0_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_dat1_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_dat2_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_dat3_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_dat4_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_dat5_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_dat6_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_dat7_in_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc4_ipp_wp_on_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_EIM_IPP_IND_DTACK_B_SELECT_INPUT.
static const field_t hw_iomuxc_eim_ipp_ind_dtack_b_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_EIM_IPP_IND_WAIT_B_SELECT_INPUT.
static const field_t hw_iomuxc_eim_ipp_ind_wait_b_select_input[] =
{
    {
        "DAISY",
        DESC("Selecting Pads Involved in Daisy Chain.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a IOMUXC module.
static const reg_t hw_iomuxc[] =
{
    {
        "GPR0",
        DESC("")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_gpr0
    },
    {
        "GPR1",
        DESC("")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_iomuxc_gpr1
    },
    {
        "GPR2",
        DESC("")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        24, // Number of bitfields
        hw_iomuxc_gpr2
    },
    {
        "GPR3",
        DESC("")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_gpr3
    },
    {
        "GPR4",
        DESC("")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_iomuxc_gpr4
    },
    {
        "GPR5",
        DESC("")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_iomuxc_gpr5
    },
    {
        "GPR6",
        DESC("")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_iomuxc_gpr6
    },
    {
        "GPR7",
        DESC("")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_iomuxc_gpr7
    },
    {
        "GPR8",
        DESC("")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_iomuxc_gpr8
    },
    {
        "GPR9",
        DESC("")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_gpr9
    },
    {
        "GPR10",
        DESC("")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_iomuxc_gpr10
    },
    {
        "GPR11",
        DESC("")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_gpr11
    },
    {
        "GPR12",
        DESC("")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_iomuxc_gpr12
    },
    {
        "GPR13",
        DESC("SATA_PHY_6    PHUG    FRUG    fast_startup    Frequency Tolerance (ppm"
        ")      000    1    1    None    780      001    2    2    None    780 "
        "     010    1    4    None    6,250      011    2    4    None    6,25"
        "0      1xx    Reserved")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_iomuxc_gpr13
    },
    {
        "SW_MUX_CTL_PAD_AUD_MCLK",
        DESC("")
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_aud_mclk
    },
    {
        "SW_MUX_CTL_PAD_AUD_RXC",
        DESC("")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_aud_rxc
    },
    {
        "SW_MUX_CTL_PAD_AUD_RXD",
        DESC("")
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_aud_rxd
    },
    {
        "SW_MUX_CTL_PAD_AUD_RXFS",
        DESC("")
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_aud_rxfs
    },
    {
        "SW_MUX_CTL_PAD_AUD_TXC",
        DESC("")
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_aud_txc
    },
    {
        "SW_MUX_CTL_PAD_AUD_TXD",
        DESC("")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_aud_txd
    },
    {
        "SW_MUX_CTL_PAD_AUD_TXFS",
        DESC("")
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_aud_txfs
    },
    {
        "SW_MUX_CTL_PAD_ECSPI1_MISO",
        DESC("")
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_ecspi1_miso
    },
    {
        "SW_MUX_CTL_PAD_ECSPI1_MOSI",
        DESC("")
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_ecspi1_mosi
    },
    {
        "SW_MUX_CTL_PAD_ECSPI1_SCLK",
        DESC("")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_ecspi1_sclk
    },
    {
        "SW_MUX_CTL_PAD_ECSPI1_SS0",
        DESC("")
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_ecspi1_ss0
    },
    {
        "SW_MUX_CTL_PAD_ECSPI2_MISO",
        DESC("")
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_ecspi2_miso
    },
    {
        "SW_MUX_CTL_PAD_ECSPI2_MOSI",
        DESC("")
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_ecspi2_mosi
    },
    {
        "SW_MUX_CTL_PAD_ECSPI2_SCLK",
        DESC("")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_ecspi2_sclk
    },
    {
        "SW_MUX_CTL_PAD_ECSPI2_SS0",
        DESC("")
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_ecspi2_ss0
    },
    {
        "SW_MUX_CTL_PAD_EPDC_BDR0",
        DESC("")
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_bdr0
    },
    {
        "SW_MUX_CTL_PAD_EPDC_BDR1",
        DESC("")
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_bdr1
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D0",
        DESC("")
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d0
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D1",
        DESC("")
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d1
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D10",
        DESC("")
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d10
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D11",
        DESC("")
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d11
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D12",
        DESC("")
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d12
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D13",
        DESC("")
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d13
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D14",
        DESC("")
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d14
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D15",
        DESC("")
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d15
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D2",
        DESC("")
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d2
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D3",
        DESC("")
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d3
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D4",
        DESC("")
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d4
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D5",
        DESC("")
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d5
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D6",
        DESC("")
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d6
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D7",
        DESC("")
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d7
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D8",
        DESC("")
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d8
    },
    {
        "SW_MUX_CTL_PAD_EPDC_D9",
        DESC("")
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_d9
    },
    {
        "SW_MUX_CTL_PAD_EPDC_GDCLK",
        DESC("")
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_gdclk
    },
    {
        "SW_MUX_CTL_PAD_EPDC_GDOE",
        DESC("")
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_gdoe
    },
    {
        "SW_MUX_CTL_PAD_EPDC_GDRL",
        DESC("")
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_gdrl
    },
    {
        "SW_MUX_CTL_PAD_EPDC_GDSP",
        DESC("")
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_gdsp
    },
    {
        "SW_MUX_CTL_PAD_EPDC_PWRCOM",
        DESC("")
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_pwrcom
    },
    {
        "SW_MUX_CTL_PAD_EPDC_PWRCTRL0",
        DESC("")
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl0
    },
    {
        "SW_MUX_CTL_PAD_EPDC_PWRCTRL1",
        DESC("")
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl1
    },
    {
        "SW_MUX_CTL_PAD_EPDC_PWRCTRL2",
        DESC("")
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl2
    },
    {
        "SW_MUX_CTL_PAD_EPDC_PWRCTRL3",
        DESC("")
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl3
    },
    {
        "SW_MUX_CTL_PAD_EPDC_PWRINT",
        DESC("")
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_pwrint
    },
    {
        "SW_MUX_CTL_PAD_EPDC_PWRSTAT",
        DESC("")
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_pwrstat
    },
    {
        "SW_MUX_CTL_PAD_EPDC_PWRWAKEUP",
        DESC("")
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_pwrwakeup
    },
    {
        "SW_MUX_CTL_PAD_EPDC_SDCE0",
        DESC("")
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_sdce0
    },
    {
        "SW_MUX_CTL_PAD_EPDC_SDCE1",
        DESC("")
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_sdce1
    },
    {
        "SW_MUX_CTL_PAD_EPDC_SDCE2",
        DESC("")
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_sdce2
    },
    {
        "SW_MUX_CTL_PAD_EPDC_SDCE3",
        DESC("")
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_sdce3
    },
    {
        "SW_MUX_CTL_PAD_EPDC_SDCLK",
        DESC("")
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_sdclk
    },
    {
        "SW_MUX_CTL_PAD_EPDC_SDLE",
        DESC("")
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_sdle
    },
    {
        "SW_MUX_CTL_PAD_EPDC_SDOE",
        DESC("")
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_sdoe
    },
    {
        "SW_MUX_CTL_PAD_EPDC_SDSHR",
        DESC("")
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_sdshr
    },
    {
        "SW_MUX_CTL_PAD_EPDC_VCOM0",
        DESC("")
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_vcom0
    },
    {
        "SW_MUX_CTL_PAD_EPDC_VCOM1",
        DESC("")
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_epdc_vcom1
    },
    {
        "SW_MUX_CTL_PAD_FEC_CRS_DV",
        DESC("")
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_fec_crs_dv
    },
    {
        "SW_MUX_CTL_PAD_FEC_MDC",
        DESC("")
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_fec_mdc
    },
    {
        "SW_MUX_CTL_PAD_FEC_MDIO",
        DESC("")
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_fec_mdio
    },
    {
        "SW_MUX_CTL_PAD_FEC_REF_CLK",
        DESC("")
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_fec_ref_clk
    },
    {
        "SW_MUX_CTL_PAD_FEC_RX_ER",
        DESC("")
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_fec_rx_er
    },
    {
        "SW_MUX_CTL_PAD_FEC_RXD0",
        DESC("")
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_fec_rxd0
    },
    {
        "SW_MUX_CTL_PAD_FEC_RXD1",
        DESC("")
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_fec_rxd1
    },
    {
        "SW_MUX_CTL_PAD_FEC_TX_CLK",
        DESC("")
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_fec_tx_clk
    },
    {
        "SW_MUX_CTL_PAD_FEC_TX_EN",
        DESC("")
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_fec_tx_en
    },
    {
        "SW_MUX_CTL_PAD_FEC_TXD0",
        DESC("")
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_fec_txd0
    },
    {
        "SW_MUX_CTL_PAD_FEC_TXD1",
        DESC("")
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_fec_txd1
    },
    {
        "SW_MUX_CTL_PAD_HSIC_DAT",
        DESC("")
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_hsic_dat
    },
    {
        "SW_MUX_CTL_PAD_HSIC_STROBE",
        DESC("")
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_hsic_strobe
    },
    {
        "SW_MUX_CTL_PAD_I2C1_SCL",
        DESC("")
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_i2c1_scl
    },
    {
        "SW_MUX_CTL_PAD_I2C1_SDA",
        DESC("")
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_i2c1_sda
    },
    {
        "SW_MUX_CTL_PAD_I2C2_SCL",
        DESC("")
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_i2c2_scl
    },
    {
        "SW_MUX_CTL_PAD_I2C2_SDA",
        DESC("")
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_i2c2_sda
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL0",
        DESC("")
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col0
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL1",
        DESC("")
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col1
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL2",
        DESC("")
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col2
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL3",
        DESC("")
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col3
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL4",
        DESC("")
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col4
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL5",
        DESC("")
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col5
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL6",
        DESC("")
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col6
    },
    {
        "SW_MUX_CTL_PAD_KEY_COL7",
        DESC("")
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_col7
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW0",
        DESC("")
        4, // Width in bytes
        0x0000018c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row0
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW1",
        DESC("")
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row1
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW2",
        DESC("")
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row2
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW3",
        DESC("")
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row3
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW4",
        DESC("")
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row4
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW5",
        DESC("")
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row5
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW6",
        DESC("")
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row6
    },
    {
        "SW_MUX_CTL_PAD_KEY_ROW7",
        DESC("")
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_key_row7
    },
    {
        "SW_MUX_CTL_PAD_LCD_CLK",
        DESC("")
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_clk
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT0",
        DESC("")
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat0
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT1",
        DESC("")
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat1
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT10",
        DESC("")
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat10
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT11",
        DESC("")
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat11
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT12",
        DESC("")
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat12
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT13",
        DESC("")
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat13
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT14",
        DESC("")
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat14
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT15",
        DESC("")
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat15
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT16",
        DESC("")
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat16
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT17",
        DESC("")
        4, // Width in bytes
        0x000001d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat17
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT18",
        DESC("")
        4, // Width in bytes
        0x000001d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat18
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT19",
        DESC("")
        4, // Width in bytes
        0x000001dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat19
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT2",
        DESC("")
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat2
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT20",
        DESC("")
        4, // Width in bytes
        0x000001e4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat20
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT21",
        DESC("")
        4, // Width in bytes
        0x000001e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat21
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT22",
        DESC("")
        4, // Width in bytes
        0x000001ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat22
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT23",
        DESC("")
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat23
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT3",
        DESC("")
        4, // Width in bytes
        0x000001f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat3
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT4",
        DESC("")
        4, // Width in bytes
        0x000001f8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat4
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT5",
        DESC("")
        4, // Width in bytes
        0x000001fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat5
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT6",
        DESC("")
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat6
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT7",
        DESC("")
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat7
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT8",
        DESC("")
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat8
    },
    {
        "SW_MUX_CTL_PAD_LCD_DAT9",
        DESC("")
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_dat9
    },
    {
        "SW_MUX_CTL_PAD_LCD_ENABLE",
        DESC("")
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_enable
    },
    {
        "SW_MUX_CTL_PAD_LCD_HSYNC",
        DESC("")
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_hsync
    },
    {
        "SW_MUX_CTL_PAD_LCD_RESET",
        DESC("")
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_reset
    },
    {
        "SW_MUX_CTL_PAD_LCD_VSYNC",
        DESC("")
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_vsync
    },
    {
        "SW_MUX_CTL_PAD_PWM1",
        DESC("")
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_pwm1
    },
    {
        "SW_MUX_CTL_PAD_REF_CLK_24M",
        DESC("")
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_ref_clk_24m
    },
    {
        "SW_MUX_CTL_PAD_REF_CLK_32K",
        DESC("")
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_ref_clk_32k
    },
    {
        "SW_MUX_CTL_PAD_SD1_CLK",
        DESC("")
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_clk
    },
    {
        "SW_MUX_CTL_PAD_SD1_CMD",
        DESC("")
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_cmd
    },
    {
        "SW_MUX_CTL_PAD_SD1_DAT0",
        DESC("")
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_dat0
    },
    {
        "SW_MUX_CTL_PAD_SD1_DAT1",
        DESC("")
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_dat1
    },
    {
        "SW_MUX_CTL_PAD_SD1_DAT2",
        DESC("")
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_dat2
    },
    {
        "SW_MUX_CTL_PAD_SD1_DAT3",
        DESC("")
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_dat3
    },
    {
        "SW_MUX_CTL_PAD_SD1_DAT4",
        DESC("")
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_dat4
    },
    {
        "SW_MUX_CTL_PAD_SD1_DAT5",
        DESC("")
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_dat5
    },
    {
        "SW_MUX_CTL_PAD_SD1_DAT6",
        DESC("")
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_dat6
    },
    {
        "SW_MUX_CTL_PAD_SD1_DAT7",
        DESC("")
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_dat7
    },
    {
        "SW_MUX_CTL_PAD_SD2_CLK",
        DESC("")
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_clk
    },
    {
        "SW_MUX_CTL_PAD_SD2_CMD",
        DESC("")
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_cmd
    },
    {
        "SW_MUX_CTL_PAD_SD2_DAT0",
        DESC("")
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_dat0
    },
    {
        "SW_MUX_CTL_PAD_SD2_DAT1",
        DESC("")
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_dat1
    },
    {
        "SW_MUX_CTL_PAD_SD2_DAT2",
        DESC("")
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_dat2
    },
    {
        "SW_MUX_CTL_PAD_SD2_DAT3",
        DESC("")
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_dat3
    },
    {
        "SW_MUX_CTL_PAD_SD2_DAT4",
        DESC("")
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_dat4
    },
    {
        "SW_MUX_CTL_PAD_SD2_DAT5",
        DESC("")
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_dat5
    },
    {
        "SW_MUX_CTL_PAD_SD2_DAT6",
        DESC("")
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_dat6
    },
    {
        "SW_MUX_CTL_PAD_SD2_DAT7",
        DESC("")
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_dat7
    },
    {
        "SW_MUX_CTL_PAD_SD2_RST",
        DESC("")
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd2_rst
    },
    {
        "SW_MUX_CTL_PAD_SD3_CLK",
        DESC("")
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_clk
    },
    {
        "SW_MUX_CTL_PAD_SD3_CMD",
        DESC("")
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_cmd
    },
    {
        "SW_MUX_CTL_PAD_SD3_DAT0",
        DESC("")
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_dat0
    },
    {
        "SW_MUX_CTL_PAD_SD3_DAT1",
        DESC("")
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_dat1
    },
    {
        "SW_MUX_CTL_PAD_SD3_DAT2",
        DESC("")
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_dat2
    },
    {
        "SW_MUX_CTL_PAD_SD3_DAT3",
        DESC("")
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd3_dat3
    },
    {
        "SW_MUX_CTL_PAD_UART1_RXD",
        DESC("")
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart1_rxd
    },
    {
        "SW_MUX_CTL_PAD_UART1_TXD",
        DESC("")
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart1_txd
    },
    {
        "SW_MUX_CTL_PAD_WDOG_B",
        DESC("")
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_wdog_b
    },
    {
        "SW_PAD_CTL_PAD_AUD_MCLK",
        DESC("")
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_aud_mclk
    },
    {
        "SW_PAD_CTL_PAD_AUD_RXC",
        DESC("")
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_aud_rxc
    },
    {
        "SW_PAD_CTL_PAD_AUD_RXD",
        DESC("")
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_aud_rxd
    },
    {
        "SW_PAD_CTL_PAD_AUD_RXFS",
        DESC("")
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_aud_rxfs
    },
    {
        "SW_PAD_CTL_PAD_AUD_TXC",
        DESC("")
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_aud_txc
    },
    {
        "SW_PAD_CTL_PAD_AUD_TXD",
        DESC("")
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_aud_txd
    },
    {
        "SW_PAD_CTL_PAD_AUD_TXFS",
        DESC("")
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_aud_txfs
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A0",
        DESC("")
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A1",
        DESC("")
        4, // Width in bytes
        0x000002c4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A10",
        DESC("")
        4, // Width in bytes
        0x000002c8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a10
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A11",
        DESC("")
        4, // Width in bytes
        0x000002cc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a11
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A12",
        DESC("")
        4, // Width in bytes
        0x000002d0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a12
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A13",
        DESC("")
        4, // Width in bytes
        0x000002d4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a13
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A14",
        DESC("")
        4, // Width in bytes
        0x000002d8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a14
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A15",
        DESC("")
        4, // Width in bytes
        0x000002dc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a15
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A2",
        DESC("")
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a2
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A3",
        DESC("")
        4, // Width in bytes
        0x000002e4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a3
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A4",
        DESC("")
        4, // Width in bytes
        0x000002e8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a4
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A5",
        DESC("")
        4, // Width in bytes
        0x000002ec, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a5
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A6",
        DESC("")
        4, // Width in bytes
        0x000002f0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a6
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A7",
        DESC("")
        4, // Width in bytes
        0x000002f4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a7
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A8",
        DESC("")
        4, // Width in bytes
        0x000002f8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a8
    },
    {
        "SW_PAD_CTL_PAD_DRAM_A9",
        DESC("")
        4, // Width in bytes
        0x000002fc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_a9
    },
    {
        "SW_PAD_CTL_PAD_DRAM_CAS",
        DESC("")
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_cas
    },
    {
        "SW_PAD_CTL_PAD_DRAM_CS0",
        DESC("")
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_cs0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_CS1",
        DESC("")
        4, // Width in bytes
        0x00000308, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_cs1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM0",
        DESC("")
        4, // Width in bytes
        0x0000030c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM1",
        DESC("")
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM2",
        DESC("")
        4, // Width in bytes
        0x00000314, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm2
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM3",
        DESC("")
        4, // Width in bytes
        0x00000318, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm3
    },
    {
        "SW_PAD_CTL_PAD_DRAM_RAS",
        DESC("")
        4, // Width in bytes
        0x0000031c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_ras
    },
    {
        "SW_PAD_CTL_PAD_DRAM_RESET",
        DESC("")
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_reset
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDBA0",
        DESC("")
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdba0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDBA1",
        DESC("")
        4, // Width in bytes
        0x00000328, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdba1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDBA2",
        DESC("")
        4, // Width in bytes
        0x0000032c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdba2
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCKE0",
        DESC("")
        4, // Width in bytes
        0x00000330, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdcke0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCKE1",
        DESC("")
        4, // Width in bytes
        0x00000334, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdcke1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCLK_0",
        DESC("")
        4, // Width in bytes
        0x00000338, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdclk_0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDODT0",
        DESC("")
        4, // Width in bytes
        0x0000033c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdodt0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDODT1",
        DESC("")
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdodt1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS0",
        DESC("")
        4, // Width in bytes
        0x00000344, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS1",
        DESC("")
        4, // Width in bytes
        0x00000348, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS2",
        DESC("")
        4, // Width in bytes
        0x0000034c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs2
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS3",
        DESC("")
        4, // Width in bytes
        0x00000350, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs3
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDWE",
        DESC("")
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdwe
    },
    {
        "SW_PAD_CTL_PAD_ECSPI1_MISO",
        DESC("")
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_ecspi1_miso
    },
    {
        "SW_PAD_CTL_PAD_ECSPI1_MOSI",
        DESC("")
        4, // Width in bytes
        0x0000035c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_ecspi1_mosi
    },
    {
        "SW_PAD_CTL_PAD_ECSPI1_SCLK",
        DESC("")
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_ecspi1_sclk
    },
    {
        "SW_PAD_CTL_PAD_ECSPI1_SS0",
        DESC("")
        4, // Width in bytes
        0x00000364, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_ecspi1_ss0
    },
    {
        "SW_PAD_CTL_PAD_ECSPI2_MISO",
        DESC("")
        4, // Width in bytes
        0x00000368, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_ecspi2_miso
    },
    {
        "SW_PAD_CTL_PAD_ECSPI2_MOSI",
        DESC("")
        4, // Width in bytes
        0x0000036c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_ecspi2_mosi
    },
    {
        "SW_PAD_CTL_PAD_ECSPI2_SCLK",
        DESC("")
        4, // Width in bytes
        0x00000370, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_ecspi2_sclk
    },
    {
        "SW_PAD_CTL_PAD_ECSPI2_SS0",
        DESC("")
        4, // Width in bytes
        0x00000374, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_ecspi2_ss0
    },
    {
        "SW_PAD_CTL_PAD_EPDC_BDR0",
        DESC("")
        4, // Width in bytes
        0x00000378, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_bdr0
    },
    {
        "SW_PAD_CTL_PAD_EPDC_BDR1",
        DESC("")
        4, // Width in bytes
        0x0000037c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_bdr1
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D0",
        DESC("")
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d0
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D1",
        DESC("")
        4, // Width in bytes
        0x00000384, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d1
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D10",
        DESC("")
        4, // Width in bytes
        0x00000388, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d10
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D11",
        DESC("")
        4, // Width in bytes
        0x0000038c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d11
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D12",
        DESC("")
        4, // Width in bytes
        0x00000390, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d12
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D13",
        DESC("")
        4, // Width in bytes
        0x00000394, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d13
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D14",
        DESC("")
        4, // Width in bytes
        0x00000398, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d14
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D15",
        DESC("")
        4, // Width in bytes
        0x0000039c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d15
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D2",
        DESC("")
        4, // Width in bytes
        0x000003a0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d2
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D3",
        DESC("")
        4, // Width in bytes
        0x000003a4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d3
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D4",
        DESC("")
        4, // Width in bytes
        0x000003a8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d4
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D5",
        DESC("")
        4, // Width in bytes
        0x000003ac, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d5
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D6",
        DESC("")
        4, // Width in bytes
        0x000003b0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d6
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D7",
        DESC("")
        4, // Width in bytes
        0x000003b4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d7
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D8",
        DESC("")
        4, // Width in bytes
        0x000003b8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d8
    },
    {
        "SW_PAD_CTL_PAD_EPDC_D9",
        DESC("")
        4, // Width in bytes
        0x000003bc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_d9
    },
    {
        "SW_PAD_CTL_PAD_EPDC_GDCLK",
        DESC("")
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_gdclk
    },
    {
        "SW_PAD_CTL_PAD_EPDC_GDOE",
        DESC("")
        4, // Width in bytes
        0x000003c4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_gdoe
    },
    {
        "SW_PAD_CTL_PAD_EPDC_GDRL",
        DESC("")
        4, // Width in bytes
        0x000003c8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_gdrl
    },
    {
        "SW_PAD_CTL_PAD_EPDC_GDSP",
        DESC("")
        4, // Width in bytes
        0x000003cc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_gdsp
    },
    {
        "SW_PAD_CTL_PAD_EPDC_PWRCOM",
        DESC("")
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_pwrcom
    },
    {
        "SW_PAD_CTL_PAD_EPDC_PWRCTRL0",
        DESC("")
        4, // Width in bytes
        0x000003d4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl0
    },
    {
        "SW_PAD_CTL_PAD_EPDC_PWRCTRL1",
        DESC("")
        4, // Width in bytes
        0x000003d8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl1
    },
    {
        "SW_PAD_CTL_PAD_EPDC_PWRCTRL2",
        DESC("")
        4, // Width in bytes
        0x000003dc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl2
    },
    {
        "SW_PAD_CTL_PAD_EPDC_PWRCTRL3",
        DESC("")
        4, // Width in bytes
        0x000003e0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl3
    },
    {
        "SW_PAD_CTL_PAD_EPDC_PWRINT",
        DESC("")
        4, // Width in bytes
        0x000003e4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_pwrint
    },
    {
        "SW_PAD_CTL_PAD_EPDC_PWRSTAT",
        DESC("")
        4, // Width in bytes
        0x000003e8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_pwrstat
    },
    {
        "SW_PAD_CTL_PAD_EPDC_PWRWAKEUP",
        DESC("")
        4, // Width in bytes
        0x000003ec, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_pwrwakeup
    },
    {
        "SW_PAD_CTL_PAD_EPDC_SDCE0",
        DESC("")
        4, // Width in bytes
        0x000003f0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_sdce0
    },
    {
        "SW_PAD_CTL_PAD_EPDC_SDCE1",
        DESC("")
        4, // Width in bytes
        0x000003f4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_sdce1
    },
    {
        "SW_PAD_CTL_PAD_EPDC_SDCE2",
        DESC("")
        4, // Width in bytes
        0x000003f8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_sdce2
    },
    {
        "SW_PAD_CTL_PAD_EPDC_SDCE3",
        DESC("")
        4, // Width in bytes
        0x000003fc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_sdce3
    },
    {
        "SW_PAD_CTL_PAD_EPDC_SDCLK",
        DESC("")
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_sdclk
    },
    {
        "SW_PAD_CTL_PAD_EPDC_SDLE",
        DESC("")
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_sdle
    },
    {
        "SW_PAD_CTL_PAD_EPDC_SDOE",
        DESC("")
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_sdoe
    },
    {
        "SW_PAD_CTL_PAD_EPDC_SDSHR",
        DESC("")
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_sdshr
    },
    {
        "SW_PAD_CTL_PAD_EPDC_VCOM0",
        DESC("")
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_vcom0
    },
    {
        "SW_PAD_CTL_PAD_EPDC_VCOM1",
        DESC("")
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_epdc_vcom1
    },
    {
        "SW_PAD_CTL_PAD_FEC_CRS_DV",
        DESC("")
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_fec_crs_dv
    },
    {
        "SW_PAD_CTL_PAD_FEC_MDC",
        DESC("")
        4, // Width in bytes
        0x0000041c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_fec_mdc
    },
    {
        "SW_PAD_CTL_PAD_FEC_MDIO",
        DESC("")
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_fec_mdio
    },
    {
        "SW_PAD_CTL_PAD_FEC_REF_CLK",
        DESC("")
        4, // Width in bytes
        0x00000424, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_fec_ref_clk
    },
    {
        "SW_PAD_CTL_PAD_FEC_RX_ER",
        DESC("")
        4, // Width in bytes
        0x00000428, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_fec_rx_er
    },
    {
        "SW_PAD_CTL_PAD_FEC_RXD0",
        DESC("")
        4, // Width in bytes
        0x0000042c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_fec_rxd0
    },
    {
        "SW_PAD_CTL_PAD_FEC_RXD1",
        DESC("")
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_fec_rxd1
    },
    {
        "SW_PAD_CTL_PAD_FEC_TX_CLK",
        DESC("")
        4, // Width in bytes
        0x00000434, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_fec_tx_clk
    },
    {
        "SW_PAD_CTL_PAD_FEC_TX_EN",
        DESC("")
        4, // Width in bytes
        0x00000438, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_fec_tx_en
    },
    {
        "SW_PAD_CTL_PAD_FEC_TXD0",
        DESC("")
        4, // Width in bytes
        0x0000043c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_fec_txd0
    },
    {
        "SW_PAD_CTL_PAD_FEC_TXD1",
        DESC("")
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_fec_txd1
    },
    {
        "SW_PAD_CTL_PAD_HSIC_DAT",
        DESC("")
        4, // Width in bytes
        0x00000444, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_hsic_dat
    },
    {
        "SW_PAD_CTL_PAD_HSIC_STROBE",
        DESC("")
        4, // Width in bytes
        0x00000448, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_hsic_strobe
    },
    {
        "SW_PAD_CTL_PAD_I2C1_SCL",
        DESC("")
        4, // Width in bytes
        0x0000044c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_i2c1_scl
    },
    {
        "SW_PAD_CTL_PAD_I2C1_SDA",
        DESC("")
        4, // Width in bytes
        0x00000450, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_i2c1_sda
    },
    {
        "SW_PAD_CTL_PAD_I2C2_SCL",
        DESC("")
        4, // Width in bytes
        0x00000454, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_i2c2_scl
    },
    {
        "SW_PAD_CTL_PAD_I2C2_SDA",
        DESC("")
        4, // Width in bytes
        0x00000458, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_i2c2_sda
    },
    {
        "SW_PAD_CTL_PAD_JTAG_MOD",
        DESC("")
        4, // Width in bytes
        0x0000045c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_mod
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TCK",
        DESC("")
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tck
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TDI",
        DESC("")
        4, // Width in bytes
        0x00000464, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tdi
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TDO",
        DESC("")
        4, // Width in bytes
        0x00000468, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tdo
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TMS",
        DESC("")
        4, // Width in bytes
        0x0000046c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tms
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TRSTB",
        DESC("")
        4, // Width in bytes
        0x00000470, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_trstb
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL0",
        DESC("")
        4, // Width in bytes
        0x00000474, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col0
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL1",
        DESC("")
        4, // Width in bytes
        0x00000478, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col1
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL2",
        DESC("")
        4, // Width in bytes
        0x0000047c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col2
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL3",
        DESC("")
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col3
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL4",
        DESC("")
        4, // Width in bytes
        0x00000484, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col4
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL5",
        DESC("")
        4, // Width in bytes
        0x00000488, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col5
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL6",
        DESC("")
        4, // Width in bytes
        0x0000048c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col6
    },
    {
        "SW_PAD_CTL_PAD_KEY_COL7",
        DESC("")
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_col7
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW0",
        DESC("")
        4, // Width in bytes
        0x00000494, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row0
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW1",
        DESC("")
        4, // Width in bytes
        0x00000498, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row1
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW2",
        DESC("")
        4, // Width in bytes
        0x0000049c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row2
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW3",
        DESC("")
        4, // Width in bytes
        0x000004a0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row3
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW4",
        DESC("")
        4, // Width in bytes
        0x000004a4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row4
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW5",
        DESC("")
        4, // Width in bytes
        0x000004a8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row5
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW6",
        DESC("")
        4, // Width in bytes
        0x000004ac, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row6
    },
    {
        "SW_PAD_CTL_PAD_KEY_ROW7",
        DESC("")
        4, // Width in bytes
        0x000004b0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_key_row7
    },
    {
        "SW_PAD_CTL_PAD_LCD_CLK",
        DESC("")
        4, // Width in bytes
        0x000004b4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_clk
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT0",
        DESC("")
        4, // Width in bytes
        0x000004b8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat0
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT1",
        DESC("")
        4, // Width in bytes
        0x000004bc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat1
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT10",
        DESC("")
        4, // Width in bytes
        0x000004c0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat10
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT11",
        DESC("")
        4, // Width in bytes
        0x000004c4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat11
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT12",
        DESC("")
        4, // Width in bytes
        0x000004c8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat12
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT13",
        DESC("")
        4, // Width in bytes
        0x000004cc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat13
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT14",
        DESC("")
        4, // Width in bytes
        0x000004d0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat14
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT15",
        DESC("")
        4, // Width in bytes
        0x000004d4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat15
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT16",
        DESC("")
        4, // Width in bytes
        0x000004d8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat16
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT17",
        DESC("")
        4, // Width in bytes
        0x000004dc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat17
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT18",
        DESC("")
        4, // Width in bytes
        0x000004e0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat18
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT19",
        DESC("")
        4, // Width in bytes
        0x000004e4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat19
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT2",
        DESC("")
        4, // Width in bytes
        0x000004e8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat2
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT20",
        DESC("")
        4, // Width in bytes
        0x000004ec, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat20
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT21",
        DESC("")
        4, // Width in bytes
        0x000004f0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat21
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT22",
        DESC("")
        4, // Width in bytes
        0x000004f4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat22
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT23",
        DESC("")
        4, // Width in bytes
        0x000004f8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat23
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT3",
        DESC("")
        4, // Width in bytes
        0x000004fc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat3
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT4",
        DESC("")
        4, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat4
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT5",
        DESC("")
        4, // Width in bytes
        0x00000504, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat5
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT6",
        DESC("")
        4, // Width in bytes
        0x00000508, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat6
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT7",
        DESC("")
        4, // Width in bytes
        0x0000050c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat7
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT8",
        DESC("")
        4, // Width in bytes
        0x00000510, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat8
    },
    {
        "SW_PAD_CTL_PAD_LCD_DAT9",
        DESC("")
        4, // Width in bytes
        0x00000514, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_dat9
    },
    {
        "SW_PAD_CTL_PAD_LCD_ENABLE",
        DESC("")
        4, // Width in bytes
        0x00000518, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_enable
    },
    {
        "SW_PAD_CTL_PAD_LCD_HSYNC",
        DESC("")
        4, // Width in bytes
        0x0000051c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_hsync
    },
    {
        "SW_PAD_CTL_PAD_LCD_RESET",
        DESC("")
        4, // Width in bytes
        0x00000520, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_reset
    },
    {
        "SW_PAD_CTL_PAD_LCD_VSYNC",
        DESC("")
        4, // Width in bytes
        0x00000524, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_vsync
    },
    {
        "SW_PAD_CTL_PAD_PWM1",
        DESC("")
        4, // Width in bytes
        0x00000528, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_pwm1
    },
    {
        "SW_PAD_CTL_PAD_REF_CLK_24M",
        DESC("")
        4, // Width in bytes
        0x0000052c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_ref_clk_24m
    },
    {
        "SW_PAD_CTL_PAD_REF_CLK_32K",
        DESC("")
        4, // Width in bytes
        0x00000530, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_ref_clk_32k
    },
    {
        "SW_PAD_CTL_PAD_SD1_CLK",
        DESC("")
        4, // Width in bytes
        0x00000534, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_clk
    },
    {
        "SW_PAD_CTL_PAD_SD1_CMD",
        DESC("")
        4, // Width in bytes
        0x00000538, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_cmd
    },
    {
        "SW_PAD_CTL_PAD_SD1_DAT0",
        DESC("")
        4, // Width in bytes
        0x0000053c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_dat0
    },
    {
        "SW_PAD_CTL_PAD_SD1_DAT1",
        DESC("")
        4, // Width in bytes
        0x00000540, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_dat1
    },
    {
        "SW_PAD_CTL_PAD_SD1_DAT2",
        DESC("")
        4, // Width in bytes
        0x00000544, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_dat2
    },
    {
        "SW_PAD_CTL_PAD_SD1_DAT3",
        DESC("")
        4, // Width in bytes
        0x00000548, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_dat3
    },
    {
        "SW_PAD_CTL_PAD_SD1_DAT4",
        DESC("")
        4, // Width in bytes
        0x0000054c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_dat4
    },
    {
        "SW_PAD_CTL_PAD_SD1_DAT5",
        DESC("")
        4, // Width in bytes
        0x00000550, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_dat5
    },
    {
        "SW_PAD_CTL_PAD_SD1_DAT6",
        DESC("")
        4, // Width in bytes
        0x00000554, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_dat6
    },
    {
        "SW_PAD_CTL_PAD_SD1_DAT7",
        DESC("")
        4, // Width in bytes
        0x00000558, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_dat7
    },
    {
        "SW_PAD_CTL_PAD_SD2_CLK",
        DESC("")
        4, // Width in bytes
        0x0000055c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_clk
    },
    {
        "SW_PAD_CTL_PAD_SD2_CMD",
        DESC("")
        4, // Width in bytes
        0x00000560, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_cmd
    },
    {
        "SW_PAD_CTL_PAD_SD2_DAT0",
        DESC("")
        4, // Width in bytes
        0x00000564, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_dat0
    },
    {
        "SW_PAD_CTL_PAD_SD2_DAT1",
        DESC("")
        4, // Width in bytes
        0x00000568, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_dat1
    },
    {
        "SW_PAD_CTL_PAD_SD2_DAT2",
        DESC("")
        4, // Width in bytes
        0x0000056c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_dat2
    },
    {
        "SW_PAD_CTL_PAD_SD2_DAT3",
        DESC("")
        4, // Width in bytes
        0x00000570, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_dat3
    },
    {
        "SW_PAD_CTL_PAD_SD2_DAT4",
        DESC("")
        4, // Width in bytes
        0x00000574, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_dat4
    },
    {
        "SW_PAD_CTL_PAD_SD2_DAT5",
        DESC("")
        4, // Width in bytes
        0x00000578, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_dat5
    },
    {
        "SW_PAD_CTL_PAD_SD2_DAT6",
        DESC("")
        4, // Width in bytes
        0x0000057c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_dat6
    },
    {
        "SW_PAD_CTL_PAD_SD2_DAT7",
        DESC("")
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_dat7
    },
    {
        "SW_PAD_CTL_PAD_SD2_RST",
        DESC("")
        4, // Width in bytes
        0x00000584, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd2_rst
    },
    {
        "SW_PAD_CTL_PAD_SD3_CLK",
        DESC("")
        4, // Width in bytes
        0x00000588, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_clk
    },
    {
        "SW_PAD_CTL_PAD_SD3_CMD",
        DESC("")
        4, // Width in bytes
        0x0000058c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_cmd
    },
    {
        "SW_PAD_CTL_PAD_SD3_DAT0",
        DESC("")
        4, // Width in bytes
        0x00000590, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_dat0
    },
    {
        "SW_PAD_CTL_PAD_SD3_DAT1",
        DESC("")
        4, // Width in bytes
        0x00000594, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_dat1
    },
    {
        "SW_PAD_CTL_PAD_SD3_DAT2",
        DESC("")
        4, // Width in bytes
        0x00000598, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_dat2
    },
    {
        "SW_PAD_CTL_PAD_SD3_DAT3",
        DESC("")
        4, // Width in bytes
        0x0000059c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd3_dat3
    },
    {
        "SW_PAD_CTL_PAD_UART1_RXD",
        DESC("")
        4, // Width in bytes
        0x000005a0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart1_rxd
    },
    {
        "SW_PAD_CTL_PAD_UART1_TXD",
        DESC("")
        4, // Width in bytes
        0x000005a4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart1_txd
    },
    {
        "SW_PAD_CTL_PAD_WDOG_B",
        DESC("")
        4, // Width in bytes
        0x000005a8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_wdog_b
    },
    {
        "SW_PAD_CTL_GRP_ADDDS",
        DESC("")
        4, // Width in bytes
        0x000005ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_addds
    },
    {
        "SW_PAD_CTL_GRP_DDRMODE_CTL",
        DESC("")
        4, // Width in bytes
        0x000005b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrmode_ctl
    },
    {
        "SW_PAD_CTL_GRP_DDRPKE",
        DESC("")
        4, // Width in bytes
        0x000005b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrpke
    },
    {
        "SW_PAD_CTL_GRP_DDRPK",
        DESC("")
        4, // Width in bytes
        0x000005b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrpk
    },
    {
        "SW_PAD_CTL_GRP_DDRHYS",
        DESC("")
        4, // Width in bytes
        0x000005bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrhys
    },
    {
        "SW_PAD_CTL_GRP_DDRMODE",
        DESC("")
        4, // Width in bytes
        0x000005c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrmode
    },
    {
        "SW_PAD_CTL_GRP_B0DS",
        DESC("")
        4, // Width in bytes
        0x000005c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b0ds
    },
    {
        "SW_PAD_CTL_GRP_CTLDS",
        DESC("")
        4, // Width in bytes
        0x000005c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ctlds
    },
    {
        "SW_PAD_CTL_GRP_B1DS",
        DESC("")
        4, // Width in bytes
        0x000005cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b1ds
    },
    {
        "SW_PAD_CTL_GRP_DDR_TYPE",
        DESC("")
        4, // Width in bytes
        0x000005d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddr_type
    },
    {
        "SW_PAD_CTL_GRP_B2DS",
        DESC("")
        4, // Width in bytes
        0x000005d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b2ds
    },
    {
        "SW_PAD_CTL_GRP_B3DS",
        DESC("")
        4, // Width in bytes
        0x000005d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b3ds
    },
    {
        "USB_OTG_ID_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000005dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usb_otg_id_select_input
    },
    {
        "USB_IPP_IND_H1_ID_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000005e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usb_ipp_ind_h1_id_select_input
    },
    {
        "AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000005e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_da_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000005e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_db_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000005ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_rxclk_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000005f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_rxfs_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000005f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_txclk_amx_select_input
    },
    {
        "AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000005f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p4_input_txfs_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000005fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_da_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_db_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000604, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_rxclk_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000608, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_rxfs_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000060c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_txclk_amx_select_input
    },
    {
        "AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p5_input_txfs_amx_select_input
    },
    {
        "AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000614, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p6_input_da_amx_select_input
    },
    {
        "AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000618, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p6_input_db_amx_select_input
    },
    {
        "AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000061c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p6_input_rxclk_amx_select_input
    },
    {
        "AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000620, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p6_input_rxfs_amx_select_input
    },
    {
        "AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000624, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p6_input_txclk_amx_select_input
    },
    {
        "AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000628, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_audmux_p6_input_txfs_amx_select_input
    },
    {
        "CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000062c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ccm_pmic_vfuncional_ready_select_input
    },
    {
        "CSI_IPP_CSI_D_0_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000630, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_0_select_input
    },
    {
        "CSI_IPP_CSI_D_1_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000634, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_1_select_input
    },
    {
        "CSI_IPP_CSI_D_2_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000638, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_2_select_input
    },
    {
        "CSI_IPP_CSI_D_3_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000063c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_3_select_input
    },
    {
        "CSI_IPP_CSI_D_4_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000640, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_4_select_input
    },
    {
        "CSI_IPP_CSI_D_5_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000644, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_5_select_input
    },
    {
        "CSI_IPP_CSI_D_6_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000648, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_6_select_input
    },
    {
        "CSI_IPP_CSI_D_7_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000064c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_7_select_input
    },
    {
        "CSI_IPP_CSI_D_8_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000650, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_8_select_input
    },
    {
        "CSI_IPP_CSI_D_9_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000654, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_9_select_input
    },
    {
        "CSI_IPP_CSI_D_10_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000658, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_10_select_input
    },
    {
        "CSI_IPP_CSI_D_11_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000065c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_11_select_input
    },
    {
        "CSI_IPP_CSI_D_12_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000660, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_12_select_input
    },
    {
        "CSI_IPP_CSI_D_13_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000664, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_13_select_input
    },
    {
        "CSI_IPP_CSI_D_14_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000668, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_14_select_input
    },
    {
        "CSI_IPP_CSI_D_15_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000066c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_d_15_select_input
    },
    {
        "CSI_IPP_CSI_HSYNC_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000670, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_hsync_select_input
    },
    {
        "CSI_IPP_CSI_PIXCLK_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000674, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_pixclk_select_input
    },
    {
        "CSI_IPP_CSI_VSYNC_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000678, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_ipp_csi_vsync_select_input
    },
    {
        "ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000067c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_cspi_clk_in_select_input
    },
    {
        "ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000680, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_dataready_b_select_input
    },
    {
        "ECSPI1_IPP_IND_MISO_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000684, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_miso_select_input
    },
    {
        "ECSPI1_IPP_IND_MOSI_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000688, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_mosi_select_input
    },
    {
        "ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000068c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_ss_b_0_select_input
    },
    {
        "ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000690, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_ss_b_1_select_input
    },
    {
        "ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000694, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_ss_b_2_select_input
    },
    {
        "ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000698, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ipp_ind_ss_b_3_select_input
    },
    {
        "ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000069c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_cspi_clk_in_select_input
    },
    {
        "ECSPI2_IPP_IND_MISO_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_ind_miso_select_input
    },
    {
        "ECSPI2_IPP_IND_MOSI_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_ind_mosi_select_input
    },
    {
        "ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_ind_ss_b_0_select_input
    },
    {
        "ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ipp_ind_ss_b_1_select_input
    },
    {
        "ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ipp_cspi_clk_in_select_input
    },
    {
        "ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ipp_ind_dataready_b_select_input
    },
    {
        "ECSPI3_IPP_IND_MISO_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ipp_ind_miso_select_input
    },
    {
        "ECSPI3_IPP_IND_MOSI_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ipp_ind_mosi_select_input
    },
    {
        "ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ipp_ind_ss_b_0_select_input
    },
    {
        "ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ipp_ind_ss_b_1_select_input
    },
    {
        "ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ipp_ind_ss_b_2_select_input
    },
    {
        "ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ipp_ind_ss_b_3_select_input
    },
    {
        "ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_ipp_cspi_clk_in_select_input
    },
    {
        "ECSPI4_IPP_IND_MISO_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_ipp_ind_miso_select_input
    },
    {
        "ECSPI4_IPP_IND_MOSI_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_ipp_ind_mosi_select_input
    },
    {
        "ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_ipp_ind_ss_b_0_select_input
    },
    {
        "ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_ipp_ind_ss_b_1_select_input
    },
    {
        "ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_ipp_ind_ss_b_2_select_input
    },
    {
        "EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_epdc_ipp_epdc_pwrirq_select_input
    },
    {
        "EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_epdc_ipp_epdc_pwrstat_select_input
    },
    {
        "FEC_FEC_COL_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_fec_fec_col_select_input
    },
    {
        "FEC_FEC_MDI_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_fec_fec_mdi_select_input
    },
    {
        "FEC_FEC_RDATA_0_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_fec_fec_rdata_0_select_input
    },
    {
        "FEC_FEC_RDATA_1_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000006fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_fec_fec_rdata_1_select_input
    },
    {
        "FEC_FEC_RX_CLK_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000700, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_fec_fec_rx_clk_select_input
    },
    {
        "FEC_FEC_RX_DV_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000704, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_fec_fec_rx_dv_select_input
    },
    {
        "FEC_FEC_RX_ER_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000708, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_fec_fec_rx_er_select_input
    },
    {
        "FEC_FEC_TX_CLK_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000070c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_fec_fec_tx_clk_select_input
    },
    {
        "GPT_IPP_IND_CAPIN1_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000710, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_gpt_ipp_ind_capin1_select_input
    },
    {
        "GPT_IPP_IND_CAPIN2_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000714, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_gpt_ipp_ind_capin2_select_input
    },
    {
        "GPT_IPP_IND_CLKIN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000718, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_gpt_ipp_ind_clkin_select_input
    },
    {
        "I2C1_IPP_SCL_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000071c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c1_ipp_scl_in_select_input
    },
    {
        "I2C1_IPP_SDA_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000720, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c1_ipp_sda_in_select_input
    },
    {
        "I2C2_IPP_SCL_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000724, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c2_ipp_scl_in_select_input
    },
    {
        "I2C2_IPP_SDA_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000728, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c2_ipp_sda_in_select_input
    },
    {
        "I2C3_IPP_SCL_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000072c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c3_ipp_scl_in_select_input
    },
    {
        "I2C3_IPP_SDA_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000730, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c3_ipp_sda_in_select_input
    },
    {
        "KPP_IPP_IND_COL_0_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000734, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_0_select_input
    },
    {
        "KPP_IPP_IND_COL_1_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000738, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_1_select_input
    },
    {
        "KPP_IPP_IND_COL_2_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000073c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_2_select_input
    },
    {
        "KPP_IPP_IND_COL_3_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000740, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_3_select_input
    },
    {
        "KPP_IPP_IND_COL_4_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000744, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_4_select_input
    },
    {
        "KPP_IPP_IND_COL_5_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000748, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_5_select_input
    },
    {
        "KPP_IPP_IND_COL_6_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000074c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_6_select_input
    },
    {
        "KPP_IPP_IND_COL_7_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000750, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_col_7_select_input
    },
    {
        "KPP_IPP_IND_ROW_0_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000754, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_0_select_input
    },
    {
        "KPP_IPP_IND_ROW_1_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000758, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_1_select_input
    },
    {
        "KPP_IPP_IND_ROW_2_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000075c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_2_select_input
    },
    {
        "KPP_IPP_IND_ROW_3_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000760, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_3_select_input
    },
    {
        "KPP_IPP_IND_ROW_4_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000764, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_4_select_input
    },
    {
        "KPP_IPP_IND_ROW_5_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000768, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_5_select_input
    },
    {
        "KPP_IPP_IND_ROW_6_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000076c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_6_select_input
    },
    {
        "KPP_IPP_IND_ROW_7_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000770, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_ipp_ind_row_7_select_input
    },
    {
        "LCDIF_LCDIF_BUSY_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000774, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_busy_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_0_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000778, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_0_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_1_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000077c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_1_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_2_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000780, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_2_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_3_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000784, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_3_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_4_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000788, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_4_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_5_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000078c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_5_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_6_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000790, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_6_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_7_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000794, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_7_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_8_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000798, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_8_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_9_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000079c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_9_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_10_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_10_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_11_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_11_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_12_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_12_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_13_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_13_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_14_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_14_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_15_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_15_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_16_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_16_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_17_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_17_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_18_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_18_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_19_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_19_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_20_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_20_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_21_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_21_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_22_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_22_select_input
    },
    {
        "LCDIF_LCDIF_RXDATA_23_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcdif_lcdif_rxdata_23_select_input
    },
    {
        "SPDIF_SPDIF_IN1_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_spdif_spdif_in1_select_input
    },
    {
        "SPDIF_TX_CLK2_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_spdif_tx_clk2_select_input
    },
    {
        "UART1_IPP_UART_RTS_B_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart1_ipp_uart_rts_b_select_input
    },
    {
        "UART1_IPP_UART_RXD_MUX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x000007fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart1_ipp_uart_rxd_mux_select_input
    },
    {
        "UART2_IPP_UART_RTS_B_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart2_ipp_uart_rts_b_select_input
    },
    {
        "UART2_IPP_UART_RXD_MUX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart2_ipp_uart_rxd_mux_select_input
    },
    {
        "UART3_IPP_UART_RTS_B_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart3_ipp_uart_rts_b_select_input
    },
    {
        "UART3_IPP_UART_RXD_MUX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000080c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart3_ipp_uart_rxd_mux_select_input
    },
    {
        "UART4_IPP_UART_RTS_B_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart4_ipp_uart_rts_b_select_input
    },
    {
        "UART4_IPP_UART_RXD_MUX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000814, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart4_ipp_uart_rxd_mux_select_input
    },
    {
        "UART5_IPP_UART_RTS_B_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart5_ipp_uart_rts_b_select_input
    },
    {
        "UART5_IPP_UART_RXD_MUX_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart5_ipp_uart_rxd_mux_select_input
    },
    {
        "USB_IPP_IND_OTG2_OC_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usb_ipp_ind_otg2_oc_select_input
    },
    {
        "USB_IPP_IND_OTG_OC_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000824, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usb_ipp_ind_otg_oc_select_input
    },
    {
        "USDHC1_IPP_CARD_DET_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000828, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc1_ipp_card_det_select_input
    },
    {
        "USDHC1_IPP_WP_ON_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000082c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc1_ipp_wp_on_select_input
    },
    {
        "USDHC2_IPP_CARD_DET_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000830, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_ipp_card_det_select_input
    },
    {
        "USDHC2_IPP_WP_ON_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000834, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_ipp_wp_on_select_input
    },
    {
        "USDHC3_IPP_CARD_DET_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000838, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc3_ipp_card_det_select_input
    },
    {
        "USDHC3_IPP_DAT4_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000083c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc3_ipp_dat4_in_select_input
    },
    {
        "USDHC3_IPP_DAT5_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000840, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc3_ipp_dat5_in_select_input
    },
    {
        "USDHC3_IPP_DAT6_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000844, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc3_ipp_dat6_in_select_input
    },
    {
        "USDHC3_IPP_DAT7_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000848, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc3_ipp_dat7_in_select_input
    },
    {
        "USDHC3_IPP_WP_ON_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000084c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc3_ipp_wp_on_select_input
    },
    {
        "USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000850, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_card_clk_in_select_input
    },
    {
        "USDHC4_IPP_CARD_DET_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000854, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_card_det_select_input
    },
    {
        "USDHC4_IPP_CMD_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000858, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_cmd_in_select_input
    },
    {
        "USDHC4_IPP_DAT0_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000085c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_dat0_in_select_input
    },
    {
        "USDHC4_IPP_DAT1_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000860, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_dat1_in_select_input
    },
    {
        "USDHC4_IPP_DAT2_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000864, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_dat2_in_select_input
    },
    {
        "USDHC4_IPP_DAT3_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000868, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_dat3_in_select_input
    },
    {
        "USDHC4_IPP_DAT4_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000086c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_dat4_in_select_input
    },
    {
        "USDHC4_IPP_DAT5_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000870, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_dat5_in_select_input
    },
    {
        "USDHC4_IPP_DAT6_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000874, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_dat6_in_select_input
    },
    {
        "USDHC4_IPP_DAT7_IN_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000878, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_dat7_in_select_input
    },
    {
        "USDHC4_IPP_WP_ON_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x0000087c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc4_ipp_wp_on_select_input
    },
    {
        "EIM_IPP_IND_DTACK_B_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_eim_ipp_ind_dtack_b_select_input
    },
    {
        "EIM_IPP_IND_WAIT_B_SELECT_INPUT",
        DESC("")
        4, // Width in bytes
        0x00000884, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_eim_ipp_ind_wait_b_select_input
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark KPP
#endif

// Bitfields in register KPP_KPCR.
static const field_t hw_kpp_kpcr[] =
{
    {
        "KRE",
        DESC("Keypad Row Enable.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KCO",
        DESC("Keypad Column Strobe Open-Drain Enable.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register KPP_KPSR.
static const field_t hw_kpp_kpsr[] =
{
    {
        "KPKD",
        DESC("Keypad Key Depress.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KPKR",
        DESC("Keypad Key Release.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KDSC",
        DESC("Key Depress Synchronizer Clear.")
        2, // LSB
        2, // MSB
        false, // Readable
        true // Writable
    },
    {
        "KPP_KRSS",
        DESC("Key Release Synchronizer Set.")
        3, // LSB
        3, // MSB
        false, // Readable
        true // Writable
    },
    {
        "KDIE",
        DESC("Keypad Key Depress Interrupt Enable.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KRIE",
        DESC("Keypad Release Interrupt Enable.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register KPP_KDDR.
static const field_t hw_kpp_kddr[] =
{
    {
        "KRDD",
        DESC("Keypad Row Data Direction.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KCDD",
        DESC("Keypad Column Data Direction Register.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register KPP_KPDR.
static const field_t hw_kpp_kpdr[] =
{
    {
        "KRD",
        DESC("Keypad Row Data.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KCD",
        DESC("Keypad Column Data.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a KPP module.
static const reg_t hw_kpp[] =
{
    {
        "KPCR",
        DESC("The Keypad Control Register determines which of the eight possible col"
        "umn strobes are to be open drain when configured as outputs, and which"
        " of the eight row sense lines are considered in generating an interrup"
        "t to the core.")
        2, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_kpp_kpcr
    },
    {
        "KPSR",
        DESC("The Keypad Status Register reflects the state of the key press detect "
        "circuit.")
        2, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_kpp_kpsr
    },
    {
        "KDDR",
        DESC("The bits in the KPP_KDDR control the direction of the keypad port pins"
        ".")
        2, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_kpp_kddr
    },
    {
        "KPDR",
        DESC("This 16-bit register is used to access the column and row data.")
        2, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_kpp_kpdr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MMDC
#endif

// Bitfields in register MMDC_MDCTL.
static const field_t hw_mmdc_mdctl[] =
{
    {
        "DSIZ",
        DESC("DDR data bus size.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        DESC("Burst Length.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COL",
        DESC("Column Address Width.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROW",
        DESC("Row Address Width.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_1",
        DESC("MMDC Enable CS1.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_0",
        DESC("MMDC Enable CS0.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDPDC.
static const field_t hw_mmdc_mdpdc[] =
{
    {
        "TCKSRE",
        DESC("Valid clock cycles after self-refresh entry.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKSRX",
        DESC("Valid clock cycles before self-refresh exit.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOTH_CS_PD",
        DESC("Parallel power down entry to both chip selects.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOW_PD",
        DESC("Slow/fast power down.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWDT_0",
        DESC("Power Down Timer - Chip Select 0.")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWDT_1",
        DESC("Power Down Timer - Chip Select 1.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKE",
        DESC("CKE minimum pulse width.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRCT_0",
        DESC("Precharge Timer - Chip Select 0.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRCT_1",
        DESC("Precharge Timer - Chip Select 1.")
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDOTC.
static const field_t hw_mmdc_mdotc[] =
{
    {
        "TODT_IDLE_OFF",
        DESC("ODT turn off latency.")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TODTLON",
        DESC("ODT turn on latency.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAXPD",
        DESC("Asynchronous ODT to power down exit delay.")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TANPD",
        DESC("Asynchronous ODT to power down entry delay.")
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAONPD",
        DESC("Asynchronous RTT turn-on delay (power down with DLL frozen).")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAOFPD",
        DESC("Asynchronous RTT turn-off delay (power down with DLL frozen).")
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG0.
static const field_t hw_mmdc_mdcfg0[] =
{
    {
        "TCL",
        DESC("CAS Read Latency.")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFAW",
        DESC("Four Active Window (all banks).")
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPDLL",
        DESC("Exit precharge power down with DLL frozen to commands requiring DLL.")
        9, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXP",
        DESC("Exit power down with DLL-on to any valid command.")
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("Exit self refresh to non READ command.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRFC",
        DESC("Refresh command to Active or Refresh command time.")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG1.
static const field_t hw_mmdc_mdcfg1[] =
{
    {
        "TCWL",
        DESC("CAS Write Latency.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMRD",
        DESC("Mode Register Set command cycle (all banks).")
        5, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWR",
        DESC("WRITE recovery time (same bank).")
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRPA",
        DESC("Precharge-all command period.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRAS",
        DESC("Active to Precharge command period (same bank).")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRC",
        DESC("Active to Active or Refresh command period (same bank).")
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRP",
        DESC("Precharge command period (same bank).")
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRCD",
        DESC("Active command to internal read or write delay time (same bank).")
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG2.
static const field_t hw_mmdc_mdcfg2[] =
{
    {
        "TRRD",
        DESC("Active to Active command period (all banks).")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWTR",
        DESC("Internal WRITE to READ command delay (same bank).")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRTP",
        DESC("Internal READ command to Precharge command delay (same bank).")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDLLK",
        DESC("DLL locking time.")
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMISC.
static const field_t hw_mmdc_mdmisc[] =
{
    {
        "RST",
        DESC("Software Reset.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TYPE",
        DESC("DDR TYPE.")
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_4_BANK",
        DESC("Number of banks per DDR device.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RALAT",
        DESC("Read Additional Latency.")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIF3_MODE",
        DESC("Command prediction working mode.")
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPDDR2_S2",
        DESC("LPDDR2 S2 device type indication.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BI_ON",
        DESC("Bank Interleaving On.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WALAT",
        DESC("Write Additional latency.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LHD",
        DESC("Latency hiding disable.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_MIRROR",
        DESC("Address mirroring.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CALIB_PER_CS",
        DESC("Number of chip-select for calibration process.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CK1_GATING",
        DESC("Gating the secondary DDR clock.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_RDY",
        DESC("External status device on CS1.")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CS0_RDY",
        DESC("External status device on CS0.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDSCR.
static const field_t hw_mmdc_mdscr[] =
{
    {
        "CMD_BA",
        DESC("Bank Address.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_CS",
        DESC("Chip Select.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD",
        DESC("Command.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_EN",
        DESC("DQS pads direction.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRR_READ_DATA_VALID",
        DESC("MRR read data valid.")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CON_ACK",
        DESC("Configuration acknowledge.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CON_REQ",
        DESC("Configuration request.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_ADDR_LSB",
        DESC("Command/Address LSB.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_ADDR_MSB",
        DESC("Command/Address MSB.")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDREF.
static const field_t hw_mmdc_mdref[] =
{
    {
        "START_REF",
        DESC("Manual start of refresh cycle.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFR",
        DESC("Refresh Rate.")
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_SEL",
        DESC("Refresh Selector.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_CNT",
        DESC("Refresh Counter at DDR clock period  If REF_SEL equals '2' a refresh c"
        "ycle will begin every amount of DDR cycles configured in this field.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDRWD.
static const field_t hw_mmdc_mdrwd[] =
{
    {
        "RTR_DIFF",
        DESC("Read to read delay for different chip-select.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTW_DIFF",
        DESC("Read to write delay for different chip-select.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTW_DIFF",
        DESC("Write to write delay for different chip-select.")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTR_DIFF",
        DESC("Write to read delay for different chip-select.")
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTW_SAME",
        DESC("Read to write delay for the same chip-select.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDAI",
        DESC("Device auto initialization period.(maximum)  This field is relevant on"
        "ly to LPDDR2 mode")
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDOR.
static const field_t hw_mmdc_mdor[] =
{
    {
        "RST_TO_CKE",
        DESC("DDR3: Time from SDE enable to CKE rise.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_TO_RST",
        DESC("DDR3: Time from SDE enable until DDR reset# is high.")
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPR",
        DESC("DDR3: CKE HIGH to a valid command.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMRR.
static const field_t hw_mmdc_mdmrr[] =
{
    {
        "MRR_READ_DATA0",
        DESC("MRR DATA that arrived on DQ[7:0]")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA1",
        DESC("MRR DATA that arrived on DQ[15:8]")
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA2",
        DESC("MRR DATA that arrived on DQ[23:16]")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA3",
        DESC("MRR DATA that arrived on DQ[31:24]")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG3LP.
static const field_t hw_mmdc_mdcfg3lp[] =
{
    {
        "TRPAB_LP",
        DESC("Precharge (all banks) command period.")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRPPB_LP",
        DESC("Precharge (per bank) command period (same bank).")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRCD_LP",
        DESC("Active command to internal read or write delay time (same bank).")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_LP",
        DESC("Active to Active or Refresh command period (same bank).")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMR4.
static const field_t hw_mmdc_mdmr4[] =
{
    {
        "UPDATE_DE_REQ",
        DESC("Update Derated Values Request.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DE_ACK",
        DESC("Update Derated Values Acknowledge.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRCD_DE",
        DESC("tRCD derating value.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRC_DE",
        DESC("tRC derating value.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRAS_DE",
        DESC("tRAS derating value.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRP_DE",
        DESC("tRP derating value.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRRD_DE",
        DESC("tRRD derating value.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDASP.
static const field_t hw_mmdc_mdasp[] =
{
    {
        "CS0_END",
        DESC("CS0_END.")
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAARCR.
static const field_t hw_mmdc_maarcr[] =
{
    {
        "ARCR_GUARD",
        DESC("ARCR Guard.")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_DYN_MAX",
        DESC("ARCR Dynamic Maximum.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_DYN_JMP",
        DESC("ARCR Dynamic Jump.")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_ACC_HIT",
        DESC("ARCR Access Hit Rate.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_PAG_HIT",
        DESC("ARCR Page Hit Rate.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_RCH_EN",
        DESC("This bit defines whether Real time channel is activated and bypassed a"
        "ll other pending accesses, So accesses with QoS=='F' will be granted t"
        "he highest prioritiy in the optimization/reordering mechanism  Default"
        " value is 0x1 - encoding 1 (Enabled)")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_EXC_ERR_EN",
        DESC("This bit defines whether exclusive read/write access violation of AXI "
        "6.2.4 rule result in SLV Error response or in OKAY response  Default v"
        "alue is 0x1 - encoding 1(response is SLV Error)")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_SEC_ERR_EN",
        DESC("This bit defines whether security read/write access violation result i"
        "n SLV Error response or in OKAY response  Default value is 0x1 - encod"
        "ing 1(response is SLV Error, rresp/bresp=2'b10)")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_SEC_ERR_LOCK",
        DESC("Once set, this bit locks ARCR_SEC_ERR_EN and prevents from its updatin"
        "g.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAPSR.
static const field_t hw_mmdc_mapsr[] =
{
    {
        "PSD",
        DESC("Automatic Power Saving Disable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSS",
        DESC("Power Saving Status.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RIS",
        DESC("Read Idle Status.This read only bit indicates whether read request buf"
        "fer is idle (empty) or not.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WIS",
        DESC("Write Idle Status.This read only bit indicates whether write request b"
        "uffer is idle (empty) or not.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        DESC("Automatic Power saving timer.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPMD",
        DESC("General LPMD request.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFS",
        DESC("General DVFS request.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPACK",
        DESC("General low-power acknowledge.")
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DVACK",
        DESC("General DVFS acknowledge.")
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAEXIDR0.
static const field_t hw_mmdc_maexidr0[] =
{
    {
        "EXC_ID_MONITOR0",
        DESC("This feild defines ID for Exclusive monitor#0.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_ID_MONITOR1",
        DESC("This feild defines ID for Exclusive monitor#1.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAEXIDR1.
static const field_t hw_mmdc_maexidr1[] =
{
    {
        "EXC_ID_MONITOR2",
        DESC("This feild defines ID for Exclusive monitor#2.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_ID_MONITOR3",
        DESC("This feild defines ID for Exclusive monitor#3.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPCR0.
static const field_t hw_mmdc_madpcr0[] =
{
    {
        "DBG_EN",
        DESC("Debug and Profiling Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_RST",
        DESC("Debug and Profiling Reset.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRF_FRZ",
        DESC("Profiling freeze.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CYC_OVF",
        DESC("Total Profiling Cycles Count Overflow.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBS_EN",
        DESC("Step By Step debug Enable.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBS",
        DESC("Step By Step trigger.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPCR1.
static const field_t hw_mmdc_madpcr1[] =
{
    {
        "PRF_AXI_ID",
        DESC("Profiling AXI ID.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRF_AXI_ID_MASK",
        DESC("Profiling AXI ID Mask.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR0.
static const field_t hw_mmdc_madpsr0[] =
{
    {
        "CYC_COUNT",
        DESC("Total Profiling cycle Count.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR1.
static const field_t hw_mmdc_madpsr1[] =
{
    {
        "BUSY_COUNT",
        DESC("Profiling Busy Cycles Count.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR2.
static const field_t hw_mmdc_madpsr2[] =
{
    {
        "RD_ACC_COUNT",
        DESC("Profiling Read Access Count.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR3.
static const field_t hw_mmdc_madpsr3[] =
{
    {
        "WR_ACC_COUNT",
        DESC("Profiling Write Access Count.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR4.
static const field_t hw_mmdc_madpsr4[] =
{
    {
        "RD_BYTES_COUNT",
        DESC("Profiling Read Bytes Count.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR5.
static const field_t hw_mmdc_madpsr5[] =
{
    {
        "WR_BYTES_COUNT",
        DESC("Profiling Write Bytes Count.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MASBS0.
static const field_t hw_mmdc_masbs0[] =
{
    {
        "SBS_ADDR",
        DESC("Step By Step Address.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MASBS1.
static const field_t hw_mmdc_masbs1[] =
{
    {
        "SBS_VLD",
        DESC("Step By Step Valid.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_TYPE",
        DESC("Step By Step Request Type.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_LOCK",
        DESC("Step By Step Lock.")
        2, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_PROT",
        DESC("Step By Step Protection.")
        4, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_SIZE",
        DESC("Step By Step Size.")
        7, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_BURST",
        DESC("Step By Step Burst.")
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_BUFF",
        DESC("Step By Step Buffered.")
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_LEN",
        DESC("Step By Step Length.")
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_AXI_ID",
        DESC("Step By Step AXI ID.")
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAGENP.
static const field_t hw_mmdc_magenp[] =
{
    {
        "GP31_GP0",
        DESC("General purpose read/write bits.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQHWCTRL.
static const field_t hw_mmdc_mpzqhwctrl[] =
{
    {
        "ZQ_MODE",
        DESC("ZQ calibration mode:")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_HW_PER",
        DESC("ZQ periodic calibration time.")
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_HW_PU_RES",
        DESC("ZQ automatic calibration pull-up result.")
        6, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_HW_PD_RES",
        DESC("ZQ HW calibration pull-down result.")
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_HW_FOR",
        DESC("Force ZQ automatic calibration process with the i.MX ZQ calibration pa"
        "d.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_INIT",
        DESC("Device ZQ long/init time.")
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_OPER",
        DESC("Device ZQ long/oper time.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_CS",
        DESC("Device ZQ short time.")
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_EARLY_COMPARATOR_EN_TIMER",
        DESC("ZQ early comparator enable timer.")
        27, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQSWCTRL.
static const field_t hw_mmdc_mpzqswctrl[] =
{
    {
        "ZQ_SW_FOR",
        DESC("ZQ SW calibration enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_RES",
        DESC("ZQ software calibration result.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_SW_PU_VAL",
        DESC("ZQ software pull-up resistence.This field determines the value of the "
        "PU resistor during SW ZQ calibration.")
        2, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_PD_VAL",
        DESC("ZQ software pull-down resistence.This field determines the value of th"
        "e PD resistor during SW ZQ calibration.")
        7, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_PD",
        DESC("ZQ software PU/PD calibration.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USE_ZQ_SW_VAL",
        DESC("Use SW ZQ configured value for I/O pads resistor controls.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_CMP_OUT_SMP",
        DESC("Defines the amount of cycles between driving the ZQ signals to the ZQ "
        "pad and till sampling the comparator enable output while performing ZQ"
        " calibration process with the i.MX ZQ calibration pad")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLGCR.
static const field_t hw_mmdc_mpwlgcr[] =
{
    {
        "HW_WL_EN",
        DESC("Write-Leveling HW (automatic) enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_WL_EN",
        DESC("Write-Leveling SW enable.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_WL_CNT_EN",
        DESC("SW write-leveling count down enable.This bit when asserted set a certa"
        "in delay of (25+15) cycles from the setting of SW_WL_EN and before dri"
        "ving the DQS to the DDR device.This bit should be asserted before the "
        "first SW write-leveling request and after issuing the write leveling M"
        "RS command")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_SW_RES0",
        DESC("Byte0 write-leveling software result.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_SW_RES1",
        DESC("Byte1 write-leveling software result.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_SW_RES2",
        DESC("Byte2 write-leveling software result.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_SW_RES3",
        DESC("Byte3 write-leveling software result.")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR0",
        DESC("Byte0 write-leveling HW calibration error.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR1",
        DESC("Byte1 write-leveling HW calibration error.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR2",
        DESC("Byte2 write-leveling HW calibration error.")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR3",
        DESC("Byte3 write-leveling HW calibration error.")
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLDECTRL0.
static const field_t hw_mmdc_mpwldectrl0[] =
{
    {
        "WL_DL_ABS_OFFSET0",
        DESC("Absolute write-leveling delay offset for Byte 0.")
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL0",
        DESC("Write leveling half cycle delay for Byte 0.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL0",
        DESC("Write leveling cycle delay for Byte 0.")
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_DL_ABS_OFFSET1",
        DESC("Absolute write-leveling delay offset for Byte 1.")
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL1",
        DESC("Write leveling half cycle delay for Byte 1.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL1",
        DESC("Write leveling cycle delay for Byte 1.")
        25, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLDECTRL1.
static const field_t hw_mmdc_mpwldectrl1[] =
{
    {
        "WL_DL_ABS_OFFSET2",
        DESC("Absolute write-leveling delay offset for Byte 2.")
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL2",
        DESC("Write leveling half cycle delay for Byte 2.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL2",
        DESC("Write leveling cycle delay for Byte 2.")
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_DL_ABS_OFFSET3",
        DESC("Absolute write-leveling delay offset for Byte 3.")
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL3",
        DESC("Write leveling half cycle delay for Byte 3.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL3",
        DESC("Write leveling cycle delay for Byte 3.")
        25, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLDLST.
static const field_t hw_mmdc_mpwldlst[] =
{
    {
        "WL_DL_UNIT_NUM0",
        DESC("This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 0.")
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_DL_UNIT_NUM1",
        DESC("This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 1.")
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_DL_UNIT_NUM2",
        DESC("This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 2.")
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_DL_UNIT_NUM3",
        DESC("This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 3.")
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPODTCTRL.
static const field_t hw_mmdc_mpodtctrl[] =
{
    {
        "ODT_WR_PAS_EN",
        DESC("Inactive write CS ODT enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT_WR_ACT_EN",
        DESC("Active write CS ODT enable.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT_RD_PAS_EN",
        DESC("Inactive read CS ODT enable.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT_RD_ACT_EN",
        DESC("Active read CS ODT enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT0_INT_RES",
        DESC("On chip ODT byte0 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte0 resistor during read accesses.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT1_INT_RES",
        DESC("On chip ODT byte1 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte1 resistor during read accesses.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT2_INT_RES",
        DESC("On chip ODT byte2 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte2 resistor during read accesses.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT3_INT_RES",
        DESC("On chip ODT byte3 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte3 resistor during read accesses.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY0DL.
static const field_t hw_mmdc_mprddqby0dl[] =
{
    {
        "RD_DQ0_DEL",
        DESC("Read dqs0 to dq0 delay fine-tuning.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ1_DEL",
        DESC("Read dqs0 to dq1 delay fine-tuning.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ2_DEL",
        DESC("Read dqs0 to dq2 delay fine-tuning.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ3_DEL",
        DESC("Read dqs0 to dq3 delay fine-tuning.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ4_DEL",
        DESC("Read dqs0 to dq4 delay fine-tuning.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ5_DEL",
        DESC("Read dqs0 to dq5 delay fine-tuning.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ6_DEL",
        DESC("Read dqs0 to dq6 delay fine-tuning.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ7_DEL",
        DESC("Read dqs0 to dq7 delay fine-tuning.")
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY1DL.
static const field_t hw_mmdc_mprddqby1dl[] =
{
    {
        "RD_DQ8_DEL",
        DESC("Read dqs1 to dq8 delay fine-tuning.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ9_DEL",
        DESC("Read dqs1 to dq9 delay fine-tuning.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ10_DEL",
        DESC("Read dqs1 to dq10 delay fine-tuning.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ11_DEL",
        DESC("Read dqs1 to dq11 delay fine-tuning.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ12_DEL",
        DESC("Read dqs1 to dq12 delay fine-tuning.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ13_DEL",
        DESC("Read dqs1 to dq13 delay fine-tuning.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ14_DEL",
        DESC("Read dqs1 to dq14 delay fine-tuning.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ15_DEL",
        DESC("Read dqs1 to dq15 delay fine-tuning.")
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY2DL.
static const field_t hw_mmdc_mprddqby2dl[] =
{
    {
        "RD_DQ16_DEL",
        DESC("Read dqs2 to dq16 delay fine-tuning.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ17_DEL",
        DESC("Read dqs2 to dq17 delay fine-tuning.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ18_DEL",
        DESC("Read dqs2 to dq18 delay fine-tuning.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ19_DEL",
        DESC("Read dqs2 to dq19 delay fine-tuning.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ20_DEL",
        DESC("Read dqs2 to dq20 delay fine-tuning.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ21_DEL",
        DESC("Read dqs2 to dq21 delay fine-tuning.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ22_DEL",
        DESC("Read dqs2 to dq22 delay fine-tuning.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ23_DEL",
        DESC("Read dqs2 to dq23 delay fine-tuning.")
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY3DL.
static const field_t hw_mmdc_mprddqby3dl[] =
{
    {
        "RD_DQ24_DEL",
        DESC("Read dqs3 to dq24 delay fine-tuning.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ25_DEL",
        DESC("Read dqs3 to dq25 delay fine-tuning.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ26_DEL",
        DESC("Read dqs3 to dq26 delay fine-tuning.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ27_DEL",
        DESC("Read dqs3 to dq27 delay fine-tuning.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ28_DEL",
        DESC("Read dqs3 to dq28 delay fine-tuning.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ29_DEL",
        DESC("Read dqs3 to dq29 delay fine-tuning.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ30_DEL",
        DESC("Read dqs3 to dq30 delay fine-tuning.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ31_DEL",
        DESC("Read dqs3 to dq31 delay fine-tuning.")
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY0DL.
static const field_t hw_mmdc_mpwrdqby0dl[] =
{
    {
        "WR_DQ0_DEL",
        DESC("Write dq0 delay fine-tuning.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ1_DEL",
        DESC("Write dq1 delay fine-tuning.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ2_DEL",
        DESC("Write dq2 delay fine-tuning.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ3_DEL",
        DESC("Write dq3 delay fine-tuning.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ4_DEL",
        DESC("Write dq4 delay fine-tuning.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ5_DEL",
        DESC("Write dq5 delay fine-tuning.")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ6_DEL",
        DESC("Write dq6 delay fine-tuning.")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ7_DEL",
        DESC("Write dq7 delay fine-tuning.")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM0_DEL",
        DESC("Write dm0 delay fine-tuning.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY1DL.
static const field_t hw_mmdc_mpwrdqby1dl[] =
{
    {
        "WR_DQ8_DEL",
        DESC("Write dq8 delay fine-tuning.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ9_DEL",
        DESC("Write dq9 delay fine-tuning.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ10_DEL",
        DESC("Write dq10 delay fine-tuning.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ11_DEL",
        DESC("Write dq11 delay fine-tuning.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ12_DEL",
        DESC("Write dq12 delay fine-tuning.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ13_DEL",
        DESC("Write dq13 delay fine-tuning.")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ14_DEL",
        DESC("Write dq14 delay fine-tuning.")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ15_DEL",
        DESC("Write dq15 delay fine-tuning.")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM1_DEL",
        DESC("Write dm1 delay fine-tuning.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY2DL.
static const field_t hw_mmdc_mpwrdqby2dl[] =
{
    {
        "WR_DQ16_DEL",
        DESC("Write dq16 delay fine tuning.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ17_DEL",
        DESC("Write dq17 delay fine tuning.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ18_DEL",
        DESC("Write dq18 delay fine tuning.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ19_DEL",
        DESC("Write dq19 delay fine tuning.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ20_DEL",
        DESC("Write dq20 delay fine tuning.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ21_DEL",
        DESC("Write dq21 delay fine tuning.")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ22_DEL",
        DESC("Write dq22 delay fine tuning.")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ23_DEL",
        DESC("Write dq23 delay fine tuning.")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM2_DEL",
        DESC("Write dm2 delay fine-tuning.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY3DL.
static const field_t hw_mmdc_mpwrdqby3dl[] =
{
    {
        "WR_DQ24_DEL",
        DESC("Write dq24 delay fine tuning.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ25_DEL",
        DESC("Write dq25 delay fine tuning.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ26_DEL",
        DESC("Write dq26 delay fine tuning.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ27_DEL",
        DESC("Write dq27 delay fine tuning.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ28_DEL",
        DESC("Write dq28 delay fine tuning.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ29_DEL",
        DESC("Write dq29 delay fine tuning.")
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ30_DEL",
        DESC("Write dq30 delay fine tuning.")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ31_DEL",
        DESC("Write dq31 delay fine tuning.")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM3_DEL",
        DESC("Write dm3 delay fine tuning.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGCTRL0.
static const field_t hw_mmdc_mpdgctrl0[] =
{
    {
        "DG_DL_ABS_OFFSET0",
        DESC("Absolute read DQS gating delay offset for Byte0.")
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL0",
        DESC("Read DQS gating half cycles delay for Byte0  .")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_DG_ERR",
        DESC("HW DQS gating error.")
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_ABS_OFFSET1",
        DESC("Absolute read DQS gating delay offset for Byte1.")
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_EXT_UP",
        DESC("DG extend upper boundary.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL1",
        DESC("Read DQS gating half cycles delay for Byte1 .")
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_DG_EN",
        DESC("Enable automatic read DQS gating calibration.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_DIS",
        DESC("Read DQS gating disable.")
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_CMP_CYC",
        DESC("Read DQS gating sample cycle.")
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RST_RD_FIFO",
        DESC("Reset Read Data FIFO and associated pointers.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGCTRL1.
static const field_t hw_mmdc_mpdgctrl1[] =
{
    {
        "DG_DL_ABS_OFFSET2",
        DESC("Absolute read DQS gating delay offset for Byte2.")
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL2",
        DESC("Read DQS gating half cycles delay for Byte2 .")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_DL_ABS_OFFSET3",
        DESC("Absolute read DQS gating delay offset for Byte3.")
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL3",
        DESC("Read DQS gating half cycles delay for Byte3 .")
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGDLST0.
static const field_t hw_mmdc_mpdgdlst0[] =
{
    {
        "DG_DL_UNIT_NUM0",
        DESC("This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 0.")
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM1",
        DESC("This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 1.")
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM2",
        DESC("This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 2.")
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM3",
        DESC("This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 3.")
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLCTL.
static const field_t hw_mmdc_mprddlctl[] =
{
    {
        "RD_DL_ABS_OFFSET0",
        DESC("Absolute read delay offset for Byte0.")
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET1",
        DESC("Absolute read delay offset for Byte1.")
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET2",
        DESC("Absolute read delay offset for Byte2.")
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET3",
        DESC("Absolute read delay offset for Byte3.")
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLST.
static const field_t hw_mmdc_mprddlst[] =
{
    {
        "RD_DL_UNIT_NUM0",
        DESC("This field reflects the number of delay units that are actually used b"
        "y read delay-line 0.")
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM1",
        DESC("This field reflects the number of delay units that are actually used b"
        "y read delay-line 1.")
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM2",
        DESC("This field reflects the number of delay units that are actually used b"
        "y read delay-line 2.")
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM3",
        DESC("This field reflects the number of delay units that are actually used b"
        "y read delay-line 3.")
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLCTL.
static const field_t hw_mmdc_mpwrdlctl[] =
{
    {
        "WR_DL_ABS_OFFSET0",
        DESC("Absolute write delay offset for Byte0.")
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET1",
        DESC("Absolute write delay offset for Byte1.")
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET2",
        DESC("Absolute write delay offset for Byte2.")
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET3",
        DESC("Absolute write delay offset for Byte3.")
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLST.
static const field_t hw_mmdc_mpwrdlst[] =
{
    {
        "WR_DL_UNIT_NUM0",
        DESC("This field reflects the number of delay units that are actually used b"
        "y write delay-line 0.")
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM1",
        DESC("This field reflects the number of delay units that are actually used b"
        "y write delay-line 1.")
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM2",
        DESC("This field reflects the number of delay units that are actually used b"
        "y write delay-line 2.")
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM3",
        DESC("This field reflects the number of delay units that are actually used b"
        "y write delay-line 3.")
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSDCTRL.
static const field_t hw_mmdc_mpsdctrl[] =
{
    {
        "SDCLK0_DEL",
        DESC("DDR clock0 delay fine tuning.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDCLK1_DEL",
        DESC("DDR clock1 delay fine tuning.")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQLP2CTL.
static const field_t hw_mmdc_mpzqlp2ctl[] =
{
    {
        "ZQ_LP2_HW_ZQINIT",
        DESC("This register defines the period in cycles that it takes the memory de"
        "vice to perform a Init ZQ calibration.")
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_LP2_HW_ZQCL",
        DESC("This register defines the period in cycles that it takes the memory de"
        "vice to perform a long ZQ calibration.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_LP2_HW_ZQCS",
        DESC("This register defines the period in cycles that it takes the memory de"
        "vice to perform a Short ZQ calibration.")
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWCTL.
static const field_t hw_mmdc_mprddlhwctl[] =
{
    {
        "HW_RD_DL_ERR0",
        DESC("Automatic (HW) read calibration error of Byte0.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR1",
        DESC("Automatic (HW) read calibration error of Byte1.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR2",
        DESC("Automatic (HW) read calibration error of Byte2.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR3",
        DESC("Automatic (HW) read calibration error of Byte3.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_EN",
        DESC("Enable automatic (HW) read calibration.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_RD_DL_CMP_CYC",
        DESC("Automatic (HW) read sample cycle.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWCTL.
static const field_t hw_mmdc_mpwrdlhwctl[] =
{
    {
        "HW_WR_DL_ERR0",
        DESC("Automatic (HW) write calibration error of Byte0.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR1",
        DESC("Automatic (HW) write calibration error of Byte1.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR2",
        DESC("Automatic (HW) write calibration error of Byte2.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR3",
        DESC("Automatic (HW) write calibration error of Byte3.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_EN",
        DESC("Enable automatic (HW) write calibration.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_WR_DL_CMP_CYC",
        DESC("Write sample cycle.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWST0.
static const field_t hw_mmdc_mprddlhwst0[] =
{
    {
        "HW_RD_DL_LOW0",
        DESC("Automatic (HW) read calibration result of the lower boundary of Byte0.")
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP0",
        DESC("Automatic (HW) read calibration result of the upper boundary of Byte0.")
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_LOW1",
        DESC("Automatic (HW) read calibration result of the lower boundary of Byte1.")
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP1",
        DESC("Automatic (HW) read calibration result of the upper boundary of Byte1.")
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWST1.
static const field_t hw_mmdc_mprddlhwst1[] =
{
    {
        "HW_RD_DL_LOW2",
        DESC("Automatic (HW) read calibration result of the lower boundary of Byte2.")
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP2",
        DESC("Automatic (HW) read calibration result of the upper boundary of Byte2.")
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_LOW3",
        DESC("Automatic (HW) read calibration result of the lower boundary of Byte3.")
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP3",
        DESC("Automatic (HW) read calibration result of the upper boundary of Byte3.")
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWST0.
static const field_t hw_mmdc_mpwrdlhwst0[] =
{
    {
        "HW_WR_DL_LOW0",
        DESC("Automatic (HW) write calibration result of the lower boundary of Byte0"
        ".")
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP0",
        DESC("Automatic (HW) write calibration result of the upper boundary of Byte0"
        ".")
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_LOW1",
        DESC("Automatic (HW) write calibration result of the lower boundary of Byte1"
        ".")
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP1",
        DESC("Aautomatic (HW) write utomatic (HW) write calibration result of the up"
        "per boundary of Byte1.")
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWST1.
static const field_t hw_mmdc_mpwrdlhwst1[] =
{
    {
        "HW_WR_DL_LOW2",
        DESC("Automatic (HW) write calibration result of the lower boundary of Byte2"
        ".")
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP2",
        DESC("Automatic (HW) write calibration result of the upper boundary of Byte2"
        ".")
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_LOW3",
        DESC("Automatic (HW) write calibration result of the lower boundary of Byte3"
        ".")
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP3",
        DESC("Automatic (HW) write calibration result of the upper boundary of Byte3"
        ".")
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLHWERR.
static const field_t hw_mmdc_mpwlhwerr[] =
{
    {
        "HW_WL0_DQ",
        DESC("HW write-leveling calibration result of Byte0.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WL1_DQ",
        DESC("HW write-leveling calibration result of Byte1.")
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WL2_DQ",
        DESC("HW write-leveling calibration result of Byte2.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WL3_DQ",
        DESC("HW write-leveling calibration result of Byte3.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST0.
static const field_t hw_mmdc_mpdghwst0[] =
{
    {
        "HW_DG_LOW0",
        DESC("HW DQS gating calibration result of the lower boundary of Byte0.")
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP0",
        DESC("HW DQS gating calibration result of the upper boundary of Byte0.")
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST1.
static const field_t hw_mmdc_mpdghwst1[] =
{
    {
        "HW_DG_LOW1",
        DESC("HW DQS gating calibration result of the lower boundary of Byte1.")
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP1",
        DESC("HW DQS gating calibration result of the upper boundary of Byte1.")
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST2.
static const field_t hw_mmdc_mpdghwst2[] =
{
    {
        "HW_DG_LOW2",
        DESC("HW DQS gating calibration result of the lower boundary of Byte2.")
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP2",
        DESC("HW DQS gating calibration result of the upper boundary of Byte2.")
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST3.
static const field_t hw_mmdc_mpdghwst3[] =
{
    {
        "HW_DG_LOW3",
        DESC("HW DQS gating calibration result of the lower boundary of Byte3.")
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP3",
        DESC("HW DQS gating calibration result of the upper boundary of Byte3.")
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPPDCMPR1.
static const field_t hw_mmdc_mppdcmpr1[] =
{
    {
        "PDV1",
        DESC("MMDC Pre defined comapre value2.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDV2",
        DESC("MMDC Pre defined comapre value2.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPPDCMPR2.
static const field_t hw_mmdc_mppdcmpr2[] =
{
    {
        "MPR_CMP",
        DESC("MPR(DDR3)/DQ calibration (LPDDR2) comapre enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPR_FULL_CMP",
        DESC("MPR(DDR3)/DQ calibration (LPDDR2) full compare enable.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_LEVEL_PATTERN",
        DESC("MPR(DDR3)/DQ calibration(LPDDR2) read compare pattern.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CA_DL_ABS_OFFSET",
        DESC("Absolute CA (Command/Address of LPDDRR2) offset.")
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_CA_DL_UNIT",
        DESC("This field reflects the number of delay units that are actually used b"
        "y CA (Command/Address of LPDDR2) delay-line")
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDAR0.
static const field_t hw_mmdc_mpswdar0[] =
{
    {
        "SW_DUMMY_WR",
        DESC("SW dummy write.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_DUMMY_RD",
        DESC("SW dummy read.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_DUM_CMP0",
        DESC("SW dummy read byte0 compare results.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP1",
        DESC("SW dummy read byte1 compare results.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP2",
        DESC("SW dummy read byte2 compare results.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP3",
        DESC("SW dummy read byte3 compare results.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR0.
static const field_t hw_mmdc_mpswdrdr0[] =
{
    {
        "DUM_RD0",
        DESC("Dummy read data0.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR1.
static const field_t hw_mmdc_mpswdrdr1[] =
{
    {
        "DUM_RD1",
        DESC("Dummy read data1.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR2.
static const field_t hw_mmdc_mpswdrdr2[] =
{
    {
        "DUM_RD2",
        DESC("Dummy read data2.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR3.
static const field_t hw_mmdc_mpswdrdr3[] =
{
    {
        "DUM_RD3",
        DESC("Dummy read data3.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR4.
static const field_t hw_mmdc_mpswdrdr4[] =
{
    {
        "DUM_RD4",
        DESC("Dummy read data4.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR5.
static const field_t hw_mmdc_mpswdrdr5[] =
{
    {
        "DUM_RD5",
        DESC("Dummy read data5.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR6.
static const field_t hw_mmdc_mpswdrdr6[] =
{
    {
        "DUM_RD6",
        DESC("Dummy read data6.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR7.
static const field_t hw_mmdc_mpswdrdr7[] =
{
    {
        "DUM_RD7",
        DESC("Dummy read data7.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPMUR0.
static const field_t hw_mmdc_mpmur0[] =
{
    {
        "MU_BYP_VAL",
        DESC("Number of delay units for measurement bypass.")
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MU_BYP_EN",
        DESC("Measure unit bypass enable.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRC_MSR",
        DESC("Force measuement on delay-lines.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MU_UNIT_DEL_NUM",
        DESC("Number of delay units measured per cycle.")
        16, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRCADL.
static const field_t hw_mmdc_mpwrcadl[] =
{
    {
        "WR_CA0_DEL",
        DESC("CA (Command/Address LPDDR2 bus) bit 0 delay fine tuning.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA1_DEL",
        DESC("CA (Command/Address LPDDR2 bus) bit 1 delay fine tuning.")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA2_DEL",
        DESC("CA (Command/Address LPDDR2 bus) bit 2 delay fine tuning.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA3_DEL",
        DESC("CA (Command/Address LPDDR2 bus) bit 3 delay fine tuning.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA4_DEL",
        DESC("CA (Command/Address LPDDR2 bus) bit 4 delay fine tuning.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA5_DEL",
        DESC("CA (Command/Address LPDDR2 bus) bit 5 delay fine tuning.")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA6_DEL",
        DESC("CA (Command/Address LPDDR2 bus) bit 6 delay fine tuning.")
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA7_DEL",
        DESC("CA (Command/Address LPDDR2 bus) bit 7 delay fine tuning.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA8_DEL",
        DESC("CA (Command/Address LPDDR2 bus) bit 8 delay fine tuning.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA9_DEL",
        DESC("CA (Command/Address LPDDR2 bus) bit 9 delay fine tuning.")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDCCR.
static const field_t hw_mmdc_mpdccr[] =
{
    {
        "WR_DQS0_FT_DCC",
        DESC("Write DQS duty cycle fine tuning control of Byte0.")
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DQS1_FT_DCC",
        DESC("Write DQS duty cycle fine tuning control of Byte1.")
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DQS2_FT_DCC",
        DESC("Write DQS duty cycle fine tuning control of Byte1.")
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DQS3_FT_DCC",
        DESC("Write DQS duty cycle fine tuning control of Byte0.")
        9, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CK_FT0_DCC",
        DESC("Primary duty cycle fine tuning control of DDR clock.")
        12, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CK_FT1_DCC",
        DESC("Secondary duty cycle fine tuning control of DDR clock.")
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DQS0_FT_DCC",
        DESC("Read DQS duty cycle fine tuning control of Byte0.")
        19, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DQS1_FT_DCC",
        DESC("Read DQS duty cycle fine tuning control of Byte1.")
        22, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DQS2_FT_DCC",
        DESC("Read DQS duty cycle fine tuning control of Byte2.")
        25, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DQS3_FT_DCC",
        DESC("Read DQS duty cycle fine tuning control of Byte3.")
        28, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a MMDC module.
static const reg_t hw_mmdc[] =
{
    {
        "MDCTL",
        DESC("")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdctl
    },
    {
        "MDPDC",
        DESC("PRCT field encoding        PRCT[2:0]    Precharge Timer        000    "
        "Disabled (Bit field reset value)      001    2 clocks      010    4 cl"
        "ocks      011    8 clocks      100    16 clocks      101    32 clocks "
        "     110    64 clocks      111    128 clocks         PWDT field encodi"
        "ng        PWDT[3:0]    Power Down Time-out        0000    Disabled (bi"
        "t field reset value)      0001    16 cycles      0010    32 cycles    "
        "  0011    64 cycles      0100    128 cycles      0101    256 cycles   "
        "   0110    512 cycles      0111    1024 cycles      1000    2048 cycle"
        "s      1001    4096 cycles      1010    8196 cycles      1011    16384"
        " cycles      1100    32768 cycles      1101-1111    Reserved")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mdpdc
    },
    {
        "MDOTC",
        DESC("For further information see .")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdotc
    },
    {
        "MDCFG0",
        DESC("")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdcfg0
    },
    {
        "MDCFG1",
        DESC("")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mdcfg1
    },
    {
        "MDCFG2",
        DESC("")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdcfg2
    },
    {
        "MDMISC",
        DESC("")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_mmdc_mdmisc
    },
    {
        "MDSCR",
        DESC("This register is used to issue special commands manually toward the ex"
        "ternal DDR device (such as load mode register, manual self refresh, ma"
        "nual precharge and so on).")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mdscr
    },
    {
        "MDREF",
        DESC("This register determines the refresh scheme that will be executed towa"
        "rd the DDR device.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdref
    },
    {
        "MDRWD",
        DESC("This register determines the delay between back to back read and write"
        " accesses.")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdrwd
    },
    {
        "MDOR",
        DESC("This register defines delays that must be kept when MMDC exits reset.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mmdc_mdor
    },
    {
        "MDMRR",
        DESC("This register contains data that was collected after issuing MRR comma"
        "nd.")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mdmrr
    },
    {
        "MDCFG3LP",
        DESC("This register is relevant only for LPDDR2 mode.")
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdcfg3lp
    },
    {
        "MDMR4",
        DESC("This register is relevant only for LPDDR2 mode.")
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mmdc_mdmr4
    },
    {
        "MDASP",
        DESC("This register defines the partitioning between chip select 0 and chip "
        "select 1.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmdc_mdasp
    },
    {
        "MAARCR",
        DESC("This register determines the values of the weights used for the re-ord"
        "ering arbitration engine.")
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_maarcr
    },
    {
        "MAPSR",
        DESC("The MAPSR determines the power saving features of MMDC.")
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mapsr
    },
    {
        "MAEXIDR0",
        DESC("This register defines the ID to be monitored for exclusive accesses of"
        " monitor0 and monitor1.")
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_maexidr0
    },
    {
        "MAEXIDR1",
        DESC("This register defines the ID to be monitored for exclusive accesses of"
        " monitor2 and monitor3.")
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_maexidr1
    },
    {
        "MADPCR0",
        DESC("")
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_madpcr0
    },
    {
        "MADPCR1",
        DESC("")
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_madpcr1
    },
    {
        "MADPSR0",
        DESC("")
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr0
    },
    {
        "MADPSR1",
        DESC("The register reflects the total cycles during which the MMDC state mac"
        "hines were busy (both writes and reads).")
        4, // Width in bytes
        0x0000041c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr1
    },
    {
        "MADPSR2",
        DESC("This register reflects the total number of read accesses (per AXI ID) "
        "toward MMDC.")
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr2
    },
    {
        "MADPSR3",
        DESC("This register reflects the total number of write accesses (per AXI ID)"
        " toward MMDC.")
        4, // Width in bytes
        0x00000424, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr3
    },
    {
        "MADPSR4",
        DESC("This register reflects the total number of bytes that were transferred"
        " during read access (per AXI ID) toward MMDC.")
        4, // Width in bytes
        0x00000428, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr4
    },
    {
        "MADPSR5",
        DESC("This register reflects the total number of bytes that were transferred"
        " during write access (per AXI ID) toward MMDC.")
        4, // Width in bytes
        0x0000042c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr5
    },
    {
        "MASBS0",
        DESC("")
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_masbs0
    },
    {
        "MASBS1",
        DESC("")
        4, // Width in bytes
        0x00000434, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_mmdc_masbs1
    },
    {
        "MAGENP",
        DESC("This register is a general 32 bit read/write register.")
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmdc_magenp
    },
    {
        "MPZQHWCTRL",
        DESC("")
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpzqhwctrl
    },
    {
        "MPZQSWCTRL",
        DESC("")
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mmdc_mpzqswctrl
    },
    {
        "MPWLGCR",
        DESC("")
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_mmdc_mpwlgcr
    },
    {
        "MPWLDECTRL0",
        DESC("")
        4, // Width in bytes
        0x0000080c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpwldectrl0
    },
    {
        "MPWLDECTRL1",
        DESC("")
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpwldectrl1
    },
    {
        "MPWLDLST",
        DESC("This register holds the status of the four write leveling delay-lines.")
        4, // Width in bytes
        0x00000814, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwldlst
    },
    {
        "MPODTCTRL",
        DESC("In LPDDR2 mode this register should be cleared, so no termination will"
        " be activated")
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mpodtctrl
    },
    {
        "MPRDDQBY0DL",
        DESC("This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte0 relative to the read DQS.")
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby0dl
    },
    {
        "MPRDDQBY1DL",
        DESC("This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte1 relative to the read DQS")
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby1dl
    },
    {
        "MPRDDQBY2DL",
        DESC("This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte2 relative to the read DQS")
        4, // Width in bytes
        0x00000824, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby2dl
    },
    {
        "MPRDDQBY3DL",
        DESC("This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte3 relative to the read DQS.")
        4, // Width in bytes
        0x00000828, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby3dl
    },
    {
        "MPWRDQBY0DL",
        DESC("This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte0 relative to the write DQS")
        4, // Width in bytes
        0x0000082c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby0dl
    },
    {
        "MPWRDQBY1DL",
        DESC("This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte1 relative to the write DQS")
        4, // Width in bytes
        0x00000830, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby1dl
    },
    {
        "MPWRDQBY2DL",
        DESC("This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte2 relative to the write DQS")
        4, // Width in bytes
        0x00000834, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby2dl
    },
    {
        "MPWRDQBY3DL",
        DESC("This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte3 relative to the write DQS")
        4, // Width in bytes
        0x00000838, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby3dl
    },
    {
        "MPDGCTRL0",
        DESC("")
        4, // Width in bytes
        0x0000083c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_mmdc_mpdgctrl0
    },
    {
        "MPDGCTRL1",
        DESC("")
        4, // Width in bytes
        0x00000840, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpdgctrl1
    },
    {
        "MPDGDLST0",
        DESC("This register holds the status of the 4 dqs gating delay-lines.")
        4, // Width in bytes
        0x00000844, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpdgdlst0
    },
    {
        "MPRDDLCTL",
        DESC("This register controls read delay-lines functionality; it determines D"
        "QS delay relative to the associated DQ read access.")
        4, // Width in bytes
        0x00000848, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlctl
    },
    {
        "MPRDDLST",
        DESC("This register holds the status of the 4 read delay-lines.")
        4, // Width in bytes
        0x0000084c, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlst
    },
    {
        "MPWRDLCTL",
        DESC("This register controls write delay-lines functionality, it determines "
        "DQ/DM delay relative to the associated DQS in write access.")
        4, // Width in bytes
        0x00000850, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlctl
    },
    {
        "MPWRDLST",
        DESC("This register holds the status of the 4 write delay-line.")
        4, // Width in bytes
        0x00000854, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlst
    },
    {
        "MPSDCTRL",
        DESC("This register controls the fine tuning of the primary clock (CK0).")
        4, // Width in bytes
        0x00000858, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_mpsdctrl
    },
    {
        "MPZQLP2CTL",
        DESC("This register controls the idle time that takes the LPDDR2 device to p"
        "erform ZQ calibration")
        4, // Width in bytes
        0x0000085c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mmdc_mpzqlp2ctl
    },
    {
        "MPRDDLHWCTL",
        DESC("")
        4, // Width in bytes
        0x00000860, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mprddlhwctl
    },
    {
        "MPWRDLHWCTL",
        DESC("")
        4, // Width in bytes
        0x00000864, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpwrdlhwctl
    },
    {
        "MPRDDLHWST0",
        DESC("")
        4, // Width in bytes
        0x00000868, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlhwst0
    },
    {
        "MPRDDLHWST1",
        DESC("")
        4, // Width in bytes
        0x0000086c, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlhwst1
    },
    {
        "MPWRDLHWST0",
        DESC("")
        4, // Width in bytes
        0x00000870, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlhwst0
    },
    {
        "MPWRDLHWST1",
        DESC("")
        4, // Width in bytes
        0x00000874, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlhwst1
    },
    {
        "MPWLHWERR",
        DESC("")
        4, // Width in bytes
        0x00000878, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwlhwerr
    },
    {
        "MPDGHWST0",
        DESC("")
        4, // Width in bytes
        0x0000087c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst0
    },
    {
        "MPDGHWST1",
        DESC("")
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst1
    },
    {
        "MPDGHWST2",
        DESC("")
        4, // Width in bytes
        0x00000884, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst2
    },
    {
        "MPDGHWST3",
        DESC("")
        4, // Width in bytes
        0x00000888, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst3
    },
    {
        "MPPDCMPR1",
        DESC("This register holds the MMDC pre-defined compare value that will be us"
        "ed during automatic read, read DQS gating and write calibration proces"
        "s.")
        4, // Width in bytes
        0x0000088c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_mppdcmpr1
    },
    {
        "MPPDCMPR2",
        DESC("")
        4, // Width in bytes
        0x00000890, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_mmdc_mppdcmpr2
    },
    {
        "MPSWDAR0",
        DESC("")
        4, // Width in bytes
        0x00000894, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpswdar0
    },
    {
        "MPSWDRDR0",
        DESC("")
        4, // Width in bytes
        0x00000898, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr0
    },
    {
        "MPSWDRDR1",
        DESC("")
        4, // Width in bytes
        0x0000089c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr1
    },
    {
        "MPSWDRDR2",
        DESC("")
        4, // Width in bytes
        0x000008a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr2
    },
    {
        "MPSWDRDR3",
        DESC("")
        4, // Width in bytes
        0x000008a4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr3
    },
    {
        "MPSWDRDR4",
        DESC("")
        4, // Width in bytes
        0x000008a8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr4
    },
    {
        "MPSWDRDR5",
        DESC("")
        4, // Width in bytes
        0x000008ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr5
    },
    {
        "MPSWDRDR6",
        DESC("")
        4, // Width in bytes
        0x000008b0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr6
    },
    {
        "MPSWDRDR7",
        DESC("")
        4, // Width in bytes
        0x000008b4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr7
    },
    {
        "MPMUR0",
        DESC("")
        4, // Width in bytes
        0x000008b8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpmur0
    },
    {
        "MPWRCADL",
        DESC("This register is used to add fine-tuning adjustment to the CA (command"
        "/Address of LPDDR2 bus) relative to the DDR clock")
        4, // Width in bytes
        0x000008bc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_mmdc_mpwrcadl
    },
    {
        "MPDCCR",
        DESC("This register is used to control the duty cycle of the DQS and the pri"
        "mary clock (CK0) .")
        4, // Width in bytes
        0x000008c0, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_mmdc_mpdccr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark OCOTP
#endif

// Bitfields in register OCOTP_CTRL.
static const field_t hw_ocotp_ctrl[] =
{
    {
        "ADDR",
        DESC("OTP write and read access address register.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY",
        DESC("OTP controller status bit.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        DESC("Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        DESC("Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_TEST",
        DESC("Set to calculate CRC according to start address and end address in CRC"
        "_ADDR register.And compare with CRC fuse word according CRC address in"
        " CRC_ADDR register to generate CRC_FAIL flag")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_FAIL",
        DESC("Set by controller when calculated CRC value is not equal to appointed "
        "CRC fuse word")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_UNLOCK",
        DESC("Write 0x3E77 to enable OTP write accesses.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_TIMING.
static const field_t hw_ocotp_timing[] =
{
    {
        "STROBE_PROG",
        DESC("This count value specifies the strobe period in one time write OTP.")
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELAX",
        DESC("This count value specifies the time to add to all default timing param"
        "eters other than the Tpgm and Trd.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_READ",
        DESC("This count value specifies the strobe period in one time read OTP.")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT",
        DESC("This count value specifies time interval between auto read and write a"
        "ccess in one time program.")
        22, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_DATA.
static const field_t hw_ocotp_data[] =
{
    {
        "DATA",
        DESC("Used to initiate a write to OTP.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_READ_CTRL.
static const field_t hw_ocotp_read_ctrl[] =
{
    {
        "READ_FUSE",
        DESC("Used to initiate a read to OTP.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_READ_FUSE_DATA.
static const field_t hw_ocotp_read_fuse_data[] =
{
    {
        "DATA",
        DESC("The data read from OTP")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_STICKY.
static const field_t hw_ocotp_sw_sticky[] =
{
    {
        "SRK_REVOKE_LOCK",
        DESC("Shadow register write and OTP write lock for SRK_REVOKE region.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIELD_RETURN_LOCK",
        DESC("Shadow register write and OTP write lock for FIELD_RETURN region.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SCS.
static const field_t hw_ocotp_scs[] =
{
    {
        "HAB_JDE",
        DESC("HAB JTAG Debug Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        DESC("Unallocated read/write bits for implementation specific software use.")
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        DESC("When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CRC_ADDR.
static const field_t hw_ocotp_crc_addr[] =
{
    {
        "DATA_START_ADDR",
        DESC("End address of fuse location for CRC calculation")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_END_ADDR",
        DESC("Start address of fuse location for CRC calculation")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_ADDR",
        DESC("Address of 32-bit CRC result for comparing")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CRC_VALUE.
static const field_t hw_ocotp_crc_value[] =
{
    {
        "DATA",
        DESC("The crc32 value based on CRC_ADDR")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_UMC_TIMING.
static const field_t hw_ocotp_umc_timing[] =
{
    {
        "STROBE_PROG_INT",
        DESC("This count value specifies the strobe pulse interval in one time write"
        " OTP.")
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_VERSION.
static const field_t hw_ocotp_version[] =
{
    {
        "STEP",
        DESC("Fixed read-only value reflecting the stepping of the RTL version.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        DESC("Fixed read-only value reflecting the MINOR field of the RTL version.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        DESC("Fixed read-only value reflecting the MAJOR field of the RTL version.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_LOCK.
static const field_t hw_ocotp_lock[] =
{
    {
        "TESTER",
        DESC("Status of shadow register and OTP write lock for tester region.")
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG",
        DESC("Status of shadow register and OTP write lock for boot_cfg region.")
        2, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MEM_TRIM",
        DESC("Status of shadow register and OTP write lock for mem_trim region.")
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SJC_RESP",
        DESC("Status of shadow register read and write, OTP read and write lock for "
        "sjc_resp region.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAC_ADDR",
        DESC("Status of shadow register and OTP write lock for mac_addr region.")
        8, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP1",
        DESC("Status of shadow register and OTP write lock for gp2 region.")
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP2",
        DESC("Status of shadow register and OTP write lock for gp2 region.")
        12, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SRK",
        DESC("Status of shadow register and OTP write lock for srk region.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_GP",
        DESC("Status of shadow register lock for the region contained in the SW_GP r"
        "egisters.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DCP",
        DESC("Status of shadow register read and write, OTP read and write lock for "
        "otpmk region.")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ANALOG",
        DESC("Status of shadow register and OTP write lock for analog region.")
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CRC_GP_LOCK",
        DESC("Status of shadow register write and read, OTP program and read lock fo"
        "r CRC region.")
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MISC_CONF",
        DESC("Status of shadow register and OTP write lock for misc_conf region.")
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIN",
        DESC("Status of Pin access lock bit.")
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP_LO_LOCK",
        DESC("Status of shadow register and OTP write lock for GP region.")
        26, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP_HI_LOCK",
        DESC("Status of shadow register and OTP write lock for GP region.")
        28, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNALLOCATED",
        DESC("Value of un-used portion of LOCK word")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG0.
static const field_t hw_ocotp_cfg0[] =
{
    {
        "BITS",
        DESC("This register contains 32 bits of the Unique ID and SJC_CHALLENGE fiel"
        "d.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG1.
static const field_t hw_ocotp_cfg1[] =
{
    {
        "BITS",
        DESC("This register contains 32 bits of the Unique ID and SJC_CHALLENGE fiel"
        "d.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG2.
static const field_t hw_ocotp_cfg2[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 0, word 3 (ADDR = 0x03).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG3.
static const field_t hw_ocotp_cfg3[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 0, word 4 (ADDR = 0x04).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG4.
static const field_t hw_ocotp_cfg4[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 0, word 5 (ADDR = 0x05).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG5.
static const field_t hw_ocotp_cfg5[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 0, word 6 (ADDR = 0x06).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG6.
static const field_t hw_ocotp_cfg6[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 0, word 7 (ADDR = 0x07).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM0.
static const field_t hw_ocotp_mem0[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP bank 1, word 0 (ADDR = 0x08).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM1.
static const field_t hw_ocotp_mem1[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP bank 1, word 1 (ADDR = 0x09).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM2.
static const field_t hw_ocotp_mem2[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP bank 1, word 2 (ADDR = 0x0A).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM3.
static const field_t hw_ocotp_mem3[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP bank 1, word 3 (ADDR = 0x0B).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM4.
static const field_t hw_ocotp_mem4[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP bank 1, word 4 (ADDR = 0x0C).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ANA0.
static const field_t hw_ocotp_ana0[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP bank 1, word 5 (ADDR = 0x0D).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ANA1.
static const field_t hw_ocotp_ana1[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP bank 1, word 6 (ADDR = 0x0E).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ANA2.
static const field_t hw_ocotp_ana2[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP bank 1, word 7 (ADDR = 0x0F).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_DCP0.
static const field_t hw_ocotp_dcp0[] =
{
    {
        "BITS",
        DESC("Shadow register for the DCP Key word0 (Copy of OTP Bank 2, word 0 (ADD"
        "R = 0x10)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_DCP1.
static const field_t hw_ocotp_dcp1[] =
{
    {
        "BITS",
        DESC("Shadow register for the DCP Key word1 (Copy of OTP Bank 2, word 1 (ADD"
        "R = 0x11)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_DCP2.
static const field_t hw_ocotp_dcp2[] =
{
    {
        "BITS",
        DESC("Shadow register for the DCP Key word2 (Copy of OTP Bank 2, word 2 (ADD"
        "R = 0x12)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_DCP3.
static const field_t hw_ocotp_dcp3[] =
{
    {
        "BITS",
        DESC("Shadow register for the DCP Key word3 (Copy of OTP Bank 2, word 3 (ADD"
        "R = 0x13)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_DCP4.
static const field_t hw_ocotp_dcp4[] =
{
    {
        "BITS",
        DESC("Shadow register for the DCP Key word4 (Copy of OTP Bank 2, word 4 (ADD"
        "R = 0x14)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_DCP5.
static const field_t hw_ocotp_dcp5[] =
{
    {
        "BITS",
        DESC("Shadow register for the DCP Key word5 (Copy of OTP Bank 2, word 5 (ADD"
        "R = 0x15)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_DCP6.
static const field_t hw_ocotp_dcp6[] =
{
    {
        "BITS",
        DESC("Shadow register for the DCP Key word6 (Copy of OTP Bank 2, word 6 (ADD"
        "R = 0x16)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_DCP7.
static const field_t hw_ocotp_dcp7[] =
{
    {
        "BITS",
        DESC("Shadow register for the DCP Key word7 (Copy of OTP Bank 2, word 7 (ADD"
        "R = 0x17)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK0.
static const field_t hw_ocotp_srk0[] =
{
    {
        "BITS",
        DESC("Shadow register for the hash of the Super Root Key word0 (Copy of OTP "
        "Bank 3, word 0 (ADDR = 0x1C)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK1.
static const field_t hw_ocotp_srk1[] =
{
    {
        "BITS",
        DESC("Shadow register for the hash of the Super Root Key word1 (Copy of OTP "
        "Bank 3, word 1 (ADDR = 0x1D)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK2.
static const field_t hw_ocotp_srk2[] =
{
    {
        "BITS",
        DESC("Shadow register for the hash of the Super Root Key word2 (Copy of OTP "
        "Bank 3, word 2 (ADDR = 0x1E)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK3.
static const field_t hw_ocotp_srk3[] =
{
    {
        "BITS",
        DESC("Shadow register for the hash of the Super Root Key word3 (Copy of OTP "
        "Bank 3, word 3 (ADDR = 0x1F)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK4.
static const field_t hw_ocotp_srk4[] =
{
    {
        "BITS",
        DESC("Shadow register for the hash of the Super Root Key word4 (Copy of OTP "
        "Bank 3, word 4 (ADDR = 0x20)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK5.
static const field_t hw_ocotp_srk5[] =
{
    {
        "BITS",
        DESC("Shadow register for the hash of the Super Root Key word5 (Copy of OTP "
        "Bank 3, word 5 (ADDR = 0x21)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK6.
static const field_t hw_ocotp_srk6[] =
{
    {
        "BITS",
        DESC("Shadow register for the hash of the Super Root Key word6 (Copy of OTP "
        "Bank 3, word 6 (ADDR = 0x22)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK7.
static const field_t hw_ocotp_srk7[] =
{
    {
        "BITS",
        DESC("Shadow register for the hash of the Super Root Key word7 (Copy of OTP "
        "Bank 3, word 7 (ADDR = 0x23)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SJC_RESP0.
static const field_t hw_ocotp_sjc_resp0[] =
{
    {
        "BITS",
        DESC("Shadow register for the SJC_RESP Key word0 (Copy of OTP Bank 4, word 0"
        " (ADDR = 0x20)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SJC_RESP1.
static const field_t hw_ocotp_sjc_resp1[] =
{
    {
        "BITS",
        DESC("Shadow register for the SJC_RESP Key word1 (Copy of OTP Bank 4, word 1"
        " (ADDR = 0x21)).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MAC0.
static const field_t hw_ocotp_mac0[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 4, word 2 (ADDR = 0x22).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MAC1.
static const field_t hw_ocotp_mac1[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 4, word 3 (ADDR = 0x23).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CRC0.
static const field_t hw_ocotp_crc0[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 4, word 4 (ADDR = 0x24).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CRC1.
static const field_t hw_ocotp_crc1[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 4, word 5 (ADDR = 0x25).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP1.
static const field_t hw_ocotp_gp1[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 4, word 6 (ADDR = 0x26).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP2.
static const field_t hw_ocotp_gp2[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 4, word 7 (ADDR = 0x27).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_GP0.
static const field_t hw_ocotp_sw_gp0[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 5, word 0 (ADDR = 0x28).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_GP1.
static const field_t hw_ocotp_sw_gp1[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 5, word 1 (ADDR = 0x29).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_GP2.
static const field_t hw_ocotp_sw_gp2[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 5, word 2 (ADDR = 0x2a).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_GP3.
static const field_t hw_ocotp_sw_gp3[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 5, word 3 (ADDR = 0x2b).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_GP4.
static const field_t hw_ocotp_sw_gp4[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 5, word 4 (ADDR = 0x2c).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MISC_CONF.
static const field_t hw_ocotp_misc_conf[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 5, word 5 (ADDR = 0x2d).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_FIELD_RETURN.
static const field_t hw_ocotp_field_return[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 5, word 6 (ADDR = 0x2e).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK_REVOKE.
static const field_t hw_ocotp_srk_revoke[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 5, word 7 (ADDR = 0x2f).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_LO0.
static const field_t hw_ocotp_gp_lo0[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 6, word 0 (ADDR = 0x30).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_LO1.
static const field_t hw_ocotp_gp_lo1[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 6, word 1 (ADDR = 0x31).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_LO2.
static const field_t hw_ocotp_gp_lo2[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 6, word 2 (ADDR = 0x32).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_LO3.
static const field_t hw_ocotp_gp_lo3[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 6, word 3 (ADDR = 0x33).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_LO4.
static const field_t hw_ocotp_gp_lo4[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 6, word 4 (ADDR = 0x34).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_LO5.
static const field_t hw_ocotp_gp_lo5[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 6, word 5 (ADDR = 0x35).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_LO6.
static const field_t hw_ocotp_gp_lo6[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 6, word 6 (ADDR = 0x36).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_LO7.
static const field_t hw_ocotp_gp_lo7[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 6, word 7 (ADDR = 0x37).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_HI0.
static const field_t hw_ocotp_gp_hi0[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 7, word 0 (ADDR = 0x38).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_HI1.
static const field_t hw_ocotp_gp_hi1[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 7, word 1 (ADDR = 0x39).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_HI2.
static const field_t hw_ocotp_gp_hi2[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 7, word 2 (ADDR = 0x3a).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_HI3.
static const field_t hw_ocotp_gp_hi3[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 7, word 3 (ADDR = 0x3b).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_HI4.
static const field_t hw_ocotp_gp_hi4[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 7, word 4 (ADDR = 0x3c).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_HI5.
static const field_t hw_ocotp_gp_hi5[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 7, word 5 (ADDR = 0x3d).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_HI6.
static const field_t hw_ocotp_gp_hi6[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 7, word 6 (ADDR = 0x3e).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP_HI7.
static const field_t hw_ocotp_gp_hi7[] =
{
    {
        "BITS",
        DESC("Reflects value of OTP Bank 7, word 7 (ADDR = 0x3f).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a OCOTP module.
static const reg_t hw_ocotp[] =
{
    {
        "CTRL",
        DESC("The OCOTP Control and Status Register specifies the copy state, as wel"
        "l as the control required for random access of the OTP memory OCOTP_CT"
        "RL: 0x000 OCOTP_CTRL_SET: 0x004 OCOTP_CTRL_CLR: 0x008 OCOTP_CTRL_TOG: "
        "0x00C The OCOTP Control and Status Register provides the necessary sof"
        "tware interface for performing read and write operations to the On-Chi"
        "p OTP (One-Time Programmable ROM).")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ocotp_ctrl
    },
    {
        "TIMING",
        DESC("The OCOTP Data Register is used for OTP Programming This register spec"
        "ifies timing parameters for programming and reading the OCOTP fuse arr"
        "ay.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ocotp_timing
    },
    {
        "DATA",
        DESC("The OCOTP Data Register is used for OTP Programming This register is u"
        "sed in conjuction with OCOTP_CTRL to perform one-time writes to the OT"
        "P.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_data
    },
    {
        "READ_CTRL",
        DESC("The OCOTP Register is used for OTP Read This register is used in conju"
        "ction with OCOTP_CTRL to perform one time read to the OTP.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_read_ctrl
    },
    {
        "READ_FUSE_DATA",
        DESC("The OCOTP Data Register is used for OTP Read The data read from OTP EX"
        "AMPLE Empty Example.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_read_fuse_data
    },
    {
        "SW_STICKY",
        DESC("Some SW sticky bits .")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ocotp_sw_sticky
    },
    {
        "SCS",
        DESC("OCOTP_SCS: 0x060 OCOTP_SCS_SET: 0x064 OCOTP_SCS_CLR: 0x068 OCOTP_SCS_T"
        "OG: 0x06C This register holds volatile configuration values that can b"
        "e set and locked by trusted software.")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_scs
    },
    {
        "CRC_ADDR",
        DESC("The OCOTP Data Register is used for OTP Read The address for CRC calcu"
        "lation EXAMPLE Empty Example.")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_crc_addr
    },
    {
        "CRC_VALUE",
        DESC("The OCOTP Data Register is used for OTP Read The crc32 value based on "
        "CRC_ADDR EXAMPLE Empty Example.")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_crc_value
    },
    {
        "UMC_TIMING",
        DESC("The OCOTP Data Register is used for OTP Programming This register spec"
        "ifies timing parameters for programming UMC OCOTP fuse array.")
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_umc_timing
    },
    {
        "VERSION",
        DESC("This register always returns a known read value for debug purposes it "
        "indicates the version of the block.")
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_version
    },
    {
        "LOCK",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ocotp_lock
    },
    {
        "CFG0",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg0
    },
    {
        "CFG1",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg1
    },
    {
        "CFG2",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg2
    },
    {
        "CFG3",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg3
    },
    {
        "CFG4",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000450, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg4
    },
    {
        "CFG5",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg5
    },
    {
        "CFG6",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000470, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg6
    },
    {
        "MEM0",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem0
    },
    {
        "MEM1",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem1
    },
    {
        "MEM2",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000004a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem2
    },
    {
        "MEM3",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000004b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem3
    },
    {
        "MEM4",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000004c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem4
    },
    {
        "ANA0",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000004d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ana0
    },
    {
        "ANA1",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000004e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ana1
    },
    {
        "ANA2",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000004f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ana2
    },
    {
        "DCP0",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_dcp0
    },
    {
        "DCP1",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000510, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_dcp1
    },
    {
        "DCP2",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000520, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_dcp2
    },
    {
        "DCP3",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000530, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_dcp3
    },
    {
        "DCP4",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000540, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_dcp4
    },
    {
        "DCP5",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000550, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_dcp5
    },
    {
        "DCP6",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000560, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_dcp6
    },
    {
        "DCP7",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000570, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_dcp7
    },
    {
        "SRK0",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk0
    },
    {
        "SRK1",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000590, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk1
    },
    {
        "SRK2",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000005a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk2
    },
    {
        "SRK3",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000005b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk3
    },
    {
        "SRK4",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000005c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk4
    },
    {
        "SRK5",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000005d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk5
    },
    {
        "SRK6",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000005e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk6
    },
    {
        "SRK7",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000005f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk7
    },
    {
        "SJC_RESP0",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sjc_resp0
    },
    {
        "SJC_RESP1",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sjc_resp1
    },
    {
        "MAC0",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000620, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mac0
    },
    {
        "MAC1",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000630, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mac1
    },
    {
        "CRC0",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000640, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_crc0
    },
    {
        "CRC1",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000650, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_crc1
    },
    {
        "GP1",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000660, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp1
    },
    {
        "GP2",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000670, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp2
    },
    {
        "SW_GP0",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000680, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sw_gp0
    },
    {
        "SW_GP1",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000690, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sw_gp1
    },
    {
        "SW_GP2",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000006a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sw_gp2
    },
    {
        "SW_GP3",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000006b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sw_gp3
    },
    {
        "SW_GP4",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000006c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sw_gp4
    },
    {
        "MISC_CONF",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000006d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_misc_conf
    },
    {
        "FIELD_RETURN",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000006e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_field_return
    },
    {
        "SRK_REVOKE",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000006f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk_revoke
    },
    {
        "GP_LO0",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000700, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_lo0
    },
    {
        "GP_LO1",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000710, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_lo1
    },
    {
        "GP_LO2",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000720, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_lo2
    },
    {
        "GP_LO3",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000730, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_lo3
    },
    {
        "GP_LO4",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000740, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_lo4
    },
    {
        "GP_LO5",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000750, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_lo5
    },
    {
        "GP_LO6",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000760, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_lo6
    },
    {
        "GP_LO7",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000770, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_lo7
    },
    {
        "GP_HI0",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000780, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_hi0
    },
    {
        "GP_HI1",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x00000790, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_hi1
    },
    {
        "GP_HI2",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000007a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_hi2
    },
    {
        "GP_HI3",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000007b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_hi3
    },
    {
        "GP_HI4",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000007c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_hi4
    },
    {
        "GP_HI5",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000007d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_hi5
    },
    {
        "GP_HI6",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000007e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_hi6
    },
    {
        "GP_HI7",
        DESC("Copied from the OTP automatically after reset.")
        4, // Width in bytes
        0x000007f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp_hi7
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PGC
#endif

// Bitfields in register PGC_DISPLAY_CTRL.
static const field_t hw_pgc_display_ctrl[] =
{
    {
        "PCR",
        DESC("Power Control  PCR must not change from power-down request (pdn_req) a"
        "ssertion until the target subsystem is completely powered up.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_DISPLAY_PUPSCR.
static const field_t hw_pgc_display_pupscr[] =
{
    {
        "SW",
        DESC("After a power-up request (pup_req assertion), the PGC waits a number o"
        "f clocks equal to the value of SW before asserting switch_b.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW2ISO",
        DESC("After asserting switch_b, the PGC waits a number of clocks equal to th"
        "e value of SW2ISO before negating isolation.")
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_DISPLAY_PDNSCR.
static const field_t hw_pgc_display_pdnscr[] =
{
    {
        "ISO",
        DESC("After a power-down request (pdn_req assertion), the PGC waits a number"
        " of clocks equal to the value of ISO before asserting isolation.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISO2SW",
        DESC("After asserting isolation, the PGC waits a number of clocks equal to t"
        "he value of ISO2SW before negating switch_b.")
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_DISPLAY_SR.
static const field_t hw_pgc_display_sr[] =
{
    {
        "PSR",
        DESC("Power status.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_GPU_CTRL.
static const field_t hw_pgc_gpu_ctrl[] =
{
    {
        "PCR",
        DESC("Power Control  PCR must not change from power-down request (pdn_req) a"
        "ssertion until the target subsystem is completely powered up.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_GPU_PUPSCR.
static const field_t hw_pgc_gpu_pupscr[] =
{
    {
        "SW",
        DESC("After a power-up request (pup_req assertion), the PGC waits a number o"
        "f clocks equal to the value of SW before asserting switch_b.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW2ISO",
        DESC("After asserting switch_b, the PGC waits a number of clocks equal to th"
        "e value of SW2ISO before negating isolation.")
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_GPU_PDNSCR.
static const field_t hw_pgc_gpu_pdnscr[] =
{
    {
        "ISO",
        DESC("After a power-down request (pdn_req assertion), the PGC waits a number"
        " of clocks equal to the value of ISO before asserting isolation.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISO2SW",
        DESC("After asserting isolation, the PGC waits a number of clocks equal to t"
        "he value of ISO2SW before negating switch_b.")
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_GPU_SR.
static const field_t hw_pgc_gpu_sr[] =
{
    {
        "PSR",
        DESC("Power status.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_CPU_CTRL.
static const field_t hw_pgc_cpu_ctrl[] =
{
    {
        "PCR",
        DESC("Power Control  PCR must not change from power-down request (pdn_req) a"
        "ssertion until the target subsystem is completely powered up.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_CPU_PUPSCR.
static const field_t hw_pgc_cpu_pupscr[] =
{
    {
        "SW",
        DESC("After a power-up request (pup_req assertion), the PGC waits a number o"
        "f clocks equal to the value of SW before asserting switch_b.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW2ISO",
        DESC("After asserting switch_b, the PGC waits a number of clocks equal to th"
        "e value of SW2ISO before negating isolation.")
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_CPU_PDNSCR.
static const field_t hw_pgc_cpu_pdnscr[] =
{
    {
        "ISO",
        DESC("After a power-down request (pdn_req assertion), the PGC waits a number"
        " of clocks equal to the value of ISO before asserting isolation.")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISO2SW",
        DESC("After asserting isolation, the PGC waits a number of clocks equal to t"
        "he value of ISO2SW before negating switch_b.")
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PGC_CPU_SR.
static const field_t hw_pgc_cpu_sr[] =
{
    {
        "PSR",
        DESC("Power status.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a PGC module.
static const reg_t hw_pgc[] =
{
    {
        "DISPLAY_CTRL",
        DESC("The PGCR enables the response to a power-down request.")
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_display_ctrl
    },
    {
        "DISPLAY_PUPSCR",
        DESC("The PUPSCR contains the power-up timing parameters.")
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_display_pupscr
    },
    {
        "DISPLAY_PDNSCR",
        DESC("The PDNSCR contains the power-down timing parameters.")
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_display_pdnscr
    },
    {
        "DISPLAY_SR",
        DESC("The PDNSCR contains the power-down timing parameters.")
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_display_sr
    },
    {
        "GPU_CTRL",
        DESC("The PGCR enables the response to a power-down request.")
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_gpu_ctrl
    },
    {
        "GPU_PUPSCR",
        DESC("The PUPSCR contains the power-up timing parameters.")
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_gpu_pupscr
    },
    {
        "GPU_PDNSCR",
        DESC("The PDNSCR contains the power-down timing parameters.")
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_gpu_pdnscr
    },
    {
        "GPU_SR",
        DESC("The PDNSCR contains the power-down timing parameters.")
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_gpu_sr
    },
    {
        "CPU_CTRL",
        DESC("The PGCR enables the response to a power-down request.")
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_cpu_ctrl
    },
    {
        "CPU_PUPSCR",
        DESC("The PUPSCR contains the power-up timing parameters.")
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_cpu_pupscr
    },
    {
        "CPU_PDNSCR",
        DESC("The PDNSCR contains the power-down timing parameters.")
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pgc_cpu_pdnscr
    },
    {
        "CPU_SR",
        DESC("The PDNSCR contains the power-down timing parameters.")
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pgc_cpu_sr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PMU
#endif

// Bitfields in register PMU_REG_1P1.
static const field_t hw_pmu_reg_1p1[] =
{
    {
        "ENABLE_LINREG",
        DESC("Control bit to enable the regulator output.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BO",
        DESC("Control bit to enable the brown-out circuitry in the regulator.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ILIMIT",
        DESC("Control bit to enable the current-limit circuitry in the regulator.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PULLDOWN",
        DESC("Control bit to enable the pull-down circuitry in the regulator")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_OFFSET",
        DESC("Control bits to adjust the regulator brown-out offset voltage in 25mV "
        "steps.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTPUT_TRG",
        DESC("Control bits to adjust the regulator output voltage.")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_VDD1P1",
        DESC("Status bit that signals when a brown-out is detected on the regulator "
        "output.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OK_VDD1P1",
        DESC("Status bit that signals when the regulator output is ok.")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_REG_3P0.
static const field_t hw_pmu_reg_3p0[] =
{
    {
        "ENABLE_LINREG",
        DESC("Control bit to enable the regulator output.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BO",
        DESC("Control bit to enable the brown-out circuitry in the regulator.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ILIMIT",
        DESC("Control bit to enable the current-limit circuitry in the regulator.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_OFFSET",
        DESC("Control bits to adjust the regulator brown-out offset voltage in 25mV "
        "steps.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUS_SEL",
        DESC("Select input voltage source for LDO_3P0 from either USB OTG1 or USB OT"
        "G2.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTPUT_TRG",
        DESC("Control bits to adjust the regulator output voltage.")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_VDD3P0",
        DESC("Status bit that signals when a brown-out is detected on the regulator "
        "output.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OK_VDD3P0",
        DESC("Status bit that signals when the regulator output is ok.")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_REG_2P5.
static const field_t hw_pmu_reg_2p5[] =
{
    {
        "ENABLE_LINREG",
        DESC("Control bit to enable the regulator output.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BO",
        DESC("Control bit to enable the brown-out circuitry in the regulator.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ILIMIT",
        DESC("Control bit to enable the current-limit circuitry in the regulator.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PULLDOWN",
        DESC("Control bit to enable the pull-down circuitry in the regulator")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_OFFSET",
        DESC("Control bits to adjust the regulator brown-out offset voltage in 25mV "
        "steps.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTPUT_TRG",
        DESC("Control bits to adjust the regulator output voltage.")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_VDD2P5",
        DESC("Status bit that signals when a brown-out is detected on the regulator "
        "output.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OK_VDD2P5",
        DESC("Status bit that signals when the regulator output is ok.")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE_WEAK_LINREG",
        DESC("Enables the weak 2p5 regulator.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_REG_CORE.
static const field_t hw_pmu_reg_core[] =
{
    {
        "REG0_TARG",
        DESC("This bitfield defines the target voltage for the arm core power domain"
        ".")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_ADJ",
        DESC("This bitfield defines the adjustment bits to calibrate the target valu"
        "e of REG1 (ARM_CORE).")
        5, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_TARG",
        DESC("This bitfield defines the target voltage for the VPU/GPU power domain.")
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_ADJ",
        DESC("This bitfield defines the adjustment bits to calibrate the target valu"
        "e of REG1 (REG_PU).")
        14, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_TARG",
        DESC("This bitfield defines the target voltage for the SOC power domain.")
        18, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_ADJ",
        DESC("This bitfield defines the adjustment bits to calibrate the target valu"
        "e of REG2 (REG_SOC).")
        23, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FET_ODRIVE",
        DESC("If set, increases the gate drive on power gating fets to reduce leakag"
        "e in the off state.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC0.
static const field_t hw_pmu_misc0[] =
{
    {
        "REFTOP_PWD",
        DESC("Control bit to power-down the analog bandgap reference circuitry.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        DESC("Control bit to disable the self-bias circuit in the analog bandgap.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        DESC("")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        DESC("Status bit which signals that the analog bandgap voltage is up and sta"
        "ble.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        DESC("Configure the analog behavior in stop mode.")
        11, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCON_HIGH_SNVS",
        DESC("This bit forces the short between VDDHIGH_IN and VSNVS_IN to open when"
        " asserted.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        DESC("This bit field determines the bias current in the 24MHz oscillator.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        DESC("Status bit which signals that the output of the 24MHz crystal oscillat"
        "or is stable.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        DESC("This bit is asserted when the 24MHz oscillator is close to its operati"
        "ng frequency.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBCP_VPW_THRESH",
        DESC("This signal alters the voltage that the pwell is charged pumped to.")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        DESC("This bit allows disabling the clock gate (always un-gated) for the xta"
        "l 24MHz clock that clocks the digital logic in the analog block.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        DESC("This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and release the clock to the digital logic inside the analog block.")
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC1.
static const field_t hw_pmu_misc1[] =
{
    {
        "LVDS1_CLK_SEL",
        DESC("This field selects the clk to be routed to anaclk2/2b.")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_OBEN",
        DESC("This enables the lvds output buffer for anaclk1/1b.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVDSCLK1_IBEN",
        DESC("This enables the lvds input buffer for anaclk1/1b.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPSENSE",
        DESC("This status bit is set to one when when the temperature sensor interru"
        "pt asserts.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        DESC("This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        DESC("This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC2.
static const field_t hw_pmu_misc2[] =
{
    {
        "REG0_BO_OFFSET",
        DESC("This bit field defines the brown out voltage offset for the CORE power"
        " domain.")
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        DESC("Reg0 brownout status bit.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        DESC("Enables the brownout detection.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        DESC("Default value of \"0\".")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        DESC("This bit field defines the brown out voltage offset for the xPU power "
        "domain.")
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        DESC("Reg1 brownout status bit.")
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        DESC("Enables the brownout detection.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        DESC("LSB of Audio Pll post divider two bit control: 0x0=div-by-1(default), "
        "0x1=div-by-2, 0x2-div-by-1, 0x3=div-by-4.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        DESC("This bit field defines the brown out voltage offset for the xPU power "
        "domain.")
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        DESC("Reg2 brownout status bit.")
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        DESC("Enables the brownout detection.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        DESC("Signals that the voltage is above the brownout level for the SOC suppl"
        "y.")
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        DESC("MSB of 2 bit post-divider field for the Audio PLL: 0x0=div-by-1(defaul"
        "t), 0x1=div-by-2, 0x2=div-by-1, 0x3=div-by-4.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        DESC("Number of clock periods (24MHz clock).")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        DESC("Number of clock periods (24MHz clock).")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        DESC("Number of clock periods (24MHz clock).")
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        DESC("Post-divider for video PLL.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_LOWPWR_CTRL.
static const field_t hw_pmu_lowpwr_ctrl[] =
{
    {
        "RC_OSC_EN",
        DESC("RC Osc.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        DESC("RC osc.")
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        DESC("Select the source for the 24MHz clock.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        DESC("Bandgap select.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        DESC("Low power bandgap test bit.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        DESC("Low power reftop ibias disable.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        DESC("L1 power gate control.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        DESC("L2 power gate control.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        DESC("CPU power gate control.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        DESC("Display logic power gate control.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWB_EN",
        DESC("Reverse well bias enable control.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        DESC("For debug purposes only.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        DESC("Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        DESC("Status of the 24MHz xtal oscillator.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a PMU module.
static const reg_t hw_pmu[] =
{
    {
        "REG_1P1",
        DESC("This register defines the control and status bits for the 1.1V regulat"
        "or.")
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pmu_reg_1p1
    },
    {
        "REG_3P0",
        DESC("This register defines the control and status bits for the 3.0V regulat"
        "or powered by the host USB VBUS pin.")
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pmu_reg_3p0
    },
    {
        "REG_2P5",
        DESC("This register defines the control and status bits for the 2.5V regulat"
        "or.")
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_pmu_reg_2p5
    },
    {
        "REG_CORE",
        DESC("This register defines the function of the digital regulators")
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_pmu_reg_core
    },
    {
        "MISC0",
        DESC("This register defines the control and status bits for miscellaneous an"
        "alog blocks.")
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_pmu_misc0
    },
    {
        "MISC1",
        DESC("This register defines the control and status bits for miscellaneous an"
        "alog blocks.")
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pmu_misc1
    },
    {
        "MISC2",
        DESC("This register defines the control and status bits for the digital regu"
        "lators, as well as some miscellaneous analog controls.")
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_pmu_misc2
    },
    {
        "LOWPWR_CTRL",
        DESC("This register defines the low power configuration bits.")
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_pmu_lowpwr_ctrl
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PWM
#endif

// Bitfields in register PWM_PWMCR.
static const field_t hw_pwm_pwmcr[] =
{
    {
        "EN",
        DESC("PWM Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REPEAT",
        DESC("Sample Repeat.")
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        DESC("Software Reset.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALER",
        DESC("Counter Clock Prescaler Value.")
        4, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKSRC",
        DESC("Select Clock Source.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POUTC",
        DESC("PWM Output Configuration.")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCTR",
        DESC("Half-word Data Swap Control.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCTR",
        DESC("Byte Data Swap Control.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        DESC("Debug Mode Enable.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAITEN",
        DESC("Wait Mode Enable.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEN",
        DESC("Doze Mode Enable.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        DESC("Stop Mode Enable.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWM",
        DESC("FIFO Water Mark.")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMSR.
static const field_t hw_pwm_pwmsr[] =
{
    {
        "FIFOAV",
        DESC("FIFO Available.")
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FE",
        DESC("FIFO Empty Status Bit.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROV",
        DESC("Roll-over Status.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMP",
        DESC("Compare Status.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWE",
        DESC("FIFO Write Error Status.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMIR.
static const field_t hw_pwm_pwmir[] =
{
    {
        "FIE",
        DESC("FIFO Empty Interrupt Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIE",
        DESC("Roll-over Interrupt Enable.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIE",
        DESC("Compare Interrupt Enable.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMSAR.
static const field_t hw_pwm_pwmsar[] =
{
    {
        "SAMPLE",
        DESC("Sample Value.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMPR.
static const field_t hw_pwm_pwmpr[] =
{
    {
        "PERIOD",
        DESC("Period Value.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMCNR.
static const field_t hw_pwm_pwmcnr[] =
{
    {
        "COUNT",
        DESC("Counter Value.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a PWM module.
static const reg_t hw_pwm[] =
{
    {
        "PWMCR",
        DESC("The PWM control register (PWM_PWMCR) is used to configure the operatin"
        "g settings of the PWM.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pwm_pwmcr
    },
    {
        "PWMSR",
        DESC("The PWM status register (PWM_PWMSR) contains seven bits which display "
        "the state of the FIFO and the occurrence of rollover and compare event"
        "s.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pwm_pwmsr
    },
    {
        "PWMIR",
        DESC("The PWM Interrupt register (PWM_PWMIR) contains three bits which contr"
        "ol the generation of the compare, rollover and FIFO empty interrupts.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pwm_pwmir
    },
    {
        "PWMSAR",
        DESC("The PWM sample register (PWM_PWMSAR) is the input to the FIFO.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pwm_pwmsar
    },
    {
        "PWMPR",
        DESC("The PWM period register (PWM_PWMPR) determines the period of the PWM o"
        "utput signal.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pwm_pwmpr
    },
    {
        "PWMCNR",
        DESC("The read-only pulse-width modulator counter register (PWM_PWMCNR) cont"
        "ains the current count value and can be read at any time without distu"
        "rbing the counter.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_pwm_pwmcnr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PXP
#endif

// Bitfields in register PXP_CTRL.
static const field_t hw_pxp_ctrl[] =
{
    {
        "ENABLE",
        DESC("Enables PXP operation with specified parameters.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ENABLE",
        DESC("Interrupt enable.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT_IRQ_ENABLE",
        DESC("Next command interrupt enable.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_DMA_IRQ_ENABLE",
        DESC("LUT DMA interrupt enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_LCD_HANDSHAKE",
        DESC("Enable handshake with LCD controller.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROTATE",
        DESC("Indicates the clockwise rotation to be applied at the output buffer.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HFLIP",
        DESC("Indicates that the output buffer should be flipped horizontally (effec"
        "t applied before rotation).")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VFLIP",
        DESC("Indicates that the output buffer should be flipped vertically (effect "
        "applied before rotation).")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROT_POS",
        DESC("This bit controls where rotation will occur in the PXP datapath.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLOCK_SIZE",
        DESC("Select the block size to process.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_REPEAT",
        DESC("Enable the PXP to run continuously.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        DESC("This bit must be set to zero for normal operation.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        DESC("Set this bit to zero to enable normal PXP operation.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_STAT.
static const field_t hw_pxp_stat[] =
{
    {
        "IRQ",
        DESC("Indicates current PXP interrupt status.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_WRITE_ERROR",
        DESC("Indicates PXP encountered an AXI write error and processing has been t"
        "erminated.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_READ_ERROR",
        DESC("Indicates PXP encountered an AXI read error and processing has been te"
        "rminated.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT_IRQ",
        DESC("Indicates that a command issued with the \"Next Command\" functionalit"
        "y has been issued and that a new command may be initiated with a write"
        " to the PXP_NEXT register.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_ERROR_ID",
        DESC("Indicates the AXI ID of the failing bus operation.")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LUT_DMA_LOAD_DONE_IRQ",
        DESC("Indicates that the LUT DMA transfer has completed.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLOCKY",
        DESC("Indicates the X coordinate of the block currently being rendered.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BLOCKX",
        DESC("Indicates the X coordinate of the block currently being rendered.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_CTRL.
static const field_t hw_pxp_out_ctrl[] =
{
    {
        "FORMAT",
        DESC("Output framebuffer format.")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACED_OUTPUT",
        DESC("Determines how the PXP writes it's output data.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA_OUTPUT",
        DESC("Indicates that alpha component in output buffer pixels should be overw"
        "ritten by PXP_OUT_CTRL[ALPHA].")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA",
        DESC("When generating an output buffer with an alpha component, the value in"
        " this field will be used when enabled to override the alpha passed thr"
        "ough the pixel data pipeline.")
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_BUF.
static const field_t hw_pxp_out_buf[] =
{
    {
        "ADDR",
        DESC("Current address pointer for the output frame buffer.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_BUF2.
static const field_t hw_pxp_out_buf2[] =
{
    {
        "ADDR",
        DESC("Current address pointer for the output frame buffer.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_PITCH.
static const field_t hw_pxp_out_pitch[] =
{
    {
        "PITCH",
        DESC("Indicates the number of bytes in memory between two vertically adjacen"
        "t pixels.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_LRC.
static const field_t hw_pxp_out_lrc[] =
{
    {
        "Y",
        DESC("Indicates the number of vertical PIXELS in the output surface (non-rot"
        "ated).")
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "X",
        DESC("Indicates number of horizontal PIXELS in the output surface (non-rotat"
        "ed).")
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_PS_ULC.
static const field_t hw_pxp_out_ps_ulc[] =
{
    {
        "Y",
        DESC("This field indicates the upper left Y-coordinate (in pixels) of the pr"
        "ocessed surface in the output buffer.")
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "X",
        DESC("This field indicates the upper left X-coordinate (in pixels) of the pr"
        "ocessed surface (PS) in the output buffer.")
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_PS_LRC.
static const field_t hw_pxp_out_ps_lrc[] =
{
    {
        "Y",
        DESC("This field indicates the lower right Y-coordinate (in pixels) of the p"
        "rocessed surface in the output frame buffer.")
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "X",
        DESC("This field indicates the lower right X-coordinate (in pixels) of the p"
        "rocessed surface (PS) in the output frame buffer.")
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_AS_ULC.
static const field_t hw_pxp_out_as_ulc[] =
{
    {
        "Y",
        DESC("This field indicates the upper left Y-coordinate (in pixels) of the al"
        "pha surface in the output frame buffer.")
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "X",
        DESC("This field indicates the upper left X-coordinate (in pixels) of the al"
        "pha surface (AS) in the output frame buffer.")
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_AS_LRC.
static const field_t hw_pxp_out_as_lrc[] =
{
    {
        "Y",
        DESC("This field indicates the lower right Y-coordinate (in pixels) of the a"
        "lpha surface in the output frame buffer.")
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "X",
        DESC("This field indicates the lower right X-coordinate (in pixels) of the a"
        "lpha surface (AS) in the output frame buffer.")
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_CTRL.
static const field_t hw_pxp_ps_ctrl[] =
{
    {
        "FORMAT",
        DESC("PS buffer format.")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WB_SWAP",
        DESC("Swap bytes in words.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DECY",
        DESC("Verticle pre decimation filter control.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DECX",
        DESC("Horizontal pre decimation filter control.")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_BUF.
static const field_t hw_pxp_ps_buf[] =
{
    {
        "ADDR",
        DESC("Address pointer for the PS RGB or Y (luma) input buffer.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_UBUF.
static const field_t hw_pxp_ps_ubuf[] =
{
    {
        "ADDR",
        DESC("Address pointer for the PS U/Cb or 2 plane UV Chroma input buffer.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_VBUF.
static const field_t hw_pxp_ps_vbuf[] =
{
    {
        "ADDR",
        DESC("Address pointer for the PS V/Cr Chroma input buffer.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_PITCH.
static const field_t hw_pxp_ps_pitch[] =
{
    {
        "PITCH",
        DESC("Indicates the number of bytes in memory between two vertically adjacen"
        "t pixels.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_BACKGROUND.
static const field_t hw_pxp_ps_background[] =
{
    {
        "COLOR",
        DESC("Background color (in 24bpp format) for any pixels not within the buffe"
        "r range specified by the PS ULC/LRC.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_SCALE.
static const field_t hw_pxp_ps_scale[] =
{
    {
        "XSCALE",
        DESC("This is a two bit integer and 12 bit fractional representation (##.###"
        "#_####_####) of the X scaling factor for the PS source buffer.")
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YSCALE",
        DESC("This is a two bit integer and 12 bit fractional representation (##.###"
        "#_####_####) of the Y scaling factor for the PS source buffer.")
        16, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_OFFSET.
static const field_t hw_pxp_ps_offset[] =
{
    {
        "XOFFSET",
        DESC("This is a 12 bit fractional representation (0.####_####_####) of the X"
        " scaling offset.")
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YOFFSET",
        DESC("This is a 12 bit fractional representation (0.####_####_####) of the Y"
        " scaling offset.")
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_CLRKEYLOW.
static const field_t hw_pxp_ps_clrkeylow[] =
{
    {
        "PIXEL",
        DESC("Low range of color key applied to PS buffer.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_CLRKEYHIGH.
static const field_t hw_pxp_ps_clrkeyhigh[] =
{
    {
        "PIXEL",
        DESC("High range of color key applied to PS buffer.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_CTRL.
static const field_t hw_pxp_as_ctrl[] =
{
    {
        "ALPHA_CTRL",
        DESC("Determines how the alpha value is constructed for this alpha surface.")
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_COLORKEY",
        DESC("Indicates that colorkey functionality is enabled for this alpha surfac"
        "e.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FORMAT",
        DESC("Indicates the input buffer format for AS.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA",
        DESC("Alpha modifier used when the ALPHA_MULTIPLY or ALPHA_OVERRIDE values a"
        "re programmed in PXP_AS_CTRL[ALPHA_CTRL].")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROP",
        DESC("Indicates a raster operation to perform when enabled.")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA_INVERT",
        DESC("Setting this bit to logic 0 will not alter the alpha value.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_BUF.
static const field_t hw_pxp_as_buf[] =
{
    {
        "ADDR",
        DESC("Address pointer for the alpha surface 0 buffer.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_PITCH.
static const field_t hw_pxp_as_pitch[] =
{
    {
        "PITCH",
        DESC("Indicates the number of bytes in memory between two vertically adjacen"
        "t pixels.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_CLRKEYLOW.
static const field_t hw_pxp_as_clrkeylow[] =
{
    {
        "PIXEL",
        DESC("Low range of RGB color key applied to AS buffer.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_CLRKEYHIGH.
static const field_t hw_pxp_as_clrkeyhigh[] =
{
    {
        "PIXEL",
        DESC("High range of RGB color key applied to AS buffer.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC1_COEF0.
static const field_t hw_pxp_csc1_coef0[] =
{
    {
        "Y_OFFSET",
        DESC("Two's compliment amplitude offset implicit in the Y data.")
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UV_OFFSET",
        DESC("Two's compliment phase offset implicit for CbCr data.")
        9, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C0",
        DESC("Two's compliment Y multiplier coefficient.")
        18, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        DESC("Bypass the CSC unit in the scaling engine.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR_MODE",
        DESC("Set to 1 when performing YCbCr conversion to RGB.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC1_COEF1.
static const field_t hw_pxp_csc1_coef1[] =
{
    {
        "C4",
        DESC("Two's compliment Blue U/Cb multiplier coefficient.")
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C1",
        DESC("Two's compliment Red V/Cr multiplier coefficient.")
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC1_COEF2.
static const field_t hw_pxp_csc1_coef2[] =
{
    {
        "C3",
        DESC("Two's complement Green U/Cb multiplier coefficient.")
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C2",
        DESC("Two's complement Green V/Cr multiplier coefficient.")
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_CTRL.
static const field_t hw_pxp_csc2_ctrl[] =
{
    {
        "BYPASS",
        DESC("This bit controls whether the pixels entering the CSC2 unit get conver"
        "ted or not.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_MODE",
        DESC("This field controls how the CSC unit operates on pixels when the CSC i"
        "s not bypassed.")
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF0.
static const field_t hw_pxp_csc2_coef0[] =
{
    {
        "A1",
        DESC("Two's complement coefficient offset.")
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A2",
        DESC("Two's complement coefficient offset.")
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF1.
static const field_t hw_pxp_csc2_coef1[] =
{
    {
        "A3",
        DESC("Two's complement coefficient offset.")
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "B1",
        DESC("Two's complement coefficient offset.")
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF2.
static const field_t hw_pxp_csc2_coef2[] =
{
    {
        "B2",
        DESC("Two's complement coefficient offset.")
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "B3",
        DESC("Two's complement coefficient offset.")
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF3.
static const field_t hw_pxp_csc2_coef3[] =
{
    {
        "C1",
        DESC("Two's complement coefficient offset.")
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C2",
        DESC("Two's complement coefficient offset.")
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF4.
static const field_t hw_pxp_csc2_coef4[] =
{
    {
        "C3",
        DESC("Two's complement coefficient offset.")
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1",
        DESC("Two's complement coefficient integer offset to be added.")
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF5.
static const field_t hw_pxp_csc2_coef5[] =
{
    {
        "D2",
        DESC("Two's complement D1 coefficient integer offset to be added.")
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3",
        DESC("Two's complement coefficient integer offset to be added.")
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_LUT_CTRL.
static const field_t hw_pxp_lut_ctrl[] =
{
    {
        "DMA_START",
        DESC("Setting this bit will result in the DMA operation to load the PXP LUT "
        "memory based on PXP_LUT_ADDR_NUM_BYTES, PXP_LUT_ADDR_ADDR, and PXP_LUT"
        "_MEM_ADDR.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVALID",
        DESC("Invalidate the cache LRU and valid bits.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LRU_UPD",
        DESC("Least Recently Used Policy Update Control: 1=> block LRU update for hi"
        "t after miss.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL_8KB",
        DESC("Selects which 8KB bank of memory to use for direct 12bpp lookup modes.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUT_MODE",
        DESC("Select the output mode of operation for  the LUT resource.")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOKUP_MODE",
        DESC("Configure the input address for the 16KB  LUT memory.")
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        DESC("Setting this bit will bypass the LUT memory resource completely.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_LUT_ADDR.
static const field_t hw_pxp_lut_addr[] =
{
    {
        "ADDR",
        DESC("LUT indexed address pointer.")
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM_BYTES",
        DESC("Indicates the number of bytes to load via a DMA operation.")
        16, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_LUT_DATA.
static const field_t hw_pxp_lut_data[] =
{
    {
        "DATA",
        DESC("Writing this field will load 4 bytes, aligned to four byte boundaries,"
        " of data indexed by the ADDR field of the PXP_LUT_CTRL register.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_LUT_EXTMEM.
static const field_t hw_pxp_lut_extmem[] =
{
    {
        "ADDR",
        DESC("This register contains the external memory address used for LUT memory"
        " operation.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CFA.
static const field_t hw_pxp_cfa[] =
{
    {
        "DATA",
        DESC("This register contains the Color Filter  Array pattern for decimation "
        "of RGBW4444 16 bit pixels  to individual R, G, B, W values.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST_CTRL.
static const field_t hw_pxp_hist_ctrl[] =
{
    {
        "STATUS",
        DESC("Indicates which histogram matched the processed bitmap.")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PANEL_MODE",
        DESC("Specifies the EPDC panel grayscale depth.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST2_PARAM.
static const field_t hw_pxp_hist2_param[] =
{
    {
        "VALUE0",
        DESC("Black value for 2-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE1",
        DESC("White value for 2-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST4_PARAM.
static const field_t hw_pxp_hist4_param[] =
{
    {
        "VALUE0",
        DESC("GRAY0 (Black) value for 4-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE1",
        DESC("GRAY1 value for 4-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE2",
        DESC("GRAY2 value for 4-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE3",
        DESC("GRAY3 (White) value for 4-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST8_PARAM0.
static const field_t hw_pxp_hist8_param0[] =
{
    {
        "VALUE0",
        DESC("GRAY0 (Black) value for 8-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE1",
        DESC("GRAY1 value for 8-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE2",
        DESC("GRAY2 value for 8-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE3",
        DESC("GRAY3 value for 8-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST8_PARAM1.
static const field_t hw_pxp_hist8_param1[] =
{
    {
        "VALUE4",
        DESC("GRAY4 value for 8-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE5",
        DESC("GRAY5 value for 8-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE6",
        DESC("GRAY6 value for 8-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE7",
        DESC("GRAY7 (White) value for 8-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST16_PARAM0.
static const field_t hw_pxp_hist16_param0[] =
{
    {
        "VALUE0",
        DESC("GRAY0 (Black) value for 16-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE1",
        DESC("GRAY1 value for 16-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE2",
        DESC("GRAY2 value for 16-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE3",
        DESC("GRAY3 value for 16-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST16_PARAM1.
static const field_t hw_pxp_hist16_param1[] =
{
    {
        "VALUE4",
        DESC("GRAY4 value for 16-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE5",
        DESC("GRAY5 value for 16-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE6",
        DESC("GRAY6 value for 16-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE7",
        DESC("GRAY7 value for 16-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST16_PARAM2.
static const field_t hw_pxp_hist16_param2[] =
{
    {
        "VALUE8",
        DESC("GRAY8 value for 16-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE9",
        DESC("GRAY9 value for 16-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE10",
        DESC("GRAY10 value for 16-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE11",
        DESC("GRAY11 value for 16-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST16_PARAM3.
static const field_t hw_pxp_hist16_param3[] =
{
    {
        "VALUE12",
        DESC("GRAY12 value for 16-level histogram")
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE13",
        DESC("GRAY13 value for 16-level histogram")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE14",
        DESC("GRAY14 value for 16-level histogram")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALUE15",
        DESC("GRAY15 (White) value for 16-level histogram")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_POWER.
static const field_t hw_pxp_power[] =
{
    {
        "LUT_LP_STATE_WAY0_BANK0",
        DESC("Select the low power state of the LUT's WAY0-BANK0 memory.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_LP_STATE_WAY0_BANKN",
        DESC("Select the low power state of the LUT's WAY0-BANK1,2,3 memory.")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_LP_STATE_WAY1_BANKN",
        DESC("Select the low power state of the LUT's WAY0-BANK0,1,2,3 memory.")
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROT_MEM_LP_STATE",
        DESC("Select the low power state of the ROT memory.")
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTRL",
        DESC("This register contains power control for  the PXP.")
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_NEXT.
static const field_t hw_pxp_next[] =
{
    {
        "ENABLED",
        DESC("Indicates that the \"next frame\" functionality has been enabled.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "POINTER",
        DESC("A pointer to a data structure containing register values to be used wh"
        "en processing the next frame.")
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a PXP module.
static const reg_t hw_pxp[] =
{
    {
        "CTRL",
        DESC("The CTRL register contains controls for the PXP module.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pxp_ctrl
    },
    {
        "STAT",
        DESC("The PXP Interrupt Status register provides interrupt status informatio"
        "n.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_stat
    },
    {
        "OUT_CTRL",
        DESC("The OUT_CTRL register contains controls for the Output Buffer.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_out_ctrl
    },
    {
        "OUT_BUF",
        DESC("Output Framebuffer Pointer.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_out_buf
    },
    {
        "OUT_BUF2",
        DESC("Output Framebuffer Pointer #2.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_out_buf2
    },
    {
        "OUT_PITCH",
        DESC("This register contains the output buffer pitch in bytes.")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_out_pitch
    },
    {
        "OUT_LRC",
        DESC("This register contains the size, or lower right coordinate, of the out"
        "put buffer NOT rotated.")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_out_lrc
    },
    {
        "OUT_PS_ULC",
        DESC("This register contains the upper left pixel coordinate for the Process"
        "ed Surface in the OUTPUT buffer.")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_out_ps_ulc
    },
    {
        "OUT_PS_LRC",
        DESC("This register contains the lower right extent for the Processed Surfac"
        "e in the OUTPUT buffer.")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_out_ps_lrc
    },
    {
        "OUT_AS_ULC",
        DESC("This register contains the upper left location for the Alpha Surface i"
        "n the output buffer.")
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_out_as_ulc
    },
    {
        "OUT_AS_LRC",
        DESC("This register contains the lower right extent for Alpha Surface in the"
        " output buffer.")
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_out_as_lrc
    },
    {
        "PS_CTRL",
        DESC("The PS_CTRL register contains controls for the Processed Surface Buffe"
        "r.")
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_ps_ctrl
    },
    {
        "PS_BUF",
        DESC("PS Input Buffer Address.")
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_buf
    },
    {
        "PS_UBUF",
        DESC("PS Chroma (U/Cb/UV) Input Buffer Address.")
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_ubuf
    },
    {
        "PS_VBUF",
        DESC("PS Chroma (V/Cr) Input Buffer Address.")
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_vbuf
    },
    {
        "PS_PITCH",
        DESC("This register contains the processed surface pitch in bytes.")
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_pitch
    },
    {
        "PS_BACKGROUND",
        DESC("PS Background Pixel Color.")
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_background
    },
    {
        "PS_SCALE",
        DESC("PS Scale Factor.")
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_ps_scale
    },
    {
        "PS_OFFSET",
        DESC("PS Scale Offset.")
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_ps_offset
    },
    {
        "PS_CLRKEYLOW",
        DESC("This register contains the color key low value for the PS buffer.")
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_clrkeylow
    },
    {
        "PS_CLRKEYHIGH",
        DESC("This register contains the color key high value for the PS buffer.")
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_clrkeyhigh
    },
    {
        "AS_CTRL",
        DESC("This register contains buffer control for the Alpha Surface 0 input bu"
        "ffer.")
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pxp_as_ctrl
    },
    {
        "AS_BUF",
        DESC("Alpha Surface 0 Buffer Address Pointer.")
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_as_buf
    },
    {
        "AS_PITCH",
        DESC("This register contains the alpha surface pitch in bytes.")
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_as_pitch
    },
    {
        "AS_CLRKEYLOW",
        DESC("This register contains the color key low value for the AS buffer.")
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_as_clrkeylow
    },
    {
        "AS_CLRKEYHIGH",
        DESC("This register contains the color key high value for the AS buffer.")
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_as_clrkeyhigh
    },
    {
        "CSC1_COEF0",
        DESC("This register contains color space conversion coefficients in two's co"
        "mpliment notation.")
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pxp_csc1_coef0
    },
    {
        "CSC1_COEF1",
        DESC("This register contains color space conversion coefficients in two's co"
        "mpliment notation.")
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_csc1_coef1
    },
    {
        "CSC1_COEF2",
        DESC("This register contains color space conversion coefficients in two's co"
        "mpliment notation.")
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_csc1_coef2
    },
    {
        "CSC2_CTRL",
        DESC("This register contains the control registers to configure the CSC modu"
        "le.")
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_csc2_ctrl
    },
    {
        "CSC2_COEF0",
        DESC("This register contains color space conversion coefficients in two's co"
        "mplement notation.")
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_csc2_coef0
    },
    {
        "CSC2_COEF1",
        DESC("This register contains color space conversion coefficients in two's co"
        "mplement notation.")
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_csc2_coef1
    },
    {
        "CSC2_COEF2",
        DESC("This register contains color space conversion coefficients in two's co"
        "mplement notation.")
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_csc2_coef2
    },
    {
        "CSC2_COEF3",
        DESC("This register contains color space conversion coefficients in two's co"
        "mplement notation.")
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_csc2_coef3
    },
    {
        "CSC2_COEF4",
        DESC("This register contains color space conversion coefficients in two's co"
        "mplement notation.")
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_csc2_coef4
    },
    {
        "CSC2_COEF5",
        DESC("This register contains color space conversion coefficients in two's co"
        "mplement notation.")
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_csc2_coef5
    },
    {
        "LUT_CTRL",
        DESC("This register is used to access/control the Monochrome Lookup table.")
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_pxp_lut_ctrl
    },
    {
        "LUT_ADDR",
        DESC("This register is used to access/control the Monochrome Lookup table.")
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_lut_addr
    },
    {
        "LUT_DATA",
        DESC("This register is used to load data into the lookup table.")
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_lut_data
    },
    {
        "LUT_EXTMEM",
        DESC("For DMA LUT memory loads, this is the base address from which data wil"
        "l be sourced to store into the LUT memory array.")
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_lut_extmem
    },
    {
        "CFA",
        DESC("There are sixteen 2 bit values in this register each mapping a selecte"
        "d component to the output pixel.")
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_cfa
    },
    {
        "HIST_CTRL",
        DESC("Provides control and status registers for the PXP's histogram classifi"
        "cation algorithm.")
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_hist_ctrl
    },
    {
        "HIST2_PARAM",
        DESC("This register specifies the valid values for a 2-level histogram.")
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_hist2_param
    },
    {
        "HIST4_PARAM",
        DESC("This register specifies the valid values for a 4-level histogram.")
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_hist4_param
    },
    {
        "HIST8_PARAM0",
        DESC("This register specifies four of the valid values for an 8-level histog"
        "ram.")
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_hist8_param0
    },
    {
        "HIST8_PARAM1",
        DESC("This register specifies four of the valid values for an 8-level histog"
        "ram.")
        4, // Width in bytes
        0x000002d0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_hist8_param1
    },
    {
        "HIST16_PARAM0",
        DESC("This register specifies four of the valid values for a 16-level histog"
        "ram.")
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_hist16_param0
    },
    {
        "HIST16_PARAM1",
        DESC("This register specifies four of the valid values for a 16-level histog"
        "ram.")
        4, // Width in bytes
        0x000002f0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_hist16_param1
    },
    {
        "HIST16_PARAM2",
        DESC("This register specifies four of the valid values for a 16-level histog"
        "ram.")
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_hist16_param2
    },
    {
        "HIST16_PARAM3",
        DESC("This register specifies four of the valid values for a 16-level histog"
        "ram.")
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_hist16_param3
    },
    {
        "POWER",
        DESC("")
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pxp_power
    },
    {
        "NEXT",
        DESC("This register contains a pointer to a data structure used to reload th"
        "e PXP registers at the end of the current frame.")
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_next
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark QOS
#endif

// Bitfields in register QOS_CTRL.
static const field_t hw_qos_ctrl[] =
{
    {
        "EMI_PRIORITY_MODE",
        DESC("Set this bit to one to enable QoS and priority values to be set separa"
        "tely for the AXI fabric and EMI.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XLATE_AXI_MODE",
        DESC("This bit selects the way in which AXI QoS information is translated in"
        "to EMI priority values.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPDC_PRIORITY_BOOST",
        DESC("Set this field to enable a feedback path that allows the EPDC to reque"
        "st higher priority for its accesses when needed.")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF_PRIORITY_BOOST",
        DESC("Set this field to enable a feedback path that allows the eLCDIF to req"
        "uest higher priority for its accesses when needed.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        DESC("This bit must be set to zero for normal operation.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        DESC("Set to zero for normal operation.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QOS_AXI_QOS0.
static const field_t hw_qos_axi_qos0[] =
{
    {
        "M0_AWQOS",
        DESC("Specifies the QOS level for the write commands on MasterID 0.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M0_ARQOS",
        DESC("Specifies the QOS level for the read commands on MasterID 0.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_0_AWQOS",
        DESC("Specifies the QOS level for the write commands on MasterID 1.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_0_ARQOS",
        DESC("Specifies the QOS level for the read commands on MasterID 1.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_1_AWQOS",
        DESC("Specifies the QOS level for the write commands on MasterID 2.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_1_ARQOS",
        DESC("Specifies the QOS level for the read commands on MasterID 2.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_2_AWQOS",
        DESC("Specifies the QOS level for the write commands on MasterID 3.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_2_ARQOS",
        DESC("Specifies the QOS level for the read commands on MasterID 3.")
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QOS_AXI_QOS1.
static const field_t hw_qos_axi_qos1[] =
{
    {
        "M2_AWQOS",
        DESC("Specifies the QOS level for the write commands on MasterID 4.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2_ARQOS",
        DESC("Specifies the QOS level for the read commands on MasterID 4.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M3_AWQOS",
        DESC("Specifies the QOS level for the write commands on MasterID 5.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M3_ARQOS",
        DESC("Specifies the QOS level for the read commands on MasterID 5.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_AWQOS",
        DESC("Specifies the QOS level for the write commands on MasterID 6.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_ARQOS",
        DESC("Specifies the QOS level for the read commands on MasterID 6.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M5_AWQOS",
        DESC("Specifies the QOS level for the write commands on MasterID 7.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M5_ARQOS",
        DESC("Specifies the QOS level for the read commands on MasterID 7.")
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QOS_AXI_QOS2.
static const field_t hw_qos_axi_qos2[] =
{
    {
        "M6_AWQOS",
        DESC("Specifies the QOS level for the write commands on MasterID 8.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M6_ARQOS",
        DESC("Specifies the QOS level for the read commands on MasterID 8.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M7_AWQOS",
        DESC("Specifies the QOS level for the write commands on MasterID 9.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M7_ARQOS",
        DESC("Specifies the QOS level for the read commands on MasterID 9.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M8_AWQOS",
        DESC("Specifies the QOS level for the write commands on MasterID 10.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M8_ARQOS",
        DESC("Specifies the QOS level for the read commands on MasterID 10.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M9_AWQOS",
        DESC("Specifies the QOS level for the write commands on MasterID 10.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M9_ARQOS",
        DESC("Specifies the QOS level for the read commands on MasterID 11.")
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QOS_EMI_PRIORITY0.
static const field_t hw_qos_emi_priority0[] =
{
    {
        "M0_WR",
        DESC("Specifies the priority level for the write commands on MasterID 0.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M0_RD",
        DESC("Specifies the priority level for the read commands on MasterID 0.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_0_WR",
        DESC("Specifies the priority level for the write commands on MasterID 1.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_0_RD",
        DESC("Specifies the priority level for the read commands on MasterID 1.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_1_WR",
        DESC("Specifies the priority level for the write commands on MasterID 2.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_1_RD",
        DESC("Specifies the priority level for the read commands on MasterID 2.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_2_WR",
        DESC("Specifies the priority level for the write commands on MasterID 3.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_2_RD",
        DESC("Specifies the priority level for the read commands on MasterID 3.")
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QOS_EMI_PRIORITY1.
static const field_t hw_qos_emi_priority1[] =
{
    {
        "M2_WR",
        DESC("Specifies the priority level for the write commands on MasterID 4.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2_RD",
        DESC("Specifies the priority level for the read commands on MasterID 4.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M3_WR",
        DESC("Specifies the priority level for the write commands on MasterID 5.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M3_RD",
        DESC("Specifies the priority level for the read commands on MasterID 5.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_WR",
        DESC("Specifies the priority level for the write commands on MasterID 6.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_RD",
        DESC("Specifies the priority level for the read commands on MasterID 6.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M5_WR",
        DESC("Specifies the priority level for the write commands on MasterID 7.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M5_RD",
        DESC("Specifies the priority level for the read commands on MasterID 7.")
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QOS_EMI_PRIORITY2.
static const field_t hw_qos_emi_priority2[] =
{
    {
        "M6_WR",
        DESC("Specifies the priority level for the write commands on MasterID 8.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M6_RD",
        DESC("Specifies the priority level for the read commands on MasterID 8.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M7_WR",
        DESC("Specifies the priority level for the write commands on MasterID 9.")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M7_RD",
        DESC("Specifies the priority level for the read commands on MasterID 9.")
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M8_WR",
        DESC("Specifies the priority level for the write commands on MasterID 10.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M8_RD",
        DESC("Specifies the priority level for the read commands on MasterID 10.")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M9_WR",
        DESC("Specifies the priority level for the write commands on MasterID 10.")
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M9_RD",
        DESC("Specifies the priority level for the read commands on MasterID 11.")
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QOS_DISABLE.
static const field_t hw_qos_disable[] =
{
    {
        "M1_0_DIS",
        DESC("Setting this bit disables the interface between master1_0 and the AXI "
        "fabric.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_1_DIS",
        DESC("Setting this bit disables the interface between master1_1 and the AXI "
        "fabric.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_2_DIS",
        DESC("Setting this bit disables the interface between master1_2 and the AXI "
        "fabric.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2_DIS",
        DESC("Setting this bit disables the interface between master2 and the AXI fa"
        "bric.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M3_DIS",
        DESC("Setting this bit disables the interface between master3 and the AXI fa"
        "bric.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_DIS",
        DESC("Setting this bit disables the interface between master4 and the AXI fa"
        "bric.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M5_DIS",
        DESC("Setting this bit disables the interface between master5 and the AXI fa"
        "bric.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M6_DIS",
        DESC("Setting this bit disables the interface between master6 and the AXI fa"
        "bric.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M7_DIS",
        DESC("Setting this bit disables the interface between master7 and the AXI fa"
        "bric.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M8_DIS",
        DESC("Setting this bit disables the interface between master8 and the AXI fa"
        "bric.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M9_DIS",
        DESC("Setting this bit disables the interface between master9 and the AXI fa"
        "bric.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M1_0_DIS_STAT",
        DESC("This bit indicates the enable/disable status for master port1_0 on the"
        " AXI fabric.")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M1_1_DIS_STAT",
        DESC("This bit indicates the enable/disable status for master port1_1 on the"
        " AXI fabric.")
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M1_2_DIS_STAT",
        DESC("This bit indicates the enable/disable status for master port1_2 on the"
        " AXI fabric.")
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M2_DIS_STAT",
        DESC("This bit indicates the enable/disable status for master port0 on the A"
        "XI fabric.")
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M3_DIS_STAT",
        DESC("This bit indicates the enable/disable status for master port0 on the A"
        "XI fabric.")
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M4_DIS_STAT",
        DESC("This bit indicates the enable/disable status for master port0 on the A"
        "XI fabric.")
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M5_DIS_STAT",
        DESC("This bit indicates the enable/disable status for master port0 on the A"
        "XI fabric.")
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M6_DIS_STAT",
        DESC("This bit indicates the enable/disable status for master port0 on the A"
        "XI fabric.")
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M7_DIS_STAT",
        DESC("This bit indicates the enable/disable status for master port0 on the A"
        "XI fabric.")
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M8_DIS_STAT",
        DESC("This bit indicates the enable/disable status for master port0 on the A"
        "XI fabric.")
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M9_DIS_STAT",
        DESC("This bit indicates the enable/disable status for master port0 on the A"
        "XI fabric.")
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QOS_VERSION.
static const field_t hw_qos_version[] =
{
    {
        "STEP",
        DESC("Fixed read-only value reflecting the stepping of the RTL version.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        DESC("Fixed read-only value reflecting the MINOR field of the RTL version.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        DESC("Fixed read-only value reflecting the MAJOR field of the RTL version.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a QOS module.
static const reg_t hw_qos[] =
{
    {
        "CTRL",
        DESC("The Control Register specifies the reset state and the interrupt contr"
        "ols for the Performance Monitor.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_qos_ctrl
    },
    {
        "AXI_QOS0",
        DESC("This register specifies the AWQOS and ARQOS parameters for masters 0-3"
        ".")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_qos_axi_qos0
    },
    {
        "AXI_QOS1",
        DESC("This register specifies the AWQOS and ARQOS parameters for masters 4-7"
        ".")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_qos_axi_qos1
    },
    {
        "AXI_QOS2",
        DESC("This register specifies the AWQOS and ARQOS parameters for masters 8-1"
        "1.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_qos_axi_qos2
    },
    {
        "EMI_PRIORITY0",
        DESC("For EMI manual priority mode, this register specifies the AWPRIORITY a"
        "nd ARPRIORITY parameters for masters 0-3.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_qos_emi_priority0
    },
    {
        "EMI_PRIORITY1",
        DESC("For EMI manual priority mode, this register specifies the AWPRIORITY a"
        "nd ARPRIORITY parameters for masters 4-7.")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_qos_emi_priority1
    },
    {
        "EMI_PRIORITY2",
        DESC("For EMI manual priority mode, this register specifies the AWPRIORITY a"
        "nd ARPRIORITY parameters for masters 8-11.")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_qos_emi_priority2
    },
    {
        "DISABLE",
        DESC("This register allows disabling of the individual master ports of the A"
        "XI fabric.")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_qos_disable
    },
    {
        "VERSION",
        DESC("This register always returns a known read value for debug purposes it "
        "indicates the version of the block.")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_qos_version
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark RNG
#endif

// Bitfields in register RNG_VER.
static const field_t hw_rng_ver[] =
{
    {
        "MINOR",
        DESC("Subjiect to change.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        DESC("This field is always set to 0x02.")
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TYPE",
        DESC("")
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RNG_CMD.
static const field_t hw_rng_cmd[] =
{
    {
        "ST",
        DESC("Initiates a self test of the RNGB's internal logic.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GS",
        DESC("Initiates the seed generation process.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CI",
        DESC("Clears the RNGB interrupt if an error is not present.")
        4, // LSB
        4, // MSB
        false, // Readable
        true // Writable
    },
    {
        "CE",
        DESC("Clears the errors in the RNG_ESR register and the RNGB interrupt.This "
        "bit is self-clearing.")
        5, // LSB
        5, // MSB
        false, // Readable
        true // Writable
    },
    {
        "SR",
        DESC("Performs a software reset of the RNGB.")
        6, // LSB
        6, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RNG_CR.
static const field_t hw_rng_cr[] =
{
    {
        "FUFMOD",
        DESC("Controls the RNGB's response to a FIFO underflow condition.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AR",
        DESC("Setting this bit allows the RNGB to automatically generate a new seed "
        "whenever one is needed.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASKDONE",
        DESC("Masks interrupts generated upon completion of seed and self test modes"
        ".")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASKERR",
        DESC("Masks interrupts generated by errors in the RNGB.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RNG_SR.
static const field_t hw_rng_sr[] =
{
    {
        "BUSY",
        DESC("Reflects the current state of RNGB.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SLP",
        DESC("Indicates if the RNGB is in sleep mode.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RS",
        DESC("Indicates the RNGB needs to be reseeded.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STDN",
        DESC("Indicates the self test is complete.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDN",
        DESC("Indicates the RNG has generated the first seed.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NSDN",
        DESC("Indicates that a new seed is ready for use during the next seed genera"
        "tion process.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FIFO_LVL",
        DESC("Indicates the number of random words currently in the output FIFO.")
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FIFO_SIZE",
        DESC("Size of the FIFO, and maximum possible FIFO level.")
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR",
        DESC("Indicates an error was detected in the RNGB.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ST_PF",
        DESC("Indicates Pass or Fail status of the TRNG, PRNG, and RESEED self tests"
        ",  Bit 23 - TRNG self test pass/fail  Bit 22 - PRNG self test pass/fai"
        "l  Bit 21 - RESEED self test pass/fail")
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATPF",
        DESC("Indicates pass or fail status of the various statistics tests on the l"
        "ast seed generated.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RNG_ESR.
static const field_t hw_rng_esr[] =
{
    {
        "LFE",
        DESC("When this bit is set, the interrupt generated was caused by a failure "
        "of one of the LFSRs in one of the RNGB's three entropy sources.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSCE",
        DESC("Indicates the oscillator in the RNG may be broken.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STE",
        DESC("Indicates the RNGB has failed the most recent self test.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SATE",
        DESC("Indicates if RNGB has failed the statistical tests for the last genera"
        "ted seed.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FUFE",
        DESC("Indicates the RNGB has experienced a FIFO underflow condition resultin"
        "g in the last random data read being unreliable.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register RNG_OUT.
static const field_t hw_rng_out[] =
{
    {
        "RANDOUT",
        DESC("")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a RNG module.
static const reg_t hw_rng[] =
{
    {
        "VER",
        DESC("The read-only RNG_VER register contains the current version of the RNG"
        "B.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_rng_ver
    },
    {
        "CMD",
        DESC("RNG_CMD controls the RNG's operating modes and interrupt status.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_rng_cmd
    },
    {
        "CR",
        DESC("Through use of this register, the RNGB can be programmed to provide sl"
        "ightly different functionality based on its desired use.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_rng_cr
    },
    {
        "SR",
        DESC("The RNGBSR is a read-only register which reflects the internal status "
        "of the RNGB.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        11, // Number of bitfields
        hw_rng_sr
    },
    {
        "ESR",
        DESC("")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_rng_esr
    },
    {
        "OUT",
        DESC("The RNGBOUT provides temporary storage for random data generated by th"
        "e RNGB.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_rng_out
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ROMC
#endif

// Bitfields in register ROMC_ROMPATCH0D.
static const field_t hw_romc_rompatch0d[] =
{
    {
        "DATAX",
        DESC("Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH1D.
static const field_t hw_romc_rompatch1d[] =
{
    {
        "DATAX",
        DESC("Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH2D.
static const field_t hw_romc_rompatch2d[] =
{
    {
        "DATAX",
        DESC("Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH3D.
static const field_t hw_romc_rompatch3d[] =
{
    {
        "DATAX",
        DESC("Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH4D.
static const field_t hw_romc_rompatch4d[] =
{
    {
        "DATAX",
        DESC("Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH5D.
static const field_t hw_romc_rompatch5d[] =
{
    {
        "DATAX",
        DESC("Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH6D.
static const field_t hw_romc_rompatch6d[] =
{
    {
        "DATAX",
        DESC("Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH7D.
static const field_t hw_romc_rompatch7d[] =
{
    {
        "DATAX",
        DESC("Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHCNTL.
static const field_t hw_romc_rompatchcntl[] =
{
    {
        "DATAFIX",
        DESC("Data Fix Enable - Controls the use of the first 8 address comparators "
        "for 1-word data fix or for code patch routine.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS",
        DESC("ROMC Disable -- This bit, when set, disables all ROMC operations.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHENH.
static const field_t hw_romc_rompatchenh[] =
{
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHENL.
static const field_t hw_romc_rompatchenl[] =
{
    {
        "ENABLE",
        DESC("Enable Address Comparator - This bit enables the corresponding address"
        " comparator to trigger an event.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH0A.
static const field_t hw_romc_rompatch0a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH1A.
static const field_t hw_romc_rompatch1a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH2A.
static const field_t hw_romc_rompatch2a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH3A.
static const field_t hw_romc_rompatch3a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH4A.
static const field_t hw_romc_rompatch4a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH5A.
static const field_t hw_romc_rompatch5a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH6A.
static const field_t hw_romc_rompatch6a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH7A.
static const field_t hw_romc_rompatch7a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH8A.
static const field_t hw_romc_rompatch8a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH9A.
static const field_t hw_romc_rompatch9a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH10A.
static const field_t hw_romc_rompatch10a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH11A.
static const field_t hw_romc_rompatch11a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH12A.
static const field_t hw_romc_rompatch12a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH13A.
static const field_t hw_romc_rompatch13a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH14A.
static const field_t hw_romc_rompatch14a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH15A.
static const field_t hw_romc_rompatch15a[] =
{
    {
        "THUMBX",
        DESC("THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        DESC("Address Comparator Registers - Indicates the memory address to be watc"
        "hed.")
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHSR.
static const field_t hw_romc_rompatchsr[] =
{
    {
        "SOURCE",
        DESC("ROMC Source Number - Binary encoding of the number of the address comp"
        "arator which has an address match in the most recent patch event on RO"
        "MC AHB.")
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW",
        DESC("ROMC AHB Multiple Address Comparator matches Indicator - Indicates tha"
        "t multiple address comparator matches occurred.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ROMC module.
static const reg_t hw_romc[] =
{
    {
        "ROMPATCH0D",
        DESC("The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.")
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch0d
    },
    {
        "ROMPATCH1D",
        DESC("The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.")
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch1d
    },
    {
        "ROMPATCH2D",
        DESC("The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.")
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch2d
    },
    {
        "ROMPATCH3D",
        DESC("The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.")
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch3d
    },
    {
        "ROMPATCH4D",
        DESC("The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.")
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch4d
    },
    {
        "ROMPATCH5D",
        DESC("The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.")
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch5d
    },
    {
        "ROMPATCH6D",
        DESC("The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.")
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch6d
    },
    {
        "ROMPATCH7D",
        DESC("The ROMC data registers (ROMC_ROMPATCHD7 through ROMC_ROMPATCHD0) stor"
        "e the data to use for the 8 1-word data fix events.")
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch7d
    },
    {
        "ROMPATCHCNTL",
        DESC("The ROMC control register (ROMC_ROMPATCHCNTL) contains the block disab"
        "le bit and the data fix enable bits.")
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatchcntl
    },
    {
        "ROMPATCHENH",
        DESC("The ROMC enable register high (ROMC_ROMPATCHENH) and ROMC enable regis"
        "ter low (ROMC_ROMPATCHENL) control whether or not the associated addre"
        "ss comparator can trigger a opcode patch or data fix event.")
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_romc_rompatchenh
    },
    {
        "ROMPATCHENL",
        DESC("The ROMC enable register high (ROMC_ROMPATCHENH) and ROMC enable regis"
        "ter low (ROMC_ROMPATCHENL) control whether or not the associated addre"
        "ss comparator can trigger a opcode patch or data fix event.")
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatchenl
    },
    {
        "ROMPATCH0A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch0a
    },
    {
        "ROMPATCH1A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch1a
    },
    {
        "ROMPATCH2A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch2a
    },
    {
        "ROMPATCH3A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch3a
    },
    {
        "ROMPATCH4A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch4a
    },
    {
        "ROMPATCH5A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch5a
    },
    {
        "ROMPATCH6A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch6a
    },
    {
        "ROMPATCH7A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch7a
    },
    {
        "ROMPATCH8A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch8a
    },
    {
        "ROMPATCH9A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch9a
    },
    {
        "ROMPATCH10A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch10a
    },
    {
        "ROMPATCH11A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch11a
    },
    {
        "ROMPATCH12A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch12a
    },
    {
        "ROMPATCH13A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch13a
    },
    {
        "ROMPATCH14A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch14a
    },
    {
        "ROMPATCH15A",
        DESC("The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.")
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch15a
    },
    {
        "ROMPATCHSR",
        DESC("The ROMC status register (ROMC_ROMPATCHSR) indicates the current state"
        " of the ROMC and the source number of the most recent address comparat"
        "or event.")
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatchsr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SDMAARM
#endif

// Bitfields in register SDMAARM_MC0PTR.
static const field_t hw_sdmaarm_mc0ptr[] =
{
    {
        "MC0PTR",
        DESC("Channel 0 Pointer contains the 32-bit address, in ARM platform memory,"
        " of channel 0 control block (the boot channel).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_INTR.
static const field_t hw_sdmaarm_intr[] =
{
    {
        "HI",
        DESC("The ARM platform Interrupts register contains the 32 HI[i] bits.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_STOP_STAT.
static const field_t hw_sdmaarm_stop_stat[] =
{
    {
        "HE",
        DESC("This 32-bit register gives access to the ARM platform Enable bits.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_HSTART.
static const field_t hw_sdmaarm_hstart[] =
{
    {
        "HSTART",
        DESC("The HSTART/HE registers are 32 bits wide with one bit for every channe"
        "l.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTOVR.
static const field_t hw_sdmaarm_evtovr[] =
{
    {
        "EO",
        DESC("The Channel Event Override register contains the 32 EO[i] bits.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_DSPOVR.
static const field_t hw_sdmaarm_dspovr[] =
{
    {
        "DO",
        DESC("This register is reserved.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_HOSTOVR.
static const field_t hw_sdmaarm_hostovr[] =
{
    {
        "HO",
        DESC("The Channel ARM platform Override register contains the 32 HO[i] bits.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTPEND.
static const field_t hw_sdmaarm_evtpend[] =
{
    {
        "EP",
        DESC("The Channel Event Pending register contains the 32 EP[i] bits.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_RESET.
static const field_t hw_sdmaarm_reset[] =
{
    {
        "RESET",
        DESC("When set, this bit causes the SDMA to be held in a software reset.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RESCHED",
        DESC("When set, this bit forces the SDMA to reschedule as if a script had ex"
        "ecuted a done instruction.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTERR.
static const field_t hw_sdmaarm_evterr[] =
{
    {
        "CHNERR",
        DESC("This register is used by the SDMA to warn the ARM platform when an inc"
        "oming DMA request was detected and it triggers a channel that is alrea"
        "dy pending or being serviced.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_INTRMASK.
static const field_t hw_sdmaarm_intrmask[] =
{
    {
        "HIMASK",
        DESC("The Interrupt Mask Register contains 32 interrupt generation mask bits"
        ".")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_PSW.
static const field_t hw_sdmaarm_psw[] =
{
    {
        "CCR",
        DESC("The Current Channel Register indicates the number of the channel that "
        "is being executed by the SDMA.")
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CCP",
        DESC("The Current Channel Priority indicates the priority of the current act"
        "ive channel.")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCR",
        DESC("The Next Channel Register indicates the number of the next scheduled p"
        "ending channel with the highest priority.")
        8, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCP",
        DESC("The Next Channel Priority gives the next pending channel priority.")
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTERRDBG.
static const field_t hw_sdmaarm_evterrdbg[] =
{
    {
        "CHNERR",
        DESC("This register is the same as EVTERR, except reading it does not clear "
        "its contents.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CONFIG.
static const field_t hw_sdmaarm_config[] =
{
    {
        "CSM",
        DESC("Selects the Context Switch Mode.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACR",
        DESC("ARM platform DMA / SDMA Core Clock Ratio.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTDOBS",
        DESC("Indicates if Real-Time Debug pins are used: They do not toggle by defa"
        "ult in order to reduce power consumption.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSPDMA",
        DESC("This bit's function is reserved and should be configured as zero.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_LOCK.
static const field_t hw_sdmaarm_sdma_lock[] =
{
    {
        "LOCK",
        DESC("The LOCK bit is used to restrict access to update SDMA script memory t"
        "hrough ROM channel zero scripts and through the OnCE interface under A"
        "RM platform control.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRESET_LOCK_CLR",
        DESC("The SRESET_LOCK_CLR bit determine if the LOCK bit is cleared on a soft"
        "ware reset triggered by writing to the RESET register.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_ENB.
static const field_t hw_sdmaarm_once_enb[] =
{
    {
        "ENB",
        DESC("The OnCE Enable register selects the OnCE control source: When cleared"
        " (0), the OnCE registers are accessed through the JTAG interface; when"
        " set (1), the OnCE registers may be accessed by the ARM platform throu"
        "gh the addresses described, as follows.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_DATA.
static const field_t hw_sdmaarm_once_data[] =
{
    {
        "DATA",
        DESC("Data register of the OnCE JTAG controller.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_INSTR.
static const field_t hw_sdmaarm_once_instr[] =
{
    {
        "INSTR",
        DESC("Instruction register of the OnCE JTAG controller.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_STAT.
static const field_t hw_sdmaarm_once_stat[] =
{
    {
        "ECDR",
        DESC("Event Cell Debug Request.")
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST",
        DESC("This flag is raised when the OnCE is controlled from the ARM platform "
        "peripheral interface.")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWB",
        DESC("This flag is raised when the SDMA has entered debug mode after a softw"
        "are breakpoint.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODR",
        DESC("This flag is raised when the SDMA has entered debug mode after a OnCE "
        "debug request.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EDR",
        DESC("This flag is raised when the SDMA has entered debug mode after an exte"
        "rnal debug request.")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCV",
        DESC("After each write access to the real time buffer (RTB), the RCV bit is "
        "set.")
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        DESC("The Processor Status bits reflect the state of the SDMA RISC engine.")
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_CMD.
static const field_t hw_sdmaarm_once_cmd[] =
{
    {
        "CMD",
        DESC("Writing to this register will cause the OnCE to execute the command th"
        "at is written.")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ILLINSTADDR.
static const field_t hw_sdmaarm_illinstaddr[] =
{
    {
        "ILLINSTADDR",
        DESC("The Illegal Instruction Trap Address is the address where the SDMA jum"
        "ps when an illegal instruction is executed.")
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHN0ADDR.
static const field_t hw_sdmaarm_chn0addr[] =
{
    {
        "CHN0ADDR",
        DESC("This 14-bit register is used by the boot code of the SDMA.")
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMSZ",
        DESC("The bit 14 (Scratch Memory Size) determines if scratch memory must be "
        "available after every channel context.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVT_MIRROR.
static const field_t hw_sdmaarm_evt_mirror[] =
{
    {
        "EVENTS",
        DESC("This register reflects the DMA requests received by the SDMA for event"
        "s 31-0.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVT_MIRROR2.
static const field_t hw_sdmaarm_evt_mirror2[] =
{
    {
        "EVENTS",
        DESC("This register reflects the DMA requests received by the SDMA for event"
        "s 47-32.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_XTRIG_CONF1.
static const field_t hw_sdmaarm_xtrig_conf1[] =
{
    {
        "NUM0",
        DESC("Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF0",
        DESC("Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM1",
        DESC("Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .")
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF1",
        DESC("Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM2",
        DESC("Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF2",
        DESC("Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM3",
        DESC("Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF3",
        DESC("Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_XTRIG_CONF2.
static const field_t hw_sdmaarm_xtrig_conf2[] =
{
    {
        "NUM4",
        DESC("Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF4",
        DESC("Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM5",
        DESC("Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .")
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF5",
        DESC("Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM6",
        DESC("Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF6",
        DESC("Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM7",
        DESC("Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i .")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF7",
        DESC("Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI0.
static const field_t hw_sdmaarm_sdma_chnpri0[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI1.
static const field_t hw_sdmaarm_sdma_chnpri1[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI2.
static const field_t hw_sdmaarm_sdma_chnpri2[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI3.
static const field_t hw_sdmaarm_sdma_chnpri3[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI4.
static const field_t hw_sdmaarm_sdma_chnpri4[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI5.
static const field_t hw_sdmaarm_sdma_chnpri5[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI6.
static const field_t hw_sdmaarm_sdma_chnpri6[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI7.
static const field_t hw_sdmaarm_sdma_chnpri7[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI8.
static const field_t hw_sdmaarm_sdma_chnpri8[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI9.
static const field_t hw_sdmaarm_sdma_chnpri9[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI10.
static const field_t hw_sdmaarm_sdma_chnpri10[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI11.
static const field_t hw_sdmaarm_sdma_chnpri11[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI12.
static const field_t hw_sdmaarm_sdma_chnpri12[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI13.
static const field_t hw_sdmaarm_sdma_chnpri13[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI14.
static const field_t hw_sdmaarm_sdma_chnpri14[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI15.
static const field_t hw_sdmaarm_sdma_chnpri15[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI16.
static const field_t hw_sdmaarm_sdma_chnpri16[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI17.
static const field_t hw_sdmaarm_sdma_chnpri17[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI18.
static const field_t hw_sdmaarm_sdma_chnpri18[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI19.
static const field_t hw_sdmaarm_sdma_chnpri19[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI20.
static const field_t hw_sdmaarm_sdma_chnpri20[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI21.
static const field_t hw_sdmaarm_sdma_chnpri21[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI22.
static const field_t hw_sdmaarm_sdma_chnpri22[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI23.
static const field_t hw_sdmaarm_sdma_chnpri23[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI24.
static const field_t hw_sdmaarm_sdma_chnpri24[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI25.
static const field_t hw_sdmaarm_sdma_chnpri25[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI26.
static const field_t hw_sdmaarm_sdma_chnpri26[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI27.
static const field_t hw_sdmaarm_sdma_chnpri27[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI28.
static const field_t hw_sdmaarm_sdma_chnpri28[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI29.
static const field_t hw_sdmaarm_sdma_chnpri29[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI30.
static const field_t hw_sdmaarm_sdma_chnpri30[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI31.
static const field_t hw_sdmaarm_sdma_chnpri31[] =
{
    {
        "CHNPRIN",
        DESC("This contains the priority of channel number n .")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL0.
static const field_t hw_sdmaarm_sdma_chnenbl0[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL1.
static const field_t hw_sdmaarm_sdma_chnenbl1[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL2.
static const field_t hw_sdmaarm_sdma_chnenbl2[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL3.
static const field_t hw_sdmaarm_sdma_chnenbl3[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL4.
static const field_t hw_sdmaarm_sdma_chnenbl4[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL5.
static const field_t hw_sdmaarm_sdma_chnenbl5[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL6.
static const field_t hw_sdmaarm_sdma_chnenbl6[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL7.
static const field_t hw_sdmaarm_sdma_chnenbl7[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL8.
static const field_t hw_sdmaarm_sdma_chnenbl8[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL9.
static const field_t hw_sdmaarm_sdma_chnenbl9[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL10.
static const field_t hw_sdmaarm_sdma_chnenbl10[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL11.
static const field_t hw_sdmaarm_sdma_chnenbl11[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL12.
static const field_t hw_sdmaarm_sdma_chnenbl12[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL13.
static const field_t hw_sdmaarm_sdma_chnenbl13[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL14.
static const field_t hw_sdmaarm_sdma_chnenbl14[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL15.
static const field_t hw_sdmaarm_sdma_chnenbl15[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL16.
static const field_t hw_sdmaarm_sdma_chnenbl16[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL17.
static const field_t hw_sdmaarm_sdma_chnenbl17[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL18.
static const field_t hw_sdmaarm_sdma_chnenbl18[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL19.
static const field_t hw_sdmaarm_sdma_chnenbl19[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL20.
static const field_t hw_sdmaarm_sdma_chnenbl20[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL21.
static const field_t hw_sdmaarm_sdma_chnenbl21[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL22.
static const field_t hw_sdmaarm_sdma_chnenbl22[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL23.
static const field_t hw_sdmaarm_sdma_chnenbl23[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL24.
static const field_t hw_sdmaarm_sdma_chnenbl24[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL25.
static const field_t hw_sdmaarm_sdma_chnenbl25[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL26.
static const field_t hw_sdmaarm_sdma_chnenbl26[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL27.
static const field_t hw_sdmaarm_sdma_chnenbl27[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL28.
static const field_t hw_sdmaarm_sdma_chnenbl28[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL29.
static const field_t hw_sdmaarm_sdma_chnenbl29[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL30.
static const field_t hw_sdmaarm_sdma_chnenbl30[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL31.
static const field_t hw_sdmaarm_sdma_chnenbl31[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL32.
static const field_t hw_sdmaarm_sdma_chnenbl32[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL33.
static const field_t hw_sdmaarm_sdma_chnenbl33[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL34.
static const field_t hw_sdmaarm_sdma_chnenbl34[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL35.
static const field_t hw_sdmaarm_sdma_chnenbl35[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL36.
static const field_t hw_sdmaarm_sdma_chnenbl36[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL37.
static const field_t hw_sdmaarm_sdma_chnenbl37[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL38.
static const field_t hw_sdmaarm_sdma_chnenbl38[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL39.
static const field_t hw_sdmaarm_sdma_chnenbl39[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL40.
static const field_t hw_sdmaarm_sdma_chnenbl40[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL41.
static const field_t hw_sdmaarm_sdma_chnenbl41[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL42.
static const field_t hw_sdmaarm_sdma_chnenbl42[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL43.
static const field_t hw_sdmaarm_sdma_chnenbl43[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL44.
static const field_t hw_sdmaarm_sdma_chnenbl44[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL45.
static const field_t hw_sdmaarm_sdma_chnenbl45[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL46.
static const field_t hw_sdmaarm_sdma_chnenbl46[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNENBL47.
static const field_t hw_sdmaarm_sdma_chnenbl47[] =
{
    {
        "ENBLN",
        DESC("This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n .")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SDMAARM module.
static const reg_t hw_sdmaarm[] =
{
    {
        "MC0PTR",
        DESC("")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_mc0ptr
    },
    {
        "INTR",
        DESC("")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_intr
    },
    {
        "STOP_STAT",
        DESC("")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_stop_stat
    },
    {
        "HSTART",
        DESC("")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_hstart
    },
    {
        "EVTOVR",
        DESC("")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evtovr
    },
    {
        "DSPOVR",
        DESC("")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_dspovr
    },
    {
        "HOSTOVR",
        DESC("")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_hostovr
    },
    {
        "EVTPEND",
        DESC("")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evtpend
    },
    {
        "RESET",
        DESC("")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sdmaarm_reset
    },
    {
        "EVTERR",
        DESC("")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evterr
    },
    {
        "INTRMASK",
        DESC("")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_intrmask
    },
    {
        "PSW",
        DESC("")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_sdmaarm_psw
    },
    {
        "EVTERRDBG",
        DESC("")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evterrdbg
    },
    {
        "CONFIG",
        DESC("")
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_sdmaarm_config
    },
    {
        "SDMA_LOCK",
        DESC("")
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sdmaarm_sdma_lock
    },
    {
        "ONCE_ENB",
        DESC("")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_enb
    },
    {
        "ONCE_DATA",
        DESC("")
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_data
    },
    {
        "ONCE_INSTR",
        DESC("")
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_instr
    },
    {
        "ONCE_STAT",
        DESC("")
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_sdmaarm_once_stat
    },
    {
        "ONCE_CMD",
        DESC("")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_cmd
    },
    {
        "ILLINSTADDR",
        DESC("")
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_illinstaddr
    },
    {
        "CHN0ADDR",
        DESC("")
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sdmaarm_chn0addr
    },
    {
        "EVT_MIRROR",
        DESC("")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evt_mirror
    },
    {
        "EVT_MIRROR2",
        DESC("")
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evt_mirror2
    },
    {
        "XTRIG_CONF1",
        DESC("")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_sdmaarm_xtrig_conf1
    },
    {
        "XTRIG_CONF2",
        DESC("")
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_sdmaarm_xtrig_conf2
    },
    {
        "SDMA_CHNPRI0",
        DESC("")
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri0
    },
    {
        "SDMA_CHNPRI1",
        DESC("")
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri1
    },
    {
        "SDMA_CHNPRI2",
        DESC("")
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri2
    },
    {
        "SDMA_CHNPRI3",
        DESC("")
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri3
    },
    {
        "SDMA_CHNPRI4",
        DESC("")
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri4
    },
    {
        "SDMA_CHNPRI5",
        DESC("")
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri5
    },
    {
        "SDMA_CHNPRI6",
        DESC("")
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri6
    },
    {
        "SDMA_CHNPRI7",
        DESC("")
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri7
    },
    {
        "SDMA_CHNPRI8",
        DESC("")
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri8
    },
    {
        "SDMA_CHNPRI9",
        DESC("")
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri9
    },
    {
        "SDMA_CHNPRI10",
        DESC("")
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri10
    },
    {
        "SDMA_CHNPRI11",
        DESC("")
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri11
    },
    {
        "SDMA_CHNPRI12",
        DESC("")
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri12
    },
    {
        "SDMA_CHNPRI13",
        DESC("")
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri13
    },
    {
        "SDMA_CHNPRI14",
        DESC("")
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri14
    },
    {
        "SDMA_CHNPRI15",
        DESC("")
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri15
    },
    {
        "SDMA_CHNPRI16",
        DESC("")
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri16
    },
    {
        "SDMA_CHNPRI17",
        DESC("")
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri17
    },
    {
        "SDMA_CHNPRI18",
        DESC("")
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri18
    },
    {
        "SDMA_CHNPRI19",
        DESC("")
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri19
    },
    {
        "SDMA_CHNPRI20",
        DESC("")
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri20
    },
    {
        "SDMA_CHNPRI21",
        DESC("")
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri21
    },
    {
        "SDMA_CHNPRI22",
        DESC("")
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri22
    },
    {
        "SDMA_CHNPRI23",
        DESC("")
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri23
    },
    {
        "SDMA_CHNPRI24",
        DESC("")
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri24
    },
    {
        "SDMA_CHNPRI25",
        DESC("")
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri25
    },
    {
        "SDMA_CHNPRI26",
        DESC("")
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri26
    },
    {
        "SDMA_CHNPRI27",
        DESC("")
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri27
    },
    {
        "SDMA_CHNPRI28",
        DESC("")
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri28
    },
    {
        "SDMA_CHNPRI29",
        DESC("")
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri29
    },
    {
        "SDMA_CHNPRI30",
        DESC("")
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri30
    },
    {
        "SDMA_CHNPRI31",
        DESC("")
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri31
    },
    {
        "SDMA_CHNENBL0",
        DESC("")
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl0
    },
    {
        "SDMA_CHNENBL1",
        DESC("")
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl1
    },
    {
        "SDMA_CHNENBL2",
        DESC("")
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl2
    },
    {
        "SDMA_CHNENBL3",
        DESC("")
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl3
    },
    {
        "SDMA_CHNENBL4",
        DESC("")
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl4
    },
    {
        "SDMA_CHNENBL5",
        DESC("")
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl5
    },
    {
        "SDMA_CHNENBL6",
        DESC("")
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl6
    },
    {
        "SDMA_CHNENBL7",
        DESC("")
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl7
    },
    {
        "SDMA_CHNENBL8",
        DESC("")
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl8
    },
    {
        "SDMA_CHNENBL9",
        DESC("")
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl9
    },
    {
        "SDMA_CHNENBL10",
        DESC("")
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl10
    },
    {
        "SDMA_CHNENBL11",
        DESC("")
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl11
    },
    {
        "SDMA_CHNENBL12",
        DESC("")
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl12
    },
    {
        "SDMA_CHNENBL13",
        DESC("")
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl13
    },
    {
        "SDMA_CHNENBL14",
        DESC("")
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl14
    },
    {
        "SDMA_CHNENBL15",
        DESC("")
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl15
    },
    {
        "SDMA_CHNENBL16",
        DESC("")
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl16
    },
    {
        "SDMA_CHNENBL17",
        DESC("")
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl17
    },
    {
        "SDMA_CHNENBL18",
        DESC("")
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl18
    },
    {
        "SDMA_CHNENBL19",
        DESC("")
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl19
    },
    {
        "SDMA_CHNENBL20",
        DESC("")
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl20
    },
    {
        "SDMA_CHNENBL21",
        DESC("")
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl21
    },
    {
        "SDMA_CHNENBL22",
        DESC("")
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl22
    },
    {
        "SDMA_CHNENBL23",
        DESC("")
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl23
    },
    {
        "SDMA_CHNENBL24",
        DESC("")
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl24
    },
    {
        "SDMA_CHNENBL25",
        DESC("")
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl25
    },
    {
        "SDMA_CHNENBL26",
        DESC("")
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl26
    },
    {
        "SDMA_CHNENBL27",
        DESC("")
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl27
    },
    {
        "SDMA_CHNENBL28",
        DESC("")
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl28
    },
    {
        "SDMA_CHNENBL29",
        DESC("")
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl29
    },
    {
        "SDMA_CHNENBL30",
        DESC("")
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl30
    },
    {
        "SDMA_CHNENBL31",
        DESC("")
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl31
    },
    {
        "SDMA_CHNENBL32",
        DESC("")
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl32
    },
    {
        "SDMA_CHNENBL33",
        DESC("")
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl33
    },
    {
        "SDMA_CHNENBL34",
        DESC("")
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl34
    },
    {
        "SDMA_CHNENBL35",
        DESC("")
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl35
    },
    {
        "SDMA_CHNENBL36",
        DESC("")
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl36
    },
    {
        "SDMA_CHNENBL37",
        DESC("")
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl37
    },
    {
        "SDMA_CHNENBL38",
        DESC("")
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl38
    },
    {
        "SDMA_CHNENBL39",
        DESC("")
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl39
    },
    {
        "SDMA_CHNENBL40",
        DESC("")
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl40
    },
    {
        "SDMA_CHNENBL41",
        DESC("")
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl41
    },
    {
        "SDMA_CHNENBL42",
        DESC("")
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl42
    },
    {
        "SDMA_CHNENBL43",
        DESC("")
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl43
    },
    {
        "SDMA_CHNENBL44",
        DESC("")
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl44
    },
    {
        "SDMA_CHNENBL45",
        DESC("")
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl45
    },
    {
        "SDMA_CHNENBL46",
        DESC("")
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl46
    },
    {
        "SDMA_CHNENBL47",
        DESC("")
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnenbl47
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SDMABP
#endif

// Bitfields in register SDMABP_DC0PTR.
static const field_t hw_sdmabp_dc0ptr[] =
{
    {
        "DC0PTR",
        DESC("Channel 0 Pointer contains the 32-bit address, in BP memory, of the ar"
        "ray of channel control blocks starting with the one for channel 0 (the"
        " control channel).")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_INTR.
static const field_t hw_sdmabp_intr[] =
{
    {
        "DI",
        DESC("The BP Interrupts register contains the 32 DI[i] bits.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_STOP_STAT.
static const field_t hw_sdmabp_stop_stat[] =
{
    {
        "DE",
        DESC("This 32-bit register gives access to the BP (DSP) Enable bits, DE.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_DSTART.
static const field_t hw_sdmabp_dstart[] =
{
    {
        "DSTART",
        DESC("The DSTART/DE registers are 32 bits wide with one bit for every channe"
        "l.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_EVTERR.
static const field_t hw_sdmabp_evterr[] =
{
    {
        "CHNERR",
        DESC("This register is used by the SDMA to warn the BP when an incoming DMA "
        "request was detected; it then triggers a channel that is already pendi"
        "ng or being serviced, which may mean there is an overflow of data for "
        "that channel.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_INTRMASK.
static const field_t hw_sdmabp_intrmask[] =
{
    {
        "DIMASK",
        DESC("The Interrupt Mask Register contains 32 interrupt generation mask bits"
        ".")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_EVTERRDBG.
static const field_t hw_sdmabp_evterrdbg[] =
{
    {
        "CHNERR",
        DESC("This register is the same as EVTERR except reading it does not clear i"
        "ts contents.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SDMABP module.
static const reg_t hw_sdmabp[] =
{
    {
        "DC0PTR",
        DESC("")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_dc0ptr
    },
    {
        "INTR",
        DESC("")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_intr
    },
    {
        "STOP_STAT",
        DESC("")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_stop_stat
    },
    {
        "DSTART",
        DESC("")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmabp_dstart
    },
    {
        "EVTERR",
        DESC("")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmabp_evterr
    },
    {
        "INTRMASK",
        DESC("")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_intrmask
    },
    {
        "EVTERRDBG",
        DESC("")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmabp_evterrdbg
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SDMACORE
#endif

// Bitfields in register SDMACORE_MC0PTR.
static const field_t hw_sdmacore_mc0ptr[] =
{
    {
        "MC0PTR",
        DESC("Contains the address-in the ARM platform memory space-of the initial S"
        "DMA context and scripts that are loaded by the SDMA boot script runnin"
        "g on channel 0.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_CCPTR.
static const field_t hw_sdmacore_ccptr[] =
{
    {
        "CCPTR",
        DESC("Contains the start address of the context data for the current channel"
        ": Its value is CONTEXT_BASE + 24* CCR or CONTEXT_BASE + 32* CCR where "
        "CONTEXT_BASE = 0x0800.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_CCR.
static const field_t hw_sdmacore_ccr[] =
{
    {
        "CCR",
        DESC("Contains the number of the current running channel whose context is in"
        "stalled.")
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_NCR.
static const field_t hw_sdmacore_ncr[] =
{
    {
        "NCR",
        DESC("Contains the number of the pending channel that the scheduler has sele"
        "cted to run next.")
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EVENTS.
static const field_t hw_sdmacore_events[] =
{
    {
        "EVENTS",
        DESC("Reflects the status of the SDMA's external DMA requests.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_CCPRI.
static const field_t hw_sdmacore_ccpri[] =
{
    {
        "CCPRI",
        DESC("Contains the 3-bit priority of the channel whose context is installed.")
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_NCPRI.
static const field_t hw_sdmacore_ncpri[] =
{
    {
        "NCPRI",
        DESC("Contains the 3-bit priority of the channel the scheduler has selected "
        "to run next.")
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ECOUNT.
static const field_t hw_sdmacore_ecount[] =
{
    {
        "ECOUNT",
        DESC("The event cell counter contains the number of times minus one that an "
        "event detection must occur before generating a debug request.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ECTL.
static const field_t hw_sdmacore_ectl[] =
{
    {
        "ATS",
        DESC("The access type select bits define the memory access type required on "
        "the SDMA memory bus.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AATC",
        DESC("The Address A Trigger Condition (AATC) controls the operations perform"
        "ed by address comparator A.")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABTC",
        DESC("The Address B Trigger Condition (ABTC) controls the operations perform"
        "ed by address comparator B.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATC",
        DESC("The address trigger condition bits select how the two address conditio"
        "ns (addressA and addressB) are combined to define the global address m"
        "atching condition.")
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTC",
        DESC("The data trigger condition bits define when data is considered matchin"
        "g after comparison with the data register of the event detection unit.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECTC",
        DESC("The event cell trigger condition bits select the combination of addres"
        "s and data matching conditions that generate the final address/data co"
        "ndition.")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNT",
        DESC("Event Counter Enable.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN",
        DESC("Event Cell Enable.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EAA.
static const field_t hw_sdmacore_eaa[] =
{
    {
        "EAA",
        DESC("Event Cell Address Register A computes an address A condition.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EAB.
static const field_t hw_sdmacore_eab[] =
{
    {
        "EAB",
        DESC("Event Cell Address Register B computes an address B condition.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EAM.
static const field_t hw_sdmacore_eam[] =
{
    {
        "EAM",
        DESC("The Event Cell Address Mask contains a user-defined address mask value"
        ".")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ED.
static const field_t hw_sdmacore_ed[] =
{
    {
        "ED",
        DESC("The event cell data register contains a user defined data value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EDM.
static const field_t hw_sdmacore_edm[] =
{
    {
        "EDM",
        DESC("The event cell data mask register contains the user-defined data mask "
        "value.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_RTB.
static const field_t hw_sdmacore_rtb[] =
{
    {
        "RTB",
        DESC("The Real Time Buffer register stores and retrieves run time informatio"
        "n without putting the SDMA in debug mode.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_TB.
static const field_t hw_sdmacore_tb[] =
{
    {
        "CHFADDR",
        DESC("The change of flow address is the address where the change of flow is "
        "taken when executing a change of flow instruction.")
        0, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TADDR",
        DESC("The target address is the address taken after the execution of the cha"
        "nge of flow instruction.")
        14, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TBF",
        DESC("The Trace Buffer Flag is set when the buffer contains the addresses of"
        " a valid change of flow.")
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_OSTAT.
static const field_t hw_sdmacore_ostat[] =
{
    {
        "ECDR",
        DESC("Event Cell Debug Request.")
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST",
        DESC("This flag is raised when the OnCE is controlled from the ARM platform "
        "peripheral interface.")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWB",
        DESC("This flag is raised when the SDMA has entered debug mode after a softw"
        "are breakpoint.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODR",
        DESC("This flag is raised when the SDMA has entered debug mode after a OnCE "
        "debug request.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EDR",
        DESC("This flag is raised when the SDMA has entered debug mode after an exte"
        "rnal debug request.")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCV",
        DESC("After each write access to the real time buffer (RTB), the RCV bit is "
        "set.")
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        DESC("The Processor Status bits reflect the state of the SDMA RISC engine.")
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_MCHN0ADDR.
static const field_t hw_sdmacore_mchn0addr[] =
{
    {
        "CHN0ADDR",
        DESC("Contains the address of the channel 0 routine programmed by the ARM pl"
        "atform; it is loaded into a general register at the very start of the "
        "boot and the SDMA jumps to the address it contains.")
        0, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SMSZ",
        DESC("The bit 14 (Scratch Memory Size) determines if scratch memory must be "
        "available after every channel context.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ENDIANNESS.
static const field_t hw_sdmacore_endianness[] =
{
    {
        "APEND",
        DESC("APEND indicates the endian mode of the Peripheral and Burst DMA interf"
        "aces.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_SDMA_LOCK.
static const field_t hw_sdmacore_sdma_lock[] =
{
    {
        "LOCK",
        DESC("The LOCK bit reports the value of the LOCK bit in the SDMA_LOCK status"
        " register.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EVENTS2.
static const field_t hw_sdmacore_events2[] =
{
    {
        "EVENTS",
        DESC("Reflects the status of the SDMA's external DMA requests.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SDMACORE module.
static const reg_t hw_sdmacore[] =
{
    {
        "MC0PTR",
        DESC("")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_mc0ptr
    },
    {
        "CCPTR",
        DESC("")
        4, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ccptr
    },
    {
        "CCR",
        DESC("")
        4, // Width in bytes
        0x00000003, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ccr
    },
    {
        "NCR",
        DESC("")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ncr
    },
    {
        "EVENTS",
        DESC("This register is very useful in the case of DMA requests that are acti"
        "ve when a peripheral FIFO level is above the programmed watermark.")
        4, // Width in bytes
        0x00000005, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_events
    },
    {
        "CCPRI",
        DESC("")
        4, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ccpri
    },
    {
        "NCPRI",
        DESC("")
        4, // Width in bytes
        0x00000007, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ncpri
    },
    {
        "ECOUNT",
        DESC("")
        4, // Width in bytes
        0x00000009, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_ecount
    },
    {
        "ECTL",
        DESC("")
        4, // Width in bytes
        0x0000000a, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_sdmacore_ectl
    },
    {
        "EAA",
        DESC("")
        4, // Width in bytes
        0x0000000b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_eaa
    },
    {
        "EAB",
        DESC("")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_eab
    },
    {
        "EAM",
        DESC("")
        4, // Width in bytes
        0x0000000d, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_eam
    },
    {
        "ED",
        DESC("")
        4, // Width in bytes
        0x0000000e, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_ed
    },
    {
        "EDM",
        DESC("")
        4, // Width in bytes
        0x0000000f, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_edm
    },
    {
        "RTB",
        DESC("")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_rtb
    },
    {
        "TB",
        DESC("")
        4, // Width in bytes
        0x00000019, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sdmacore_tb
    },
    {
        "OSTAT",
        DESC("")
        4, // Width in bytes
        0x0000001a, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_sdmacore_ostat
    },
    {
        "MCHN0ADDR",
        DESC("")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sdmacore_mchn0addr
    },
    {
        "ENDIANNESS",
        DESC("")
        4, // Width in bytes
        0x0000001d, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_endianness
    },
    {
        "SDMA_LOCK",
        DESC("")
        4, // Width in bytes
        0x0000001e, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_sdma_lock
    },
    {
        "EVENTS2",
        DESC("")
        4, // Width in bytes
        0x0000001f, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_events2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SJC
#endif

// Bitfields in register SJC_GPUSR1.
static const field_t hw_sjc_gpusr1[] =
{
    {
        "A_DBG",
        DESC("ARM core debug status bit  Bit 0 is the ARM core DBGACK (debug acknowl"
        "edge)  DBGACK can be overwritten in the ARM core DCR to force a partic"
        "ular DBGACK value.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A_WFI",
        DESC("ARM core wait-for interrupt bit  Bit 1 is the ARM core standbywfi (sta"
        "nd by wait-for interrupt).")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "S_STAT",
        DESC("3 LSBits of SDMA core statusH.")
        2, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PLL_LOCK",
        DESC("PLL_LOCK  A Combined PLL-Lock flag indicator, for all the PLL's.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPUSR2.
static const field_t hw_sjc_gpusr2[] =
{
    {
        "STBYWFI",
        DESC("STBYWFI[3:0]  These bits provide status of \"Standby Wait-For-Interrup"
        "t\" state of all ARM cores.")
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "S_STAT",
        DESC("S_STAT[3:0]  SDMA debug status bits: debug_core_state[3:0]")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STBYWFE",
        DESC("STBYWFE[3:0]  Reflecting the \"Standby Wait For Event\" signals of all"
        " cores.")
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPUSR3.
static const field_t hw_sjc_gpusr3[] =
{
    {
        "IPG_WAIT",
        DESC("IPG_WAIT  CCM's \"ipg_wait\" signal indication")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPG_STOP",
        DESC("IPG_STOP  CCM's \"ipg_stop\" signal indication")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYS_WAIT",
        DESC("System In wait  Indication on System in wait mode (from CCM).")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPSSR.
static const field_t hw_sjc_gpssr[] =
{
    {
        "GPSSR",
        DESC("General Purpose Secured Status Register  Register is used for testing "
        "and debug.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_DCR.
static const field_t hw_sjc_dcr[] =
{
    {
        "DE_TO_ARM",
        DESC("ARM platform debug request input propagation  This bit controls the pr"
        "opagation of debug request to ARM platform (\"dbgreq\"), when the JTAG"
        " state machine is put in \"ENTER_DEBUG\" IR instruction.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DE_TO_SDMA",
        DESC("SDMA debug request input propagation  This bit controls the propagatio"
        "n of debug request to SDMA, when the JTAG state machine is put in \"EN"
        "TER_DEBUG\" IR instruction..")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_OBS",
        DESC("Debug observability  This bit controls the propagation of the \"system"
        " debug\" input to SJC  For i.MX 6x, the SJC's \"system_debug\" input i"
        "s tied to logic HIGH value, therefore, set of \"debug_obs\" bit, will "
        "result in unconditional assertion of DE_B pad.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIRECT_SDMA_REQ_EN",
        DESC("Debug enable of the sdma debug request  This bit controls the propagat"
        "ion of debug request DE_B to the sdma.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIRECT_ARM_REQ_EN",
        DESC("Pass Debug Enable event from DE_B pin to ARM platform debug request si"
        "gnal(s).")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_SSR.
static const field_t hw_sjc_ssr[] =
{
    {
        "KTF",
        DESC("Kill Trace Enable fuse value")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KTA",
        DESC("Kill Trace is active")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWF",
        DESC("Software JTAG enable fuse  Status of the no SW disable JTAG fuse")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWE",
        DESC("SW enable  SW JTAG enable status")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EBF",
        DESC("External Boot fuse  Status of the external boot disable fuse")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EBG",
        DESC("External boot granted  External boot enabled, requested and granted")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FT",
        DESC("Fuse type  Fuse type bit - e-fuse or laser fuse")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SJM",
        DESC("SJC Secure mode  Secure JTAG mode, as set by external fuses.")
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSSTAT",
        DESC("Response status  Response status bits")
        11, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOTIND",
        DESC("Boot Indication  Inverted Internal Boot indication, i.e inverse of SRC"
        ": \"src_int_boot\" signal")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPCCR.
static const field_t hw_sjc_gpccr[] =
{
    {
        "SCLKR",
        DESC("SDMA Clock ON Register - This bit forces the clock on of the SDMA")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLKOFFDIS",
        DESC("Disable/prevent ARM platform clock/power shutdown")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SJC module.
static const reg_t hw_sjc[] =
{
    {
        "GPUSR1",
        DESC("The General Purpose Unsecured Status Register 1 is a read only registe"
        "rs used to check the status of the different Cores and of the PLL.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_sjc_gpusr1
    },
    {
        "GPUSR2",
        DESC("")
        4, // Width in bytes
        0x00000001, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sjc_gpusr2
    },
    {
        "GPUSR3",
        DESC("")
        4, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sjc_gpusr3
    },
    {
        "GPSSR",
        DESC("The General Purpose Secured Status Register is a read-only register us"
        "ed to check the status of the different critical information in the So"
        "C.")
        4, // Width in bytes
        0x00000003, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sjc_gpssr
    },
    {
        "DCR",
        DESC("This register is used to control propagation of debug request from DE_"
        "B pad to the cores and debug signals from internal logic to the DE_B p"
        "ad.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_sjc_dcr
    },
    {
        "SSR",
        DESC("")
        4, // Width in bytes
        0x00000005, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_sjc_ssr
    },
    {
        "GPCCR",
        DESC("This register is used to configure clock related modes in SOC, see Sys"
        "tem Configuration chapter for more information.")
        4, // Width in bytes
        0x00000007, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sjc_gpccr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SPBA
#endif

// Bitfields in register SPBA_PRR0.
static const field_t hw_spba_prr0[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR1.
static const field_t hw_spba_prr1[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR2.
static const field_t hw_spba_prr2[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR3.
static const field_t hw_spba_prr3[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR4.
static const field_t hw_spba_prr4[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR5.
static const field_t hw_spba_prr5[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR6.
static const field_t hw_spba_prr6[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR7.
static const field_t hw_spba_prr7[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR8.
static const field_t hw_spba_prr8[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR9.
static const field_t hw_spba_prr9[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR10.
static const field_t hw_spba_prr10[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR11.
static const field_t hw_spba_prr11[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR12.
static const field_t hw_spba_prr12[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR13.
static const field_t hw_spba_prr13[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR14.
static const field_t hw_spba_prr14[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR15.
static const field_t hw_spba_prr15[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR16.
static const field_t hw_spba_prr16[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR17.
static const field_t hw_spba_prr17[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR18.
static const field_t hw_spba_prr18[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR19.
static const field_t hw_spba_prr19[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR20.
static const field_t hw_spba_prr20[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR21.
static const field_t hw_spba_prr21[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR22.
static const field_t hw_spba_prr22[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR23.
static const field_t hw_spba_prr23[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR24.
static const field_t hw_spba_prr24[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR25.
static const field_t hw_spba_prr25[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR26.
static const field_t hw_spba_prr26[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR27.
static const field_t hw_spba_prr27[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR28.
static const field_t hw_spba_prr28[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR29.
static const field_t hw_spba_prr29[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR30.
static const field_t hw_spba_prr30[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR31.
static const field_t hw_spba_prr31[] =
{
    {
        "RARA",
        DESC("Resource Access Right.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        DESC("Resource Access Right.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        DESC("Resource Access Right.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        DESC("Resource Owner ID.")
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        DESC("Requesting Master Owner.")
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SPBA module.
static const reg_t hw_spba[] =
{
    {
        "PRR0",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr0
    },
    {
        "PRR1",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr1
    },
    {
        "PRR2",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr2
    },
    {
        "PRR3",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr3
    },
    {
        "PRR4",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr4
    },
    {
        "PRR5",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr5
    },
    {
        "PRR6",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr6
    },
    {
        "PRR7",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr7
    },
    {
        "PRR8",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr8
    },
    {
        "PRR9",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr9
    },
    {
        "PRR10",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr10
    },
    {
        "PRR11",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr11
    },
    {
        "PRR12",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr12
    },
    {
        "PRR13",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr13
    },
    {
        "PRR14",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr14
    },
    {
        "PRR15",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr15
    },
    {
        "PRR16",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr16
    },
    {
        "PRR17",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr17
    },
    {
        "PRR18",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr18
    },
    {
        "PRR19",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr19
    },
    {
        "PRR20",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr20
    },
    {
        "PRR21",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr21
    },
    {
        "PRR22",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr22
    },
    {
        "PRR23",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr23
    },
    {
        "PRR24",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr24
    },
    {
        "PRR25",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr25
    },
    {
        "PRR26",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr26
    },
    {
        "PRR27",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr27
    },
    {
        "PRR28",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr28
    },
    {
        "PRR29",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr29
    },
    {
        "PRR30",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr30
    },
    {
        "PRR31",
        DESC("This register controls master ownership and access for a peripheral.")
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr31
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SPDC
#endif

// Bitfields in register SPDC_DISP_TRIGGER.
static const field_t hw_spdc_disp_trigger[] =
{
    {
        "DISP_TRIG",
        DESC("EPD screen update trigger  When set to \"1\" it will trigger TCON star"
        "t to display image on panel.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPD_MODE",
        DESC("EPD update mode setting  0x0 MODE_0 - It will be displayed with mode 0"
        " waveform  0x1 MODE_1 - It will be displayed with mode 1 waveform  0x2"
        " MODE_2 - It will be displayed with mode 2 waveform  0x3 MODE_3 - It w"
        "ill be displayed with mode 3 waveform  0x4 MODE_4 - It will be display"
        "ed with mode 4 waveform (High Speed Handwriting Mode)  0x5 MODE_5 - It"
        " will be displayed with mode 5 waveform  0x7 MODE_7 - It will be displ"
        "ayed with mode 7 waveform")
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FLASH_SET",
        DESC("Judge EPD screen update will be flashed or not in mode 7  0x0 NO_FLASH"
        " - It will not be flashed screen update in mode 7  0x1 FLASH - It will"
        " be flashed screen update in mode 7")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_UPDATE_X_Y.
static const field_t hw_spdc_update_x_y[] =
{
    {
        "COORDINATE_Y",
        DESC("Vertical coordinate of update region (minimum: 1)  If image have rotat"
        "ed counterclockwise 90  Y should be 4n + 1 format where n is integer")
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COORDINATE_X",
        DESC("Horizontal coordinate of update region (minimum: 1)  X should be 4n + "
        "1 format where n is integer")
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_UPDATE_W_H.
static const field_t hw_spdc_update_w_h[] =
{
    {
        "HEIGHT",
        DESC("Height of update region  If image have rotated counterclockwise 90  L "
        "should be 4n format where n is integer")
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIDTH",
        DESC("Width of update region  W should be 4n format where n is integer")
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_LUT_PARA_UPDATE.
static const field_t hw_spdc_lut_para_update[] =
{
    {
        "LUT_PARAMETER_UPDATED_VALUE",
        DESC("The value of update LUT parameter")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_PARAMETER_UPDATED_ADDR",
        DESC("The address of updated LUT parameter")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_OPERATE.
static const field_t hw_spdc_operate[] =
{
    {
        "DISP_REFRESH",
        DESC("Display refresh  When set to \"1\" it will trigger TCON start to refre"
        "sh panel screen base on DDR image data (current frame memory) with mod"
        "e 0 waveform.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEEP_REFRESH",
        DESC("Deep refresh (combine display reset and display refresh function)  Whe"
        "n set to \"1\" it will trigger TCON start to reset panel screen and au"
        "tomatic refresh panel screen base on DDR image data (current frame mem"
        "ory) with mode 0 waveform.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISP_RESET",
        DESC("Display reset  When set to \"1\" it will trigger TCON start to reset p"
        "anel screen and automatic update next/current/previous frame memories "
        "according to flash LUT setting gray level.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_TCON_RESET",
        DESC("Software TCON register reset  When set to \"1\" it will trigger TCON s"
        "tart to reset all internal registers in TCON.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_PANEL_INIT_SET.
static const field_t hw_spdc_panel_init_set[] =
{
    {
        "YOE_POL",
        DESC("Set the YOE signal's polarity of gate driver IC  0x0 LOW_ENABLE -Gate "
        "pulse outputs low enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DUAL_GATE",
        DESC("Set to enable the panel type of dual gate driver  0x0 SINGLE_GATE -Sin"
        "gle gate driver (support gate driver K7900).")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESOLUTION",
        DESC("Set the panel resolution  GRAY_MODE - Please reference the Table 45-12"
        "  RGBW_MODE -Please reference the Table 45-13")
        2, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UD",
        DESC("Select gate driver IC scanning direction up or down.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        DESC("Select source driver IC scanning direction right or left.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FILTER_N",
        DESC("Automatic filter input image pixel data base on the display mode  0x0 "
        "ENABLE_AUTO_DATA_FILTER -Filter input data 16-step gray to 4-step gray"
        " data for mode 2 and mode 3.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER_READY",
        DESC("Driver IC power ready signal  0x0 POWER_NOT_READY - The TCON will be h"
        "old wait for driver IC power turn on finish  0x1 POWER_READY - The TCO"
        "N will into IDLE state and user cloud send the display trigger")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGBW_MODE_EN",
        DESC("RGBW color mode enable  0x0 DISABLE_RGBW_MODE -It will enable TCON int"
        "o gray mode  0x1 ENABLE_ RGBW_MODE - It will enable TCON into RGBW mod"
        "e")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HBURST_LEN_EN",
        DESC("HBURST length enable  0x0 DISABLE_HBURST - AHB2AXI gasket ignores the "
        "HBURST_LEN[3:0].")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_TEMPER_SETTING.
static const field_t hw_spdc_temper_setting[] =
{
    {
        "TEMPERATURE",
        DESC("Update TCON temperature information  Temperature Information is used t"
        "o indicate the temperature of operating environment.")
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_NEXT_BUF.
static const field_t hw_spdc_next_buf[] =
{
    {
        "NEXT_FRAME_MEMORY_ADDR",
        DESC("Update next frame memory address of DDR memory  The next frame memory "
        "address should be word-align value, it means EPD TCON wills automatic "
        "truncate two bits of LSB.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_CURRENT_BUF.
static const field_t hw_spdc_current_buf[] =
{
    {
        "CURRENT_FRAME_MEMORY_ADDR",
        DESC("Update current frame memory address of DDR memory  The current frame m"
        "emory address should be word-align value, it means EPD TCON wills auto"
        "matic truncate two bits of LSB.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_PREVIOUS_BUFF.
static const field_t hw_spdc_previous_buff[] =
{
    {
        "PREVIOUS_FRAME_MEMORY_ADDR",
        DESC("Update previous frame memory address of DDR memory  The previous frame"
        " memory address should be word-align value, it means EPD TCON wills au"
        "tomatic truncate two bits of LSB.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_FRM_CNT_BUFF.
static const field_t hw_spdc_frm_cnt_buff[] =
{
    {
        "COUNTER_FRAME_MEMORY_ADDR",
        DESC("Update counter frame memory address of DDR memory  The counter frame m"
        "emory address should be word-align value, it means EPD TCON wills auto"
        "matic truncate two bits of LSB.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_LUT_BUFF.
static const field_t hw_spdc_lut_buff[] =
{
    {
        "LUT_MEMORY_ADDR",
        DESC("Update LUT memory address of DDR memory  The LUT memory address should"
        " be word-align value, it means EPD TCON wills automatic truncate two b"
        "its of LSB.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_INT_EN.
static const field_t hw_spdc_int_en[] =
{
    {
        "UPDATE_FINISH_INT_EN",
        DESC("Screen update finish interrupt signal mask  0x0 DISABLE_UPDATE_FINISH_"
        "INTERRUPT - Disable Frame Update Finish Interrupt  0x1 ENABLE_UPDATE_F"
        "INISH_INTERRUPT - Enable Frame Update Finish Interrupt")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCON_INIT_FINISH_INT_EN",
        DESC("TCON initialization finish interrupt signal mask  0x0 DISABLE_TCON_INI"
        "T_FINISH_INTERRUPT - Disable TCON Initialization Finish Interrupt  0x1"
        " ENABLE_TCON_INIT_FINISH_INTERRUPT - Enable TCON Initialization Interr"
        "upt")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_DOWNLOAD_FINISH_INT_EN",
        DESC("LUT initial download finish interrupt signal mask  0x0 DISABLE_LUT_DOW"
        "NLOAD_FINISH_INTERRUPT - Disable LUT initial Download Finish Interrupt"
        "  0x1 ENABLE_LUT_DOWNLOAD_FINISH_INTERRUPT - Enable LUT initial Downlo"
        "ad Finish Interrupt")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCON_ERROR_INT_EN",
        DESC("Error interrupt signal mask  0x0 DISABLE_ERRPR_INTERRUPT - Disable Err"
        "or Interrupt  0x1 ENABLE_ERRPR_INTERRUPT - Enable Error Interrupt")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_INT_ST_CLR.
static const field_t hw_spdc_int_st_clr[] =
{
    {
        "UPDATE_FINISH_INT_CLR",
        DESC("Screen update finish interrupt signal clear  When set to \"1\" it will"
        " trigger TCON start to clear screen update finish interrupt.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCON_INIT_FINISH_INT_CLR",
        DESC("TCON initialization finish interrupt signal clear  When set to \"1\" i"
        "t will trigger TCON start to clear TCON initialization finish interrup"
        "t.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_DOWNLOAD_FINISH_INT_CLR",
        DESC("LUT initial download finish interrupt signal clear  When set to \"1\" "
        "it will trigger TCON start to clear LUT download finish interrupt.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCON_ERROR_INT_CLR",
        DESC("Error interrupt signal clear  When set to \"1\" it will trigger TCON s"
        "tart to clear error interrupt.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_STATUS.
static const field_t hw_spdc_status[] =
{
    {
        "EPD_TCON_BUSY_N",
        DESC("EPD TCON busy status  0x0 BUSY_STATUS - Panel is under updating  0x1 N"
        "OT_BUSY_STATUS - Panel update finished")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LUT_CHECKSUM",
        DESC("LUT checksum status  0x0 CHECKSUM_FAIL - LUT checksum fail  0x1 CHECKS"
        "UM_SUCCESS - LUT checksum pass")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPD_TCON_STATUS",
        DESC("EPD TCON IP status  0x0 RST_STATUS - EPD TCON during reset phase  0x1 "
        "WAIT_FOR_CHECKSUM_AND_POWER_READY_STATUS - EPD TCON is hold for waitin"
        "g checksum pass and driver IC power ready  0x2 CHECKSUM_FAIL_BUT_POWER"
        "_READY_STATUS - EPD TCON checksum fail but driver IC power ready.")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_PANEL_TYPE_VER.
static const field_t hw_spdc_panel_type_ver[] =
{
    {
        "PRODUCT_AND_DRIVER_ID",
        DESC("Product ID and driver ID, they are stand for different type of panel  "
        "0x0 A060SE02 - Panel type (AUO-K7900)  0x1 A090XE01 - Panel type (AUO-"
        "K7900)  Others need to be defined")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LUT_VERSION",
        DESC("LUT version, it stands for different version of driving waveform  0x01"
        "01 V308 - Driving waveform type  0x0102 V312 - Driving waveform type  "
        "Others need to be defined")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPD_PANEL_TYPE",
        DESC("EPD panel type, it stands for different material type of film.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_TCON_VER.
static const field_t hw_spdc_tcon_ver[] =
{
    {
        "EPD_TCON_VERSION",
        DESC("EPD TCON version, it stands for different version of EPD TCON.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDC_SW_GATE_CLK.
static const field_t hw_spdc_sw_gate_clk[] =
{
    {
        "GATING_ALL_CLK_EN",
        DESC("All clocks gating enable  0x0 ENABLE_ALL_CLOCKS - All clocks free run "
        " 0x1 GATING_ALL_CLOCKS - Gating all clocks for low power")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SPDC module.
static const reg_t hw_spdc[] =
{
    {
        "DISP_TRIGGER",
        DESC("")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_spdc_disp_trigger
    },
    {
        "UPDATE_X_Y",
        DESC("")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdc_update_x_y
    },
    {
        "UPDATE_W_H",
        DESC("")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdc_update_w_h
    },
    {
        "LUT_PARA_UPDATE",
        DESC("")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdc_lut_para_update
    },
    {
        "OPERATE",
        DESC("")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_spdc_operate
    },
    {
        "PANEL_INIT_SET",
        DESC("Resolution Mapping Table of Gray Mode        Resolution [4:0] (binary)"
        "  Resolution Setting (Width x Height)  Portrait / Landscape    11000  "
        "Display resolution is 600 x 800.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_spdc_panel_init_set
    },
    {
        "TEMPER_SETTING",
        DESC("Temperature Mapping Table       TEMPERATURE [8:0] (binary)  Thermal Se"
        "nsor Temperature (oC)    110010010  -55    :  :    111111110  -1    11"
        "1111111  -0.5    000000000  0    000000001  0.5    000000010  1    :  "
        ":    001111111  63.5    :  :")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdc_temper_setting
    },
    {
        "NEXT_BUF",
        DESC("")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdc_next_buf
    },
    {
        "CURRENT_BUF",
        DESC("")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdc_current_buf
    },
    {
        "PREVIOUS_BUFF",
        DESC("")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdc_previous_buff
    },
    {
        "FRM_CNT_BUFF",
        DESC("")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdc_frm_cnt_buff
    },
    {
        "LUT_BUFF",
        DESC("")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdc_lut_buff
    },
    {
        "INT_EN",
        DESC("")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_spdc_int_en
    },
    {
        "INT_ST_CLR",
        DESC("")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_spdc_int_st_clr
    },
    {
        "STATUS",
        DESC("")
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_spdc_status
    },
    {
        "PANEL_TYPE_VER",
        DESC("")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_spdc_panel_type_ver
    },
    {
        "TCON_VER",
        DESC("")
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdc_tcon_ver
    },
    {
        "SW_GATE_CLK",
        DESC("")
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdc_sw_gate_clk
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SPDIF
#endif

// Bitfields in register SPDIF_SCR.
static const field_t hw_spdif_scr[] =
{
    {
        "USRC_SEL",
        DESC("")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSEL",
        DESC("")
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALCTRL",
        DESC("")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TX_EN",
        DESC("DMA Transmit Request Enable  (Tx FIFO empty)")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_RX_EN",
        DESC("DMA Receive Request Enable  (RX FIFO full)")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFO_CTRL",
        DESC("")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOFT_RESET",
        DESC("When write 1 to this bit, it will cause SPDIF software reset.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOW_POWER",
        DESC("When write 1 to this bit, it will cause SPDIF enter low-power mode.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOEMPTY_SEL",
        DESC("")
        15, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXAUTOSYNC",
        DESC("")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXAUTOSYNC",
        DESC("")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFOFULL_SEL",
        DESC("")
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFO_RST",
        DESC("")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFO_OFF",
        DESC("")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFO_CTRL",
        DESC("")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRCD.
static const field_t hw_spdif_srcd[] =
{
    {
        "USYNCMODE",
        DESC("")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRPC.
static const field_t hw_spdif_srpc[] =
{
    {
        "GAINSEL",
        DESC("Gain selection:")
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        DESC("LOCK bit to show that the internal DPLL is locked, read only")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKSRC_SEL",
        DESC("Clock source selection, all other settings not shown are reserved:")
        7, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SIE.
static const field_t hw_spdif_sie[] =
{
    {
        "RXFIFOFUL",
        DESC("SPDIF Rx FIFO full, can't be cleared with reg.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXEM",
        DESC("SPDIF Tx FIFO empty, can't be cleared with reg.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCKLOSS",
        DESC("SPDIF receiver loss of lock")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFORESYN",
        DESC("Rx FIFO resync")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFOUNOV",
        DESC("Rx FIFO underrun/overrun")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UQERR",
        DESC("U/Q Channel framing error")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UQSYNC",
        DESC("U/Q Channel sync found")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QRXOV",
        DESC("Q Channel receive register overrun")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QRXFUL",
        DESC("Q Channel receive register full, can't be cleared with reg.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URXOV",
        DESC("U Channel receive register overrun")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URXFUL",
        DESC("U Channel receive register full, can't be cleared with reg.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BITERR",
        DESC("SPDIF receiver found parity bit error")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYMERR",
        DESC("SPDIF receiver found illegal symbol")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALNOGOOD",
        DESC("SPDIF validity flag no good")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNEW",
        DESC("SPDIF receive change in value of control channel")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRESYN",
        DESC("SPDIF Tx FIFO resync")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXUNOV",
        DESC("SPDIF Tx FIFO under/overrun")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        DESC("SPDIF receiver's DPLL is locked")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SIS.
static const field_t hw_spdif_sis[] =
{
    {
        "RXFIFOFUL",
        DESC("SPDIF Rx FIFO full, can't be cleared with reg.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXEM",
        DESC("SPDIF Tx FIFO empty, can't be cleared with reg.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCKLOSS",
        DESC("SPDIF receiver loss of lock")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFIFORESYN",
        DESC("Rx FIFO resync")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFIFOUNOV",
        DESC("Rx FIFO underrun/overrun")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UQERR",
        DESC("U/Q Channel framing error")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UQSYNC",
        DESC("U/Q Channel sync found")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "QRXOV",
        DESC("Q Channel receive register overrun")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "QRXFUL",
        DESC("Q Channel receive register full, can't be cleared with reg.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "URXOV",
        DESC("U Channel receive register overrun")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "URXFUL",
        DESC("U Channel receive register full, can't be cleared with reg.")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BITERR",
        DESC("SPDIF receiver found parity bit error")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYMERR",
        DESC("SPDIF receiver found illegal symbol")
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALNOGOOD",
        DESC("SPDIF validity flag no good")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CNEW",
        DESC("SPDIF receive change in value of control channel")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXRESYN",
        DESC("SPDIF Tx FIFO resync")
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXUNOV",
        DESC("SPDIF Tx FIFO under/overrun")
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        DESC("SPDIF receiver's DPLL is locked")
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRL.
static const field_t hw_spdif_srl[] =
{
    {
        "RXDATALEFT",
        DESC("Processor receive SPDIF data left")
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRR.
static const field_t hw_spdif_srr[] =
{
    {
        "RXDATARIGHT",
        DESC("Processor receive SPDIF data right")
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRCSH.
static const field_t hw_spdif_srcsh[] =
{
    {
        "RXCCHANNEL_H",
        DESC("SPDIF receive C channel register, contains first 24 bits of C channel "
        "without interpretation")
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRCSL.
static const field_t hw_spdif_srcsl[] =
{
    {
        "RXCCHANNEL_L",
        DESC("SPDIF receive C channel register, contains next 24 bits of C channel w"
        "ithout interpretation")
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRU.
static const field_t hw_spdif_sru[] =
{
    {
        "RXUCHANNEL",
        DESC("SPDIF receive U channel register, contains next 3 U channel bytes")
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("This is a 24-bit register the upper byte is unimplemented.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRQ.
static const field_t hw_spdif_srq[] =
{
    {
        "RXQCHANNEL",
        DESC("SPDIF receive Q channel register, contains next 3 Q channel bytes")
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STL.
static const field_t hw_spdif_stl[] =
{
    {
        "TXDATALEFT",
        DESC("SPDIF transmit left channel data.")
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("This is a 24-bit register the upper byte is unimplemented.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STR.
static const field_t hw_spdif_str[] =
{
    {
        "TXDATARIGHT",
        DESC("SPDIF transmit right channel data.")
        0, // LSB
        23, // MSB
        false, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("This is a 24-bit register the upper byte is unimplemented.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STCSCH.
static const field_t hw_spdif_stcsch[] =
{
    {
        "TXCCHANNELCONS_H",
        DESC("SPDIF transmit Cons.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STCSCL.
static const field_t hw_spdif_stcscl[] =
{
    {
        "TXCCHANNELCONS_L",
        DESC("SPDIF transmit Cons.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRFM.
static const field_t hw_spdif_srfm[] =
{
    {
        "FREQMEAS",
        DESC("Frequency measurement data")
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STC.
static const field_t hw_spdif_stc[] =
{
    {
        "TXCLK_DF",
        DESC("Divider factor (1-128)")
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_ALL_CLK_EN",
        DESC("Spdif transfer clock enable.When data is going to be transfered, this "
        "bit should be set to1.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCLK_SOURCE",
        DESC("")
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYSCLK_DF",
        DESC("system clock divider factor, 2~512.")
        11, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNIMPLEMENTED",
        DESC("")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SPDIF module.
static const reg_t hw_spdif[] =
{
    {
        "SCR",
        DESC("")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_spdif_scr
    },
    {
        "SRCD",
        DESC("")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdif_srcd
    },
    {
        "SRPC",
        DESC("")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_spdif_srpc
    },
    {
        "SIE",
        DESC("The InterruptEn register (SPDIF_SIE) provides control over the enablin"
        "g of interrupts.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_spdif_sie
    },
    {
        "SIS",
        DESC("The InterruptStat (SPDIF_SIS) register is a read only register that pr"
        "ovides the status on interrupt operations.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        19, // Number of bitfields
        hw_spdif_sis
    },
    {
        "SRL",
        DESC("SPDIFRxLeft register is an audio data reception register.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_srl
    },
    {
        "SRR",
        DESC("SPDIFRxRight register is an audio data reception register.")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_srr
    },
    {
        "SRCSH",
        DESC("SPDIFRxCChannel_h register is a channel status reception register.")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_srcsh
    },
    {
        "SRCSL",
        DESC("SPDIFRxCChannel_l register is a channel status reception register.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_srcsl
    },
    {
        "SRU",
        DESC("UChannelRx register is a user bits reception register.")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_sru
    },
    {
        "SRQ",
        DESC("QChannelRx register is a user bits reception register.")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_srq
    },
    {
        "STL",
        DESC("SPDIFTxLeft register is an audio data transmission register.")
        4, // Width in bytes
        0x0000002c, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdif_stl
    },
    {
        "STR",
        DESC("SPDIFTxRight register is an audio data transmission register.")
        4, // Width in bytes
        0x00000030, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdif_str
    },
    {
        "STCSCH",
        DESC("SPDIFTxCChannelCons_h register is a channel status transmission regist"
        "er.")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdif_stcsch
    },
    {
        "STCSCL",
        DESC("SPDIFTxCChannelCons_l register is a channel status transmission regist"
        "er.")
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_spdif_stcscl
    },
    {
        "SRFM",
        DESC("")
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_spdif_srfm
    },
    {
        "STC",
        DESC("The SPDIFTxClk Control register includes the means to select the trans"
        "mit clock and frequency division.")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spdif_stc
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SRC
#endif

// Bitfields in register SRC_SCR.
static const field_t hw_src_scr[] =
{
    {
        "WARM_RESET_ENABLE",
        DESC("WARM reset enable bit.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_GPU_RST",
        DESC("Software reset for gpu  this is a self clearing bit.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_VPU_RST",
        DESC("Software reset for vpu  this is a self clearing bit.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_OPEN_VG_RST",
        DESC("Software reset for open_vg  This is a self clearing bit.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WARM_RST_BYPASS_COUNT",
        DESC("Defines the ckil cycles to count before bypassing the MMDC acknowledge"
        " for WARM reset.")
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_WDOG_RST",
        DESC("Mask wdog_rst_b source.")
        7, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EIM_RST",
        DESC("EIM reset is needed in order to reconfigure the eim chip select.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0_RST",
        DESC("Software reset for core0 only.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0_DBG_RST",
        DESC("Software reset for core0 debug only.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORES_DBG_RST",
        DESC("Software reset for debug of arm platform only.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_RST_MSK_PG",
        DESC("Do not assert debug resets after power gating event of cpu")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SBMR1.
static const field_t hw_src_sbmr1[] =
{
    {
        "BOOT_CFG1",
        DESC("Please refer to fuse map.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG2",
        DESC("Please refer to fuse map.")
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG3",
        DESC("Please refer to fuse map.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG4",
        DESC("Please refer to fuse map.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SRSR.
static const field_t hw_src_srsr[] =
{
    {
        "IPP_RESET_B",
        DESC("Indicates whether reset was the result of ipp_reset_b pin (Power-up se"
        "quence)")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSU_RESET_B",
        DESC("Indicates whether the reset was the result of the csu_reset_b input.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPP_USER_RESET_B",
        DESC("Indicates whether the reset was the result of the ipp_user_reset_b qua"
        "lified reset.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_RST_B",
        DESC("IC Watchdog Time-out reset.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "JTAG_RST_B",
        DESC("HIGH - Z JTAG reset.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "JTAG_SW_RST",
        DESC("JTAG SW reset.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WARM_BOOT",
        DESC("WARM boot indication shows that WARM boot was initiated by software.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SISR.
static const field_t hw_src_sisr[] =
{
    {
        "GPU_PASSED_RESET",
        DESC("Interrupt generated to indicate that gpu passed software reset and is "
        "ready to be used")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VPU_PASSED_RESET",
        DESC("Interrupt generated to indicate that vpu passed software reset and is "
        "ready to be used")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OPEN_VG_PASSED_RESET",
        DESC("Interrupt generated to indicate that open_vg passed software reset and"
        " is ready to be used")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORE0_WDOG_RST_REQ",
        DESC("WDOG reset request from CPU core0.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SIMR.
static const field_t hw_src_simr[] =
{
    {
        "MASK_GPU_PASSED_RESET",
        DESC("mask interrupt generation due to gpu passed reset")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_VPU_PASSED_RESET",
        DESC("mask interrupt generation due to vpu passed reset")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_OPEN_VG_PASSED_RESET",
        DESC("mask interrupt generation due to open_vg passed reset")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SBMR2.
static const field_t hw_src_sbmr2[] =
{
    {
        "SEC_CONFIG",
        DESC("Please refer to fuse map.")
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIR_BT_DIS",
        DESC("Please refer to fuse map.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BT_FUSE_SEL",
        DESC("BT_FUSE_SEL (connected to gpio bt_fuse_sel)")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BMOD",
        DESC("Please refer to fuse map.")
        24, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEST_MODE",
        DESC("Please refer to fuse map.")
        27, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SRC module.
static const reg_t hw_src[] =
{
    {
        "SCR",
        DESC("The Reset control register (SCR), contains bits that control operation"
        " of the reset controller.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_src_scr
    },
    {
        "SBMR1",
        DESC("The Boot Mode register (SBMR) contains bits that reflect the status of"
        " Boot Mode Pins of the chip.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_src_sbmr1
    },
    {
        "SRSR",
        DESC("The SRSR is a write to one clear register which records the source of "
        "the reset events for the chip.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_src_srsr
    },
    {
        "SISR",
        DESC("")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_src_sisr
    },
    {
        "SIMR",
        DESC("")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_src_simr
    },
    {
        "SBMR2",
        DESC("The Boot Mode register (SBMR), contains bits that reflect the status o"
        "f Boot Mode Pins of the chip.")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_src_sbmr2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SSI
#endif

// Bitfields in register SSI_SSI_STX0.
static const field_t hw_ssi_ssi_stx0[] =
{
    {
        "STXN",
        DESC("SSI Transmit Data.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_STX1.
static const field_t hw_ssi_ssi_stx1[] =
{
    {
        "STXN",
        DESC("SSI Transmit Data.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SRX0.
static const field_t hw_ssi_ssi_srx0[] =
{
    {
        "SRXN",
        DESC("SSI Receive Data.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SRX1.
static const field_t hw_ssi_ssi_srx1[] =
{
    {
        "SRXN",
        DESC("SSI Receive Data.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SCR.
static const field_t hw_ssi_ssi_scr[] =
{
    {
        "SSIEN",
        DESC("SSIEN - SSI Enable  This bit is used to enable/disable the SSI.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE",
        DESC("Transmit Enable.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE",
        DESC("Receive Enable.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NET",
        DESC("Network Mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYN",
        DESC("Synchronous Mode.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "I2S_MODE",
        DESC("I2S Mode Select.")
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYS_CLK_EN",
        DESC("Network Clock (Oversampling Clock) Enable.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCH_EN",
        DESC("Two-Channel Operation Enable.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_IST",
        DESC("Clock Idle State.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFR_CLK_DIS",
        DESC("Transmit Frame Clock Disable.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFR_CLK_DIS",
        DESC("Receive Frame Clock Disable.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC_TX_FS",
        DESC("SYNC_FS_TX bit provides a safe window for TE to be visible to the inte"
        "rnal circuit which is just after FS occurrence.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SISR.
static const field_t hw_ssi_ssi_sisr[] =
{
    {
        "TFE0",
        DESC("Transmit FIFO Empty 0.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFE1",
        DESC("Transmit FIFO Empty 1.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFF0",
        DESC("Receive FIFO Full 0.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFF1",
        DESC("Receive FIFO Full 1.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RLS",
        DESC("Receive Last Time Slot.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TLS",
        DESC("Transmit Last Time Slot.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFS",
        DESC("Receive Frame Sync.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFS",
        DESC("Transmit Frame Sync.")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TUE0",
        DESC("Transmitter Underrun Error 0.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUE1",
        DESC("Transmitter Underrun Error 1.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROE0",
        DESC("Receiver Overrun Error 0.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROE1",
        DESC("Receiver Overrun Error 1.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDE0",
        DESC("Transmit Data Register Empty 0.")
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDE1",
        DESC("Transmit Data Register Empty 1.")
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDR0",
        DESC("Receive Data Ready 0.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDR1",
        DESC("Receive Data Ready 1.")
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXT",
        DESC("Receive Tag Updated.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDDU",
        DESC("Command Data Register Updated.")
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDAU",
        DESC("Command Address Register Updated.")
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFRC",
        DESC("Transmit Frame Complete.")
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFRC",
        DESC("Receive Frame Complete.")
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SIER.
static const field_t hw_ssi_sier[] =
{
    {
        "ENABLE_BITS1",
        DESC("Enable Bit.")
        0, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        DESC("Transmit Interrupt Enable.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMAE",
        DESC("Transmit DMA Enable.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIE",
        DESC("Receive Interrupt Enable.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMAE",
        DESC("Receive DMA Enable.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BITS",
        DESC("Enable Bit.")
        23, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_STCR.
static const field_t hw_ssi_ssi_stcr[] =
{
    {
        "TEFS",
        DESC("Transmit Early Frame Sync.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSL",
        DESC("Transmit Frame Sync Length.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFSI",
        DESC("Transmit Frame Sync Invert.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSCKP",
        DESC("Transmit Clock Polarity.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSHFD",
        DESC("Transmit Shift Direction.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDIR",
        DESC("Transmit Clock Direction.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFDIR",
        DESC("Transmit Frame Direction.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEN0",
        DESC("Transmit FIFO Enable 0.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEN1",
        DESC("Transmit FIFO Enable 1.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXBIT0",
        DESC("Transmit Bit 0.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SRCR.
static const field_t hw_ssi_ssi_srcr[] =
{
    {
        "REFS",
        DESC("Receive Early Frame Sync.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSL",
        DESC("Receive Frame Sync Length.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFSI",
        DESC("Receive Frame Sync Invert.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSCKP",
        DESC("Receive Clock Polarity.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSHFD",
        DESC("Receive Shift Direction.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDIR",
        DESC("Receive Clock Direction.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFDIR",
        DESC("Receive Frame Direction.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN0",
        DESC("Receive FIFO Enable 0.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN1",
        DESC("Receive FIFO Enable 1.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXBIT0",
        DESC("Receive Bit 0.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEXT",
        DESC("Receive Data Extension.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_STCCR.
static const field_t hw_ssi_ssi_stccr[] =
{
    {
        "PM7_PM0",
        DESC("Prescaler Modulus Select.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC4_DC0",
        DESC("Frame Rate Divider Control.")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL3_WL0",
        DESC("Word Length Control.")
        13, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSR",
        DESC("Prescaler Range.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV2",
        DESC("Divide By 2.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SRCCR.
static const field_t hw_ssi_srccr[] =
{
    {
        "PM7_PM0",
        DESC("Prescaler Modulus Select.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DC4_DC0",
        DESC("Frame Rate Divider Control.")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL3_WL0",
        DESC("Word Length Control.")
        13, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSR",
        DESC("Prescaler Range.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIV2",
        DESC("Divide By 2.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SFCSR.
static const field_t hw_ssi_ssi_sfcsr[] =
{
    {
        "TFWM0",
        DESC("Transmit FIFO Empty WaterMark 0.")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFWM0",
        DESC("Receive FIFO Full WaterMark 0.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFCNT0",
        DESC("Transmit FIFO Counter 0.")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFCNT0",
        DESC("Receive FIFO Counter 0.")
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFWM1",
        DESC("Transmit FIFO Empty WaterMark 1.")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFWM1",
        DESC("Receive FIFO Full WaterMark 1.")
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFCNT1",
        DESC("Transmit FIFO Counter1.")
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFCNT1",
        DESC("Receive FIFO Counter1.")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SACNT.
static const field_t hw_ssi_ssi_sacnt[] =
{
    {
        "AC97EN",
        DESC("AC97 Mode Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FV",
        DESC("Fixed/Variable Operation.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIF",
        DESC("Tag in FIFO.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD",
        DESC("Read Command.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR",
        DESC("Write Command.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRDIV",
        DESC("Frame Rate Divider.")
        5, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SACADD.
static const field_t hw_ssi_ssi_sacadd[] =
{
    {
        "SACADD",
        DESC("AC97 Command Address.")
        0, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SACDAT.
static const field_t hw_ssi_ssi_sacdat[] =
{
    {
        "SACDAT",
        DESC("AC97 Command Data.")
        0, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SATAG.
static const field_t hw_ssi_satag[] =
{
    {
        "SATAG",
        DESC("AC97 Tag Value.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_STMSK.
static const field_t hw_ssi_ssi_stmsk[] =
{
    {
        "STMSK",
        DESC("Transmit Mask.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SRMSK.
static const field_t hw_ssi_ssi_srmsk[] =
{
    {
        "SRMSK",
        DESC("Receive Mask.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SACCST.
static const field_t hw_ssi_ssi_saccst[] =
{
    {
        "SACCST",
        DESC("AC97 Channel Status.")
        0, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SACCEN.
static const field_t hw_ssi_ssi_saccen[] =
{
    {
        "SACCEN",
        DESC("AC97 Channel Enable.")
        0, // LSB
        9, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SSI_SSI_SACCDIS.
static const field_t hw_ssi_ssi_saccdis[] =
{
    {
        "SACCDIS",
        DESC("AC97 Channel Disable.")
        0, // LSB
        9, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SSI module.
static const reg_t hw_ssi[] =
{
    {
        "SSI_STX0",
        DESC("Enable SSI (SSIEN=1) before writing to SSI Transmit Data Registers.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_stx0
    },
    {
        "SSI_STX1",
        DESC("Enable SSI (SSIEN=1) before writing to SSI Transmit Data Registers.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_stx1
    },
    {
        "SSI_SRX0",
        DESC("")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_srx0
    },
    {
        "SSI_SRX1",
        DESC("")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_srx1
    },
    {
        "SSI_SCR",
        DESC("The SSI Control Register (SSI_SCR) sets up the SSI reset is controlled"
        " by bit 0 in the SSI_SCR.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ssi_ssi_scr
    },
    {
        "SSI_SISR",
        DESC("The SSI Interrupt Status Register (SSI_SISR) is used to monitor the SS"
        "I.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_ssi_ssi_sisr
    },
    {
        "SIER",
        DESC("The SSI Interrupt Enable Register (SIER) is a 25-bit register used to "
        "set up the SSI interrupts and DMA requests.")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ssi_sier
    },
    {
        "SSI_STCR",
        DESC("The SSI Transmit Configuration Register (SSI_STCR) is a read/write con"
        "trol register used to direct the transmit operation of the STCR contro"
        "ls the direction of the bit clock and frame sync ports, STCK and STFS.")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ssi_ssi_stcr
    },
    {
        "SSI_SRCR",
        DESC("The SSI Receive Configuration Register (SSI_SRCR) is a read/write cont"
        "rol register used to direct the receive operation of the SSI.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ssi_ssi_srcr
    },
    {
        "SSI_STCCR",
        DESC("The SSI Transmit and Receive Control (SSI_STCCR and SSI_SRCCR) registe"
        "rs are 19-bit, read/write control registers used to direct the operati"
        "on of the SSI.")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ssi_ssi_stccr
    },
    {
        "SRCCR",
        DESC("The SSI Transmit and Receive Control (SSI_STCCR and SSI_SRCCR) registe"
        "rs are 19-bit, read/write control registers used to direct the operati"
        "on of the SSI.")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ssi_srccr
    },
    {
        "SSI_SFCSR",
        DESC("The SSI FIFO Control / Status Register indicates the status of the Tra"
        "nsmit FIFO Empty flag, with different settings of the Transmit FIFO Wa"
        "terMark bits and varying amounts of data in the Tx FIFO  .")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ssi_ssi_sfcsr
    },
    {
        "SSI_SACNT",
        DESC("")
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ssi_ssi_sacnt
    },
    {
        "SSI_SACADD",
        DESC("")
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_sacadd
    },
    {
        "SSI_SACDAT",
        DESC("")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_sacdat
    },
    {
        "SATAG",
        DESC("")
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_satag
    },
    {
        "SSI_STMSK",
        DESC("")
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_stmsk
    },
    {
        "SSI_SRMSK",
        DESC("")
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_srmsk
    },
    {
        "SSI_SACCST",
        DESC("")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_saccst
    },
    {
        "SSI_SACCEN",
        DESC("")
        4, // Width in bytes
        0x00000054, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_saccen
    },
    {
        "SSI_SACCDIS",
        DESC("")
        4, // Width in bytes
        0x00000058, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ssi_ssi_saccdis
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark TEMPMON
#endif

// Bitfields in register TEMPMON_TEMPSENSE0.
static const field_t hw_tempmon_tempsense0[] =
{
    {
        "POWER_DOWN",
        DESC("This bit powers down the temperature sensor.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEASURE_TEMP",
        DESC("Starts the measurement process.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FINISHED",
        DESC("Indicates that the latest temp is valid.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEMP_CNT",
        DESC("This bit field contains the last measured temperature count.")
        8, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALARM_VALUE",
        DESC("This bit field contains the temperature count (raw sensor output) that"
        " will generate an alarm interrupt.")
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE1.
static const field_t hw_tempmon_tempsense1[] =
{
    {
        "MEASURE_FREQ",
        DESC("This bits determines how many RTC clocks to wait before automatically "
        "repeating a temperature measurement.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a TEMPMON module.
static const reg_t hw_tempmon[] =
{
    {
        "TEMPSENSE0",
        DESC("This register defines the basic controls for the temperature sensor mi"
        "nus the frequency of automatic sampling which is defined in the tempse"
        "nsor.")
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_tempmon_tempsense0
    },
    {
        "TEMPSENSE1",
        DESC("This register defines the automatic repeat time of the temperature sen"
        "sor.")
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_tempmon_tempsense1
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark UART
#endif

// Bitfields in register UART_URXD.
static const field_t hw_uart_urxd[] =
{
    {
        "RX_DATA",
        DESC("Received Data .")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRERR",
        DESC("In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bi"
        "t RS-485 data In RS232/IrDA mode, it is the Parity Error flag .")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BRK",
        DESC("BREAK Detect.")
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRMERR",
        DESC("Frame Error.")
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OVRRUN",
        DESC("Receiver Overrun.")
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR",
        DESC("Error Detect.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHARRDY",
        DESC("Character Ready.")
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UTXD.
static const field_t hw_uart_utxd[] =
{
    {
        "TX_DATA",
        DESC("Transmit Data .")
        0, // LSB
        7, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR1.
static const field_t hw_uart_ucr1[] =
{
    {
        "UARTEN",
        DESC("UART Enable .")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZE",
        DESC("DOZE .")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDMAEN",
        DESC("Aging DMA Timer Enable .")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDMAEN",
        DESC("Transmitter Ready DMA Enable .")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNDBRK",
        DESC("Send BREAK .")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSDEN",
        DESC("RTS Delta Interrupt Enable .")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXMPTYEN",
        DESC("Transmitter Empty Interrupt Enable .")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IREN",
        DESC("Infrared Interface Enable .")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDMAEN",
        DESC("Receive Ready DMA Enable .")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RRDYEN",
        DESC("Receiver Ready Interrupt Enable .")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICD",
        DESC("Idle Condition Detect .")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDEN",
        DESC("Idle Condition Detected Interrupt Enable .")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRDYEN",
        DESC("Transmitter Ready Interrupt Enable .")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADBR",
        DESC("Automatic Detection of Baud Rate .")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADEN",
        DESC("Automatic Baud Rate Detection Interrupt Enable .")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR2.
static const field_t hw_uart_ucr2[] =
{
    {
        "SRST",
        DESC("Software Reset .")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEN",
        DESC("Receiver Enable .")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXEN",
        DESC("Transmitter Enable .")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATEN",
        DESC("Aging Timer Enable .")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSEN",
        DESC("Request to Send Interrupt Enable.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WS",
        DESC("Word Size .")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STPB",
        DESC("Stop .")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROE",
        DESC("Parity Odd/Even .")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREN",
        DESC("Parity Enable .")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTEC",
        DESC("Request to Send Edge Control .")
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESCEN",
        DESC("Escape Enable .")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTS",
        DESC("Clear to Send .")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTSC",
        DESC("CTS Pin Control .")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRTS",
        DESC("Ignore RTS Pin .")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESCI",
        DESC("Escape Sequence Interrupt Enable .")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR3.
static const field_t hw_uart_ucr3[] =
{
    {
        "ACIEN",
        DESC("Autobaud Counter Interrupt Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVT",
        DESC("Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA "
        "mode.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDMUXSEL",
        DESC("RXD Muxed Input Selected.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTRDEN",
        DESC("Data Terminal Ready Delta Enable .")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWAKEN",
        DESC("Asynchronous WAKE Interrupt Enable.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIRINTEN",
        DESC("Asynchronous IR WAKE Interrupt Enable.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEN",
        DESC("Receive Status Interrupt Enable.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADNIMP",
        DESC("Autobaud Detection Not Improved-.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RI",
        DESC("Ring Indicator .")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCD",
        DESC("Data Carrier Detect .")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSR",
        DESC("Data Set Ready .")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAERREN",
        DESC("Frame Error Interrupt Enable.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PARERREN",
        DESC("Parity Error Interrupt Enable.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTREN",
        DESC("Data Terminal Ready Interrupt Enable .")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPEC",
        DESC("DTR/DSR Interrupt Edge Control .")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR4.
static const field_t hw_uart_ucr4[] =
{
    {
        "DREN",
        DESC("Receive Data Ready Interrupt Enable .")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OREN",
        DESC("Receiver Overrun Interrupt Enable .")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BKEN",
        DESC("BREAK Condition Detected Interrupt Enable .")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCEN",
        DESC("Transmit Complete Interrupt Enable .")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBYP",
        DESC("Low Power Bypass .")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRSC",
        DESC("IR Special Case .")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDDMAEN",
        DESC("DMA IDLE Condition Detected Interrupt Enable Enables/Disables the rece"
        "ive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE"
        " flag in USR2[12]).")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKEN",
        DESC("WAKE Interrupt Enable .")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRI",
        DESC("Serial Infrared Interrupt Enable .")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVR",
        DESC("Invert RXD input in RS-232/RS-485 Mode, d etermine RXD input logic lev"
        "el being sampled in In IrDA mode.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTSTL",
        DESC("CTS Trigger Level .")
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UFCR.
static const field_t hw_uart_ufcr[] =
{
    {
        "RXTL",
        DESC("Receiver Trigger Level .")
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCEDTE",
        DESC("DCE/DTE mode select .")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFDIV",
        DESC("Reference Frequency Divider.")
        7, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXTL",
        DESC("Transmitter Trigger Level .")
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_USR1.
static const field_t hw_uart_usr1[] =
{
    {
        "SAD",
        DESC("RS-485 Slave Address Detected Interrupt Flag.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWAKE",
        DESC("Asynchronous WAKE Interrupt Flag.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIRINT",
        DESC("Asynchronous IR WAKE Interrupt Flag.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDS",
        DESC("Receiver IDLE Interrupt Flag.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DTRD",
        DESC("DTR Delta.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AGTIM",
        DESC("Ageing Timer Interrupt Flag.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RRDY",
        DESC("Receiver Ready Interrupt / DMA Flag .")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRAMERR",
        DESC("Frame Error Interrupt Flag .")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESCF",
        DESC("Escape Sequence Interrupt Flag .")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSD",
        DESC("RTS Delta.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRDY",
        DESC("Transmitter Ready Interrupt / DMA Flag .")
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTSS",
        DESC("RTS Pin Status .")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PARITYERR",
        DESC("Parity Error Interrupt Flag .")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_USR2.
static const field_t hw_uart_usr2[] =
{
    {
        "RDR",
        DESC("Receive Data Ready -Indicates that at least 1 character is received an"
        "d written to the RxFIFO.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ORE",
        DESC("Overrun Error .")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRCD",
        DESC("BREAK Condition Detected .")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDC",
        DESC("Transmitter Complete .")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTSF",
        DESC("RTS Edge Triggered Interrupt Flag.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCDIN",
        DESC("Data Carrier Detect Input .")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DCDDELT",
        DESC("Data Carrier Detect Delta .")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKE",
        DESC("Wake .")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRINT",
        DESC("Serial Infrared Interrupt Flag.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIIN",
        DESC("Ring Indicator Input .")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RIDELT",
        DESC("Ring Indicator Delta .")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACST",
        DESC("Autobaud Counter Stopped .")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE",
        DESC("Idle Condition .")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTRF",
        DESC("DTR edge triggered interrupt flag .")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFE",
        DESC("Transmit Buffer FIFO Empty .")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADET",
        DESC("Automatic Baud Rate Detect Complete .")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UESC.
static const field_t hw_uart_uesc[] =
{
    {
        "ESC_CHAR",
        DESC("UART Escape Character .")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UTIM.
static const field_t hw_uart_utim[] =
{
    {
        "TIM",
        DESC("UART Escape Timer.")
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UBIR.
static const field_t hw_uart_ubir[] =
{
    {
        "INC",
        DESC("Incremental Numerator.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UBMR.
static const field_t hw_uart_ubmr[] =
{
    {
        "MOD",
        DESC("Modulator Denominator.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UBRC.
static const field_t hw_uart_ubrc[] =
{
    {
        "BCNT",
        DESC("Baud Rate Count Register.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_ONEMS.
static const field_t hw_uart_onems[] =
{
    {
        "ONEMS",
        DESC("One Millisecond Register.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UTS.
static const field_t hw_uart_uts[] =
{
    {
        "SOFTRST",
        DESC("Software Reset.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFULL",
        DESC("RxFIFO FULL.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFULL",
        DESC("TxFIFO FULL.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEMPTY",
        DESC("RxFIFO Empty.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXEMPTY",
        DESC("TxFIFO Empty.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDBG",
        DESC("RX_fifo_debug_mode.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOPIR",
        DESC("Loop TX and RX for IR Test (LOOPIR) .")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        DESC("debug_enable .")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        DESC("Loop TX and RX for Test.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRCPERR",
        DESC("Force Parity Error.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UMCR.
static const field_t hw_uart_umcr[] =
{
    {
        "MDEN",
        DESC("9-bit data or Multidrop Mode (RS-485) Enable.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLAM",
        DESC("RS-485 Slave Address Detect Mode Selection.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB8",
        DESC("Transmit RS-485 bit 8 (the ninth bit or 9 th bit).")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SADEN",
        DESC("RS-485 Slave Address Detected Interrupt Enable.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLADDR",
        DESC("RS-485 Slave Address Character.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a UART module.
static const reg_t hw_uart[] =
{
    {
        "URXD",
        DESC("The UART will yield a transfer error on the peripheral bus when core i"
        "s reading URXD register with receive interface disabled (RXEN=0 or UAR"
        "TEN=0).")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_uart_urxd
    },
    {
        "UTXD",
        DESC("The UART will yield a transfer error on the peripheral bus when core i"
        "s writing into UART_URXD register with transmit interface disabled (TX"
        "EN=0 or UARTEN=0).")
        4, // Width in bytes
        0x00000040, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_utxd
    },
    {
        "UCR1",
        DESC("")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_uart_ucr1
    },
    {
        "UCR2",
        DESC("")
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_uart_ucr2
    },
    {
        "UCR3",
        DESC("")
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_uart_ucr3
    },
    {
        "UCR4",
        DESC("")
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_uart_ucr4
    },
    {
        "UFCR",
        DESC("")
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_uart_ufcr
    },
    {
        "USR1",
        DESC("")
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_uart_usr1
    },
    {
        "USR2",
        DESC("")
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_uart_usr2
    },
    {
        "UESC",
        DESC("")
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_uesc
    },
    {
        "UTIM",
        DESC("")
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_utim
    },
    {
        "UBIR",
        DESC("This register can be written by both software and hardware.")
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_ubir
    },
    {
        "UBMR",
        DESC("This register can be written by both software and hardware.")
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_ubmr
    },
    {
        "UBRC",
        DESC("")
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_uart_ubrc
    },
    {
        "ONEMS",
        DESC("This register has been expanded from 16 bits to 24 bits.")
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_onems
    },
    {
        "UTS",
        DESC("")
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_uart_uts
    },
    {
        "UMCR",
        DESC("")
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_uart_umcr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USB_ANALOG
#endif

// Bitfields in register USB_ANALOG_USB1_VBUS_DETECT.
static const field_t hw_usb_analog_usb1_vbus_detect[] =
{
    {
        "VBUSVALID_THRESH",
        DESC("Set the threshold for the VBUSVALID comparator.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_PWRUP_CMPS",
        DESC("Powers up comparators for vbus_valid detector.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        DESC("USB OTG discharge VBUS.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHARGE_VBUS",
        DESC("USB OTG charge VBUS.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CHARGER_RESISTOR",
        DESC("Enable 125k pullup on USB_DP and 375k on USB_DN to provide USB_CHARGER"
        " functionality for USB.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB1_CHRG_DETECT.
static const field_t hw_usb_analog_usb1_chrg_detect[] =
{
    {
        "CHK_CONTACT",
        DESC("")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHK_CHRG_B",
        DESC("")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_B",
        DESC("Control the charger detector.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB1_VBUS_DETECT_STAT.
static const field_t hw_usb_analog_usb1_vbus_detect_stat[] =
{
    {
        "SESSEND",
        DESC("Session End for USB OTG.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BVALID",
        DESC("Indicates VBus is valid for a B-peripheral.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVALID",
        DESC("Indicates VBus is valid for a A-peripheral.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VBUS_VALID",
        DESC("VBus valid for USB OTG.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB1_CHRG_DETECT_STAT.
static const field_t hw_usb_analog_usb1_chrg_detect_stat[] =
{
    {
        "PLUG_CONTACT",
        DESC("State of the USB plug contact detector.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHRG_DETECTED",
        DESC("State of charger detection.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DM_STATE",
        DESC("DM line state output of the charger detector.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DP_STATE",
        DESC("DP line state output of the charger detector.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB1_MISC.
static const field_t hw_usb_analog_usb1_misc[] =
{
    {
        "HS_USE_EXTERNAL_R",
        DESC("Use external resistor to generate the current bias for the high speed "
        "transmitter.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_DEGLITCH",
        DESC("Enable the deglitching circuit of the USB PLL output.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CLK_UTMI",
        DESC("Enables the clk to the UTMI block.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB2_VBUS_DETECT.
static const field_t hw_usb_analog_usb2_vbus_detect[] =
{
    {
        "VBUSVALID_THRESH",
        DESC("Set the threshold for the VBUSVALID comparator.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_PWRUP_CMPS",
        DESC("Powers up comparators for vbus_valid detector.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        DESC("USB OTG discharge VBUS.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHARGE_VBUS",
        DESC("USB OTG charge VBUS.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CHARGER_RESISTOR",
        DESC("Enable 125k pullup on USB_DP and 375k on USB_DN to provide USB_CHARGER"
        " functionality for USB.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB2_CHRG_DETECT.
static const field_t hw_usb_analog_usb2_chrg_detect[] =
{
    {
        "CHK_CONTACT",
        DESC("")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHK_CHRG_B",
        DESC("")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_B",
        DESC("Control the charger detector.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB2_VBUS_DETECT_STAT.
static const field_t hw_usb_analog_usb2_vbus_detect_stat[] =
{
    {
        "SESSEND",
        DESC("Session End for USB OTG.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BVALID",
        DESC("Indicates VBus is valid for a B-peripheral.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVALID",
        DESC("Indicates VBus is valid for a A-peripheral.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VBUS_VALID",
        DESC("VBus valid for USB OTG.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB2_CHRG_DETECT_STAT.
static const field_t hw_usb_analog_usb2_chrg_detect_stat[] =
{
    {
        "PLUG_CONTACT",
        DESC("State of the USB plug contact detector.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHRG_DETECTED",
        DESC("State of charger detection.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DM_STATE",
        DESC("DM line state output of the charger detector.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DP_STATE",
        DESC("DP line state output of the charger detector.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_USB2_MISC.
static const field_t hw_usb_analog_usb2_misc[] =
{
    {
        "HS_USE_EXTERNAL_R",
        DESC("Use external resistor to generate the current bias for the high speed "
        "transmitter.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_DEGLITCH",
        DESC("Enable the deglitching circuit of the USB PLL output.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CLK_UTMI",
        DESC("Enables the clk to the UTMI block.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ANALOG_DIGPROG.
static const field_t hw_usb_analog_digprog[] =
{
    {
        "MINOR",
        DESC("Fixed read-only value reflecting the MINOR field of the RTL version.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        DESC("Fixed read-only value reflecting the MAJOR field of the RTL version.")
        8, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a USB_ANALOG module.
static const reg_t hw_usb_analog[] =
{
    {
        "USB1_VBUS_DETECT",
        DESC("This register defines controls for USB VBUS detect.")
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_usb_analog_usb1_vbus_detect
    },
    {
        "USB1_CHRG_DETECT",
        DESC("This register defines controls for USB charger detect.")
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_usb1_chrg_detect
    },
    {
        "USB1_VBUS_DETECT_STAT",
        DESC("This register defines fields for USB VBUS Detect status.")
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usb_analog_usb1_vbus_detect_stat
    },
    {
        "USB1_CHRG_DETECT_STAT",
        DESC("This register defines fields for USB charger detect status.")
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usb_analog_usb1_chrg_detect_stat
    },
    {
        "USB1_MISC",
        DESC("This register defines controls for USB.")
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_usb1_misc
    },
    {
        "USB2_VBUS_DETECT",
        DESC("This register defines controls for USB VBUS detect.")
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_usb_analog_usb2_vbus_detect
    },
    {
        "USB2_CHRG_DETECT",
        DESC("This register defines controls for USB charger detect.")
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_usb2_chrg_detect
    },
    {
        "USB2_VBUS_DETECT_STAT",
        DESC("This register defines fields for USB VBUS Detect status.")
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usb_analog_usb2_vbus_detect_stat
    },
    {
        "USB2_CHRG_DETECT_STAT",
        DESC("This register defines fields for USB charger detect status.")
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usb_analog_usb2_chrg_detect_stat
    },
    {
        "USB2_MISC",
        DESC("This register defines controls for USB.")
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_analog_usb2_misc
    },
    {
        "DIGPROG",
        DESC("The DIGPROG register returns the digital program ID for the silicon.")
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_analog_digprog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBC
#endif

// Bitfields in register USBC_UOG1_ID.
static const field_t hw_usbc_uog1_id[] =
{
    {
        "ID",
        DESC("Configuration number.")
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        DESC("Complement version of ID")
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        DESC("Revision number of the controller core.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HWGENERAL.
static const field_t hw_usbc_uog1_hwgeneral[] =
{
    {
        "PHYW",
        DESC("Data width of the transciever connected to the controller core.")
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        DESC("Transciever type  PHYM bit reset value: '0000b' for OTG controller cor"
        "e, '0100b' for Host-only controller core.")
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        DESC("Serial interface mode capability  SM bit reset value is '00b'")
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HWHOST.
static const field_t hw_usbc_uog1_hwhost[] =
{
    {
        "HC",
        DESC("Host Capable.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        DESC("The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).")
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HWDEVICE.
static const field_t hw_usbc_uog1_hwdevice[] =
{
    {
        "DC",
        DESC("Device Capable.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVEP",
        DESC("Device Endpoint Number")
        1, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HWTXBUF.
static const field_t hw_usbc_uog1_hwtxbuf[] =
{
    {
        "TXBURST",
        DESC("Default burst size for memory to TX buffer transfer.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        DESC("TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HWRXBUF.
static const field_t hw_usbc_uog1_hwrxbuf[] =
{
    {
        "RXBURST",
        DESC("Default burst size for memory to RX buffer transfer.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        DESC("Buffer total size for all receive endpoints is (2^RXADD).")
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_GPTIMER0LD.
static const field_t hw_usbc_uog1_gptimer0ld[] =
{
    {
        "GPTLD",
        DESC("General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_GPTIMER0CTRL.
static const field_t hw_usbc_uog1_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        DESC("General Purpose Timer Counter.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        DESC("General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software;  In repeat mode, the timer will count down to zero, gener"
        "ate an interrupt and automatically reload the counter value from GPTLD"
        " bits to start again.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        DESC("General Purpose Timer Reset")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        DESC("General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_GPTIMER1LD.
static const field_t hw_usbc_uog1_gptimer1ld[] =
{
    {
        "GPTLD",
        DESC("General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_GPTIMER1CTRL.
static const field_t hw_usbc_uog1_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        DESC("General Purpose Timer Counter.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        DESC("General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        DESC("General Purpose Timer Reset")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        DESC("General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_SBUSCFG.
static const field_t hw_usbc_uog1_sbuscfg[] =
{
    {
        "AHBBRST",
        DESC("AHB master interface Burst configuration  These bits control AHB maste"
        "r transfer type sequence (or priority).")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_CAPLENGTH.
static const field_t hw_usbc_uog1_caplength[] =
{
    {
        "CAPLENGTH",
        DESC("These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HCIVERSION.
static const field_t hw_usbc_uog1_hciversion[] =
{
    {
        "HCIVERSION",
        DESC("Host Controller Interface Version Number  Default value is '10h', whic"
        "h means EHCI rev1.0.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HCSPARAMS.
static const field_t hw_usbc_uog1_hcsparams[] =
{
    {
        "N_PORTS",
        DESC("Number of downstream ports.")
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        DESC("Port Power Control  This field indicates whether the host controller i"
        "mplementation includes port power control.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        DESC("Number of Ports per Companion Controller  This field indicates the num"
        "ber of ports supported per internal Companion Controller.")
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        DESC("Number of Companion Controller (N_CC).")
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        DESC("Port Indicators (P INDICATOR)  This bit indicates whether the ports su"
        "pport port indicator control.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        DESC("Number of Ports per Transaction Translator (N_PTT).")
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        DESC("Number of Transaction Translators (N_TT).")
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_HCCPARAMS.
static const field_t hw_usbc_uog1_hccparams[] =
{
    {
        "ADC",
        DESC("64-bit Addressing Capability  This bit is set '0b' in all controller c"
        "ore, no 64-bit addressing capability is supported.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        DESC("Programmable Frame List Flag  If this bit is set to zero, then the sys"
        "tem software must use a frame list length of 1024 elements with this h"
        "ost controller.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        DESC("Asynchronous Schedule Park Capability  If this bit is set to a one, th"
        "en the host controller supports the park feature for high-speed queue "
        "heads in the Asynchronous Schedule.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        DESC("Isochronous Scheduling Threshold.")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        DESC("EHCI Extended Capabilities Pointer.")
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_DCIVERSION.
static const field_t hw_usbc_uog1_dciversion[] =
{
    {
        "DCIVERSION",
        DESC("Device Controller Interface Version Number  Default value is '01h', wh"
        "ich means rev0.1.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_DCCPARAMS.
static const field_t hw_usbc_uog1_dccparams[] =
{
    {
        "DEN",
        DESC("Device Endpoint Number  This field indicates the number of endpoints b"
        "uilt into the device controller.")
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC",
        DESC("Device Capable  When this bit is 1, this controller is capable of oper"
        "ating as a USB 2.0 device.")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HC",
        DESC("Host Capable  When this bit is 1, this controller is capable of operat"
        "ing as an EHCI compatible USB 2.0 host controller.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_USBCMD.
static const field_t hw_usbc_uog1_usbcmd[] =
{
    {
        "RS",
        DESC("Run/Stop (RS) - Read/Write.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        DESC("Controller Reset (RESET) - Read/Write.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS",
        DESC("See description at bit 15")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        DESC("Periodic Schedule Enable- Read/Write.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        DESC("Asynchronous Schedule Enable - Read/Write.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        DESC("Interrupt on Async Advance Doorbell - Read/Write.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        DESC("Asynchronous Schedule Park Mode Count - Read/Write.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        DESC("Asynchronous Schedule Park Mode Enable - Read/Write.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        DESC("Setup TripWire - Read/Write.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        DESC("Add dTD TripWire - Read/Write.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS1",
        DESC("See also bits 3-2  Frame List Size - (Read/Write or Read Only).")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        DESC("Interrupt Threshold Control -Read/Write.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_USBSTS.
static const field_t hw_usbc_uog1_usbsts[] =
{
    {
        "UI",
        DESC("USB Interrupt (USBINT) - R/WC.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        DESC("USB Error Interrupt (USBERRINT) - R/WC.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        DESC("Port Change Detect - R/WC.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        DESC("Frame List Rollover - R/WC.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        DESC("System Error- R/WC.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        DESC("Interrupt on Async Advance - R/WC.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        DESC("USB Reset Received - R/WC.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        DESC("SOF Received - R/WC.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        DESC("DCSuspend - R/WC.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        DESC("ULPI Interrupt - R/WC.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        DESC("HCHaIted - Read Only.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        DESC("Reclamation - Read Only.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        DESC("Periodic Schedule Status - Read Only.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        DESC("Asynchronous Schedule Status - Read Only.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        DESC("NAK Interrupt Bit--RO.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        DESC("General Purpose Timer Interrupt 0(GPTINT0)--R/WC.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        DESC("General Purpose Timer Interrupt 1(GPTINT1)--R/WC.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_USBINTR.
static const field_t hw_usbc_uog1_usbintr[] =
{
    {
        "UE",
        DESC("USB Interrupt Enalbe  When this bit is one and the UI bit in n_USBSTS "
        "register is a one the controller will issue an interrupt.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        DESC("USB Error Interrupt Enable  When this bit is one and the UEI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        DESC("Port Change Detect Interrupt Enable  When this bit is one and the PCI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        DESC("Frame List Rollover Interrupt Enable  When this bit is one and the FRI"
        " bit in n_USBSTS register is a one the controller will issue an interr"
        "upt.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        DESC("System Error Interrupt Enable  When this bit is one and the SEI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        DESC("Async Advance Interrupt Enable  When this bit is one and the AAI bit i"
        "n n_USBSTS register is a one the controller will issue an interrupt.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        DESC("USB Reset Interrupt Enable  When this bit is one and the URI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        DESC("SOF Received Interrupt Enable  When this bit is one and the SRI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        DESC("Sleep Interrupt Enable  When this bit is one and the SLI bit in n_n_US"
        "BSTS register is a one the controller will issue an interrupt.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        DESC("ULPI Interrupt Enable  When this bit is one and the UPLII bit in n_USB"
        "STS register is a one the controller will issue an interrupt.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        DESC("NAK Interrupt Enable  When this bit is one and the NAKI bit in n_USBST"
        "S register is a one the controller will issue an interrupt.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        DESC("USB Host Asynchronous Interrupt Enable  When this bit is one, and the "
        "UAI bit in the n_USBSTS register is one, host controller will issue an"
        " interrupt at the next interrupt threshold.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        DESC("USB Host Periodic Interrupt Enable  When this bit is one, and the UPI "
        "bit in the n_USBSTS register is one, host controller will issue an int"
        "errupt at the next interrupt threshold.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        DESC("General Purpose Timer #0 Interrupt Enable  When this bit is one and th"
        "e TI0 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        DESC("General Purpose Timer #1 Interrupt Enable  When this bit is one and th"
        "e TI1 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_FRINDEX.
static const field_t hw_usbc_uog1_frindex[] =
{
    {
        "FRINDEX",
        DESC("Frame Index.")
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_PERIODICLISTBASE.
static const field_t hw_usbc_uog1_periodiclistbase[] =
{
    {
        "BASEADR",
        DESC("Base Address (Low).")
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ASYNCLISTADDR.
static const field_t hw_usbc_uog1_asynclistaddr[] =
{
    {
        "ASYBASE",
        DESC("Link Pointer Low (LPL).")
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_BURSTSIZE.
static const field_t hw_usbc_uog1_burstsize[] =
{
    {
        "RXPBURST",
        DESC("Programmable RX Burst Size.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        DESC("Programmable TX Burst Size.")
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_TXFILLTUNING.
static const field_t hw_usbc_uog1_txfilltuning[] =
{
    {
        "TXSCHOH",
        DESC("Scheduler Overhead.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        DESC("Scheduler Health Counter.")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        DESC("FIFO Burst Threshold.")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTNAK.
static const field_t hw_usbc_uog1_endptnak[] =
{
    {
        "EPRN",
        DESC("RX Endpoint NAK - R/WC.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTN",
        DESC("TX Endpoint NAK - R/WC.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTNAKEN.
static const field_t hw_usbc_uog1_endptnaken[] =
{
    {
        "EPRNE",
        DESC("RX Endpoint NAK Enable - R/W.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTNE",
        DESC("TX Endpoint NAK Enable - R/W.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_CONFIGFLAG.
static const field_t hw_usbc_uog1_configflag[] =
{
    {
        "CF",
        DESC("Configure Flag  Host software sets this bit as the last action in its "
        "process of configuring the Host Controller.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_PORTSC1.
static const field_t hw_usbc_uog1_portsc1[] =
{
    {
        "CCS",
        DESC("Current Connect Status-Read Only.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        DESC("Connect Status Change-R/WC.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        DESC("Port Enabled/Disabled-Read/Write.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        DESC("Port Enable/Disable Change-R/WC.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        DESC("Over-current Active-Read Only.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        DESC("Over-current Change-R/WC.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        DESC("Force Port Resume -Read/Write.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        DESC("Suspend - Read/Write or Read Only.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        DESC("Port Reset - Read/Write or Read Only.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        DESC("High-Speed Port - Read Only.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        DESC("Line Status-Read Only.")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        DESC("Port Power (PP)-Read/Write or Read Only.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        DESC("Port Owner-Read/Write.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        DESC("Port Indicator Control - Read/Write.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        DESC("Port Test Control - Read/Write.")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        DESC("Wake on Connect Enable (WKCNNT_E) - Read/Write.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        DESC("Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        DESC("Wake on Over-current Enable (WKOC_E) - Read/Write.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        DESC("PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        DESC("Port Force Full Speed Connect - Read/Write.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS",
        DESC("See description at bits 31-30")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        DESC("Port Speed - Read Only.")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        DESC("Parallel Transceiver Width  This bit has no effect if serial interface"
        " engine is used.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        DESC("Serial Transceiver Select - Read Only  Serial Transceiver Select  1 Se"
        "rial Interface Engine is selected  0 Parallel Interface signals is sel"
        "ected  Serial Interface Engine can be used in combination with UTMI+/U"
        "LPI physical interface to provide FS/LS signaling instead of the paral"
        "lel interface signals.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS1",
        DESC("Bit field {bit25, bit31, bit30}:  \"000b\" UTMI/UTMI+  \"001b\" Reserv"
        "ed  \"010b\" ULPI  \"011b\" Serial/USB 1.1 PHY/IC-USB (FS Only)  \"100"
        "b\" HSIC  All USB port interface modes are listed in this field descri"
        "ption, but not all are supported.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_OTGSC.
static const field_t hw_usbc_uog1_otgsc[] =
{
    {
        "VD",
        DESC("VBUS_Discharge - Read/Write.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VC",
        DESC("VBUS Charge - Read/Write.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OT",
        DESC("OTG Termination - Read/Write.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP",
        DESC("Data Pulsing - Read/Write.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDPU",
        DESC("ID Pullup - Read/Write  This bit provide control over the ID pull-up r"
        "esister; 0 = off, 1 = on [default].")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ID",
        DESC("USB ID - Read Only.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVV",
        DESC("A VBus Valid - Read Only.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASV",
        DESC("A Session Valid - Read Only.")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSV",
        DESC("B Session Valid - Read Only.")
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSE",
        DESC("B Session End - Read Only.")
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "_1MST",
        DESC("1 millisecond timer toggle - Read Only.")
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPS",
        DESC("Data Bus Pulsing Status - Read Only.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDIS",
        DESC("USB ID Interrupt Status - Read/Write.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIS",
        DESC("A VBus Valid Interrupt Status - Read/Write to Clear.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIS",
        DESC("A Session Valid Interrupt Status - Read/Write to Clear.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIS",
        DESC("B Session Valid Interrupt Status - Read/Write to Clear.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIS",
        DESC("B Session End Interrupt Status - Read/Write to Clear.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "_1MSS",
        DESC("1 millisecond timer Interrupt Status - Read/Write to Clear.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIS",
        DESC("Data Pulse Interrupt Status - Read/Write to Clear.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDIE",
        DESC("USB ID Interrupt Enable - Read/Write.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIE",
        DESC("A VBus Valid Interrupt Enable - Read/Write.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIE",
        DESC("A Session Valid Interrupt Enable - Read/Write.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIE",
        DESC("B Session Valid Interrupt Enable - Read/Write.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIE",
        DESC("B Session End Interrupt Enable - Read/Write.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "_1MSE",
        DESC("1 millisecond timer Interrupt Enable - Read/Write")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIE",
        DESC("Data Pulse Interrupt Enable")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_USBMODE.
static const field_t hw_usbc_uog1_usbmode[] =
{
    {
        "CM",
        DESC("Controller Mode - R/WO.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        DESC("Endian Select - Read/Write.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        DESC("Setup Lockout Mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        DESC("Stream Disable Mode.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTSETUPSTAT.
static const field_t hw_usbc_uog1_endptsetupstat[] =
{
    {
        "ENDPTSETUPSTAT",
        DESC("Setup Endpoint Status.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTPRIME.
static const field_t hw_usbc_uog1_endptprime[] =
{
    {
        "PERB",
        DESC("Prime Endpoint Receive Buffer - R/WS.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PETB",
        DESC("Prime Endpoint Transmit Buffer - R/WS.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTFLUSH.
static const field_t hw_usbc_uog1_endptflush[] =
{
    {
        "FERB",
        DESC("Flush Endpoint Receive Buffer - R/WS.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FETB",
        DESC("Flush Endpoint Transmit Buffer - R/WS.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTSTAT.
static const field_t hw_usbc_uog1_endptstat[] =
{
    {
        "ERBR",
        DESC("Endpoint Receive Buffer Ready -- Read Only.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ETBR",
        DESC("Endpoint Transmit Buffer Ready -- Read Only.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCOMPLETE.
static const field_t hw_usbc_uog1_endptcomplete[] =
{
    {
        "ERCE",
        DESC("Endpoint Receive Complete Event - RW/C.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETCE",
        DESC("Endpoint Transmit Complete Event - R/WC.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL0.
static const field_t hw_usbc_uog1_endptctrl0[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  Endpoint0 is fixed as a Con"
        "trol End Point.")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  1 Enabled  Endpoint0 is always enabled.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK [Default]  1 End Point "
        "Stalled  Software can write a one to this bit to force the endpoint to"
        " return a STALL handshake to the Host.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 - Control  Endpoint0 is fixed as a C"
        "ontrol End Point.")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  1 Enabled  Endpoint0 is always enabled.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL1.
static const field_t hw_usbc_uog1_endptctrl1[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL2.
static const field_t hw_usbc_uog1_endptctrl2[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL3.
static const field_t hw_usbc_uog1_endptctrl3[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL4.
static const field_t hw_usbc_uog1_endptctrl4[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL5.
static const field_t hw_usbc_uog1_endptctrl5[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL6.
static const field_t hw_usbc_uog1_endptctrl6[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG1_ENDPTCTRL7.
static const field_t hw_usbc_uog1_endptctrl7[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ID.
static const field_t hw_usbc_uog2_id[] =
{
    {
        "ID",
        DESC("Configuration number.")
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        DESC("Complement version of ID")
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        DESC("Revision number of the controller core.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HWGENERAL.
static const field_t hw_usbc_uog2_hwgeneral[] =
{
    {
        "PHYW",
        DESC("Data width of the transciever connected to the controller core.")
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        DESC("Transciever type  PHYM bit reset value: '0000b' for OTG controller cor"
        "e, '0100b' for Host-only controller core.")
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        DESC("Serial interface mode capability  SM bit reset value is '00b'")
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HWHOST.
static const field_t hw_usbc_uog2_hwhost[] =
{
    {
        "HC",
        DESC("Host Capable.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        DESC("The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).")
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HWDEVICE.
static const field_t hw_usbc_uog2_hwdevice[] =
{
    {
        "DC",
        DESC("Device Capable.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVEP",
        DESC("Device Endpoint Number")
        1, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HWTXBUF.
static const field_t hw_usbc_uog2_hwtxbuf[] =
{
    {
        "TXBURST",
        DESC("Default burst size for memory to TX buffer transfer.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        DESC("TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HWRXBUF.
static const field_t hw_usbc_uog2_hwrxbuf[] =
{
    {
        "RXBURST",
        DESC("Default burst size for memory to RX buffer transfer.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        DESC("Buffer total size for all receive endpoints is (2^RXADD).")
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_GPTIMER0LD.
static const field_t hw_usbc_uog2_gptimer0ld[] =
{
    {
        "GPTLD",
        DESC("General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_GPTIMER0CTRL.
static const field_t hw_usbc_uog2_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        DESC("General Purpose Timer Counter.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        DESC("General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software;  In repeat mode, the timer will count down to zero, gener"
        "ate an interrupt and automatically reload the counter value from GPTLD"
        " bits to start again.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        DESC("General Purpose Timer Reset")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        DESC("General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_GPTIMER1LD.
static const field_t hw_usbc_uog2_gptimer1ld[] =
{
    {
        "GPTLD",
        DESC("General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_GPTIMER1CTRL.
static const field_t hw_usbc_uog2_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        DESC("General Purpose Timer Counter.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        DESC("General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        DESC("General Purpose Timer Reset")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        DESC("General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_SBUSCFG.
static const field_t hw_usbc_uog2_sbuscfg[] =
{
    {
        "AHBBRST",
        DESC("AHB master interface Burst configuration  These bits control AHB maste"
        "r transfer type sequence (or priority).")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_CAPLENGTH.
static const field_t hw_usbc_uog2_caplength[] =
{
    {
        "CAPLENGTH",
        DESC("These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HCIVERSION.
static const field_t hw_usbc_uog2_hciversion[] =
{
    {
        "HCIVERSION",
        DESC("Host Controller Interface Version Number  Default value is '10h', whic"
        "h means EHCI rev1.0.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HCSPARAMS.
static const field_t hw_usbc_uog2_hcsparams[] =
{
    {
        "N_PORTS",
        DESC("Number of downstream ports.")
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        DESC("Port Power Control  This field indicates whether the host controller i"
        "mplementation includes port power control.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        DESC("Number of Ports per Companion Controller  This field indicates the num"
        "ber of ports supported per internal Companion Controller.")
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        DESC("Number of Companion Controller (N_CC).")
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        DESC("Port Indicators (P INDICATOR)  This bit indicates whether the ports su"
        "pport port indicator control.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        DESC("Number of Ports per Transaction Translator (N_PTT).")
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        DESC("Number of Transaction Translators (N_TT).")
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_HCCPARAMS.
static const field_t hw_usbc_uog2_hccparams[] =
{
    {
        "ADC",
        DESC("64-bit Addressing Capability  This bit is set '0b' in all controller c"
        "ore, no 64-bit addressing capability is supported.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        DESC("Programmable Frame List Flag  If this bit is set to zero, then the sys"
        "tem software must use a frame list length of 1024 elements with this h"
        "ost controller.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        DESC("Asynchronous Schedule Park Capability  If this bit is set to a one, th"
        "en the host controller supports the park feature for high-speed queue "
        "heads in the Asynchronous Schedule.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        DESC("Isochronous Scheduling Threshold.")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        DESC("EHCI Extended Capabilities Pointer.")
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_DCIVERSION.
static const field_t hw_usbc_uog2_dciversion[] =
{
    {
        "DCIVERSION",
        DESC("Device Controller Interface Version Number  Default value is '01h', wh"
        "ich means rev0.1.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_DCCPARAMS.
static const field_t hw_usbc_uog2_dccparams[] =
{
    {
        "DEN",
        DESC("Device Endpoint Number  This field indicates the number of endpoints b"
        "uilt into the device controller.")
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC",
        DESC("Device Capable  When this bit is 1, this controller is capable of oper"
        "ating as a USB 2.0 device.")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HC",
        DESC("Host Capable  When this bit is 1, this controller is capable of operat"
        "ing as an EHCI compatible USB 2.0 host controller.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_USBCMD.
static const field_t hw_usbc_uog2_usbcmd[] =
{
    {
        "RS",
        DESC("Run/Stop (RS) - Read/Write.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        DESC("Controller Reset (RESET) - Read/Write.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS",
        DESC("See description at bit 15")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        DESC("Periodic Schedule Enable- Read/Write.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        DESC("Asynchronous Schedule Enable - Read/Write.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        DESC("Interrupt on Async Advance Doorbell - Read/Write.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        DESC("Asynchronous Schedule Park Mode Count - Read/Write.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        DESC("Asynchronous Schedule Park Mode Enable - Read/Write.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        DESC("Setup TripWire - Read/Write.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        DESC("Add dTD TripWire - Read/Write.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS1",
        DESC("See also bits 3-2  Frame List Size - (Read/Write or Read Only).")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        DESC("Interrupt Threshold Control -Read/Write.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_USBSTS.
static const field_t hw_usbc_uog2_usbsts[] =
{
    {
        "UI",
        DESC("USB Interrupt (USBINT) - R/WC.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        DESC("USB Error Interrupt (USBERRINT) - R/WC.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        DESC("Port Change Detect - R/WC.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        DESC("Frame List Rollover - R/WC.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        DESC("System Error- R/WC.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        DESC("Interrupt on Async Advance - R/WC.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        DESC("USB Reset Received - R/WC.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        DESC("SOF Received - R/WC.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        DESC("DCSuspend - R/WC.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        DESC("ULPI Interrupt - R/WC.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        DESC("HCHaIted - Read Only.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        DESC("Reclamation - Read Only.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        DESC("Periodic Schedule Status - Read Only.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        DESC("Asynchronous Schedule Status - Read Only.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        DESC("NAK Interrupt Bit--RO.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        DESC("General Purpose Timer Interrupt 0(GPTINT0)--R/WC.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        DESC("General Purpose Timer Interrupt 1(GPTINT1)--R/WC.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_USBINTR.
static const field_t hw_usbc_uog2_usbintr[] =
{
    {
        "UE",
        DESC("USB Interrupt Enalbe  When this bit is one and the UI bit in n_USBSTS "
        "register is a one the controller will issue an interrupt.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        DESC("USB Error Interrupt Enable  When this bit is one and the UEI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        DESC("Port Change Detect Interrupt Enable  When this bit is one and the PCI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        DESC("Frame List Rollover Interrupt Enable  When this bit is one and the FRI"
        " bit in n_USBSTS register is a one the controller will issue an interr"
        "upt.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        DESC("System Error Interrupt Enable  When this bit is one and the SEI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        DESC("Async Advance Interrupt Enable  When this bit is one and the AAI bit i"
        "n n_USBSTS register is a one the controller will issue an interrupt.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        DESC("USB Reset Interrupt Enable  When this bit is one and the URI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        DESC("SOF Received Interrupt Enable  When this bit is one and the SRI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        DESC("Sleep Interrupt Enable  When this bit is one and the SLI bit in n_n_US"
        "BSTS register is a one the controller will issue an interrupt.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        DESC("ULPI Interrupt Enable  When this bit is one and the UPLII bit in n_USB"
        "STS register is a one the controller will issue an interrupt.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        DESC("NAK Interrupt Enable  When this bit is one and the NAKI bit in n_USBST"
        "S register is a one the controller will issue an interrupt.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        DESC("USB Host Asynchronous Interrupt Enable  When this bit is one, and the "
        "UAI bit in the n_USBSTS register is one, host controller will issue an"
        " interrupt at the next interrupt threshold.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        DESC("USB Host Periodic Interrupt Enable  When this bit is one, and the UPI "
        "bit in the n_USBSTS register is one, host controller will issue an int"
        "errupt at the next interrupt threshold.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        DESC("General Purpose Timer #0 Interrupt Enable  When this bit is one and th"
        "e TI0 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        DESC("General Purpose Timer #1 Interrupt Enable  When this bit is one and th"
        "e TI1 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_FRINDEX.
static const field_t hw_usbc_uog2_frindex[] =
{
    {
        "FRINDEX",
        DESC("Frame Index.")
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_PERIODICLISTBASE.
static const field_t hw_usbc_uog2_periodiclistbase[] =
{
    {
        "BASEADR",
        DESC("Base Address (Low).")
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ASYNCLISTADDR.
static const field_t hw_usbc_uog2_asynclistaddr[] =
{
    {
        "ASYBASE",
        DESC("Link Pointer Low (LPL).")
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_BURSTSIZE.
static const field_t hw_usbc_uog2_burstsize[] =
{
    {
        "RXPBURST",
        DESC("Programmable RX Burst Size.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        DESC("Programmable TX Burst Size.")
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_TXFILLTUNING.
static const field_t hw_usbc_uog2_txfilltuning[] =
{
    {
        "TXSCHOH",
        DESC("Scheduler Overhead.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        DESC("Scheduler Health Counter.")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        DESC("FIFO Burst Threshold.")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTNAK.
static const field_t hw_usbc_uog2_endptnak[] =
{
    {
        "EPRN",
        DESC("RX Endpoint NAK - R/WC.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTN",
        DESC("TX Endpoint NAK - R/WC.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTNAKEN.
static const field_t hw_usbc_uog2_endptnaken[] =
{
    {
        "EPRNE",
        DESC("RX Endpoint NAK Enable - R/W.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTNE",
        DESC("TX Endpoint NAK Enable - R/W.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_CONFIGFLAG.
static const field_t hw_usbc_uog2_configflag[] =
{
    {
        "CF",
        DESC("Configure Flag  Host software sets this bit as the last action in its "
        "process of configuring the Host Controller.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_PORTSC1.
static const field_t hw_usbc_uog2_portsc1[] =
{
    {
        "CCS",
        DESC("Current Connect Status-Read Only.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        DESC("Connect Status Change-R/WC.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        DESC("Port Enabled/Disabled-Read/Write.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        DESC("Port Enable/Disable Change-R/WC.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        DESC("Over-current Active-Read Only.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        DESC("Over-current Change-R/WC.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        DESC("Force Port Resume -Read/Write.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        DESC("Suspend - Read/Write or Read Only.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        DESC("Port Reset - Read/Write or Read Only.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        DESC("High-Speed Port - Read Only.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        DESC("Line Status-Read Only.")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        DESC("Port Power (PP)-Read/Write or Read Only.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        DESC("Port Owner-Read/Write.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        DESC("Port Indicator Control - Read/Write.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        DESC("Port Test Control - Read/Write.")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        DESC("Wake on Connect Enable (WKCNNT_E) - Read/Write.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        DESC("Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        DESC("Wake on Over-current Enable (WKOC_E) - Read/Write.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        DESC("PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        DESC("Port Force Full Speed Connect - Read/Write.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS",
        DESC("See description at bits 31-30")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        DESC("Port Speed - Read Only.")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        DESC("Parallel Transceiver Width  This bit has no effect if serial interface"
        " engine is used.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        DESC("Serial Transceiver Select - Read Only  Serial Transceiver Select  1 Se"
        "rial Interface Engine is selected  0 Parallel Interface signals is sel"
        "ected  Serial Interface Engine can be used in combination with UTMI+/U"
        "LPI physical interface to provide FS/LS signaling instead of the paral"
        "lel interface signals.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS1",
        DESC("Bit field {bit25, bit31, bit30}:  \"000b\" UTMI/UTMI+  \"001b\" Reserv"
        "ed  \"010b\" ULPI  \"011b\" Serial/USB 1.1 PHY/IC-USB (FS Only)  \"100"
        "b\" HSIC  All USB port interface modes are listed in this field descri"
        "ption, but not all are supported.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_OTGSC.
static const field_t hw_usbc_uog2_otgsc[] =
{
    {
        "VD",
        DESC("VBUS_Discharge - Read/Write.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VC",
        DESC("VBUS Charge - Read/Write.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OT",
        DESC("OTG Termination - Read/Write.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP",
        DESC("Data Pulsing - Read/Write.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDPU",
        DESC("ID Pullup - Read/Write  This bit provide control over the ID pull-up r"
        "esister; 0 = off, 1 = on [default].")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ID",
        DESC("USB ID - Read Only.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVV",
        DESC("A VBus Valid - Read Only.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASV",
        DESC("A Session Valid - Read Only.")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSV",
        DESC("B Session Valid - Read Only.")
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSE",
        DESC("B Session End - Read Only.")
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "_1MST",
        DESC("1 millisecond timer toggle - Read Only.")
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPS",
        DESC("Data Bus Pulsing Status - Read Only.")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDIS",
        DESC("USB ID Interrupt Status - Read/Write.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIS",
        DESC("A VBus Valid Interrupt Status - Read/Write to Clear.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIS",
        DESC("A Session Valid Interrupt Status - Read/Write to Clear.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIS",
        DESC("B Session Valid Interrupt Status - Read/Write to Clear.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIS",
        DESC("B Session End Interrupt Status - Read/Write to Clear.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "_1MSS",
        DESC("1 millisecond timer Interrupt Status - Read/Write to Clear.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIS",
        DESC("Data Pulse Interrupt Status - Read/Write to Clear.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDIE",
        DESC("USB ID Interrupt Enable - Read/Write.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIE",
        DESC("A VBus Valid Interrupt Enable - Read/Write.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIE",
        DESC("A Session Valid Interrupt Enable - Read/Write.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIE",
        DESC("B Session Valid Interrupt Enable - Read/Write.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIE",
        DESC("B Session End Interrupt Enable - Read/Write.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "_1MSE",
        DESC("1 millisecond timer Interrupt Enable - Read/Write")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIE",
        DESC("Data Pulse Interrupt Enable")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_USBMODE.
static const field_t hw_usbc_uog2_usbmode[] =
{
    {
        "CM",
        DESC("Controller Mode - R/WO.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        DESC("Endian Select - Read/Write.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        DESC("Setup Lockout Mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        DESC("Stream Disable Mode.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTSETUPSTAT.
static const field_t hw_usbc_uog2_endptsetupstat[] =
{
    {
        "ENDPTSETUPSTAT",
        DESC("Setup Endpoint Status.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTPRIME.
static const field_t hw_usbc_uog2_endptprime[] =
{
    {
        "PERB",
        DESC("Prime Endpoint Receive Buffer - R/WS.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PETB",
        DESC("Prime Endpoint Transmit Buffer - R/WS.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTFLUSH.
static const field_t hw_usbc_uog2_endptflush[] =
{
    {
        "FERB",
        DESC("Flush Endpoint Receive Buffer - R/WS.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FETB",
        DESC("Flush Endpoint Transmit Buffer - R/WS.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTSTAT.
static const field_t hw_usbc_uog2_endptstat[] =
{
    {
        "ERBR",
        DESC("Endpoint Receive Buffer Ready -- Read Only.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ETBR",
        DESC("Endpoint Transmit Buffer Ready -- Read Only.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCOMPLETE.
static const field_t hw_usbc_uog2_endptcomplete[] =
{
    {
        "ERCE",
        DESC("Endpoint Receive Complete Event - RW/C.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETCE",
        DESC("Endpoint Transmit Complete Event - R/WC.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL0.
static const field_t hw_usbc_uog2_endptctrl0[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  Endpoint0 is fixed as a Con"
        "trol End Point.")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  1 Enabled  Endpoint0 is always enabled.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK [Default]  1 End Point "
        "Stalled  Software can write a one to this bit to force the endpoint to"
        " return a STALL handshake to the Host.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 - Control  Endpoint0 is fixed as a C"
        "ontrol End Point.")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  1 Enabled  Endpoint0 is always enabled.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL1.
static const field_t hw_usbc_uog2_endptctrl1[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL2.
static const field_t hw_usbc_uog2_endptctrl2[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL3.
static const field_t hw_usbc_uog2_endptctrl3[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL4.
static const field_t hw_usbc_uog2_endptctrl4[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL5.
static const field_t hw_usbc_uog2_endptctrl5[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL6.
static const field_t hw_usbc_uog2_endptctrl6[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UOG2_ENDPTCTRL7.
static const field_t hw_usbc_uog2_endptctrl7[] =
{
    {
        "RXS",
        DESC("RX Endpoint Stall - Read/Write  0 End Point OK.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        DESC("RX Endpoint Data Sink - Read/Write - TBD  0 Dual Port Memory Buffer/DM"
        "A Engine [Default]  Should always be written as zero.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        DESC("RX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Reserved")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        DESC("RX Data Toggle Inhibit  0 Disabled [Default]  1 Enabled  This bit is o"
        "nly used for test and should always be written as zero.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        DESC("RX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the ho"
        "st and device.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        DESC("RX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        DESC("TX Endpoint Stall - Read/Write  0 End Point OK  1 End Point Stalled  T"
        "his bit is set automatically upon receipt of a SETUP request if this E"
        "ndpoint is not configured as a Control Endpoint.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        DESC("TX Endpoint Data Source - Read/Write  0 Dual Port Memory Buffer/DMA En"
        "gine [DEFAULT]  Should always be written as 0.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        DESC("TX Endpoint Type - Read/Write  00 Control  01 Isochronous  10 Bulk  11"
        " Interrupt")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        DESC("TX Data Toggle Inhibit  0 PID Sequencing Enabled.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        DESC("TX Data Toggle Reset (WS)  Write 1 - Reset PID Sequence  Whenever a co"
        "nfiguration event is received for this Endpoint, software must write a"
        " one to this bit in order to synchronize the data PID's between the Ho"
        "st and device.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        DESC("TX Endpoint Enable  0 Disabled [Default]  1 Enabled  An Endpoint shoul"
        "d be enabled only after it has been configured.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_ID.
static const field_t hw_usbc_uh1_id[] =
{
    {
        "ID",
        DESC("Configuration number.")
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        DESC("Complement version of ID")
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        DESC("Revision number of the controller core.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HWGENERAL.
static const field_t hw_usbc_uh1_hwgeneral[] =
{
    {
        "PHYW",
        DESC("Data width of the transciever connected to the controller core.")
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        DESC("Transciever type  PHYM bit reset value: '0000b' for OTG controller cor"
        "e, '0100b' for Host-only controller core.")
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        DESC("Serial interface mode capability  SM bit reset value is '00b'")
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HWHOST.
static const field_t hw_usbc_uh1_hwhost[] =
{
    {
        "HC",
        DESC("Host Capable.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        DESC("The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).")
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HWTXBUF.
static const field_t hw_usbc_uh1_hwtxbuf[] =
{
    {
        "TXBURST",
        DESC("Default burst size for memory to TX buffer transfer.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        DESC("TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HWRXBUF.
static const field_t hw_usbc_uh1_hwrxbuf[] =
{
    {
        "RXBURST",
        DESC("Default burst size for memory to RX buffer transfer.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        DESC("Buffer total size for all receive endpoints is (2^RXADD).")
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_GPTIMER0LD.
static const field_t hw_usbc_uh1_gptimer0ld[] =
{
    {
        "GPTLD",
        DESC("General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_GPTIMER0CTRL.
static const field_t hw_usbc_uh1_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        DESC("General Purpose Timer Counter.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        DESC("General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software;  In repeat mode, the timer will count down to zero, gener"
        "ate an interrupt and automatically reload the counter value from GPTLD"
        " bits to start again.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        DESC("General Purpose Timer Reset")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        DESC("General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_GPTIMER1LD.
static const field_t hw_usbc_uh1_gptimer1ld[] =
{
    {
        "GPTLD",
        DESC("General Purpose Timer Load Value  These bit fields are loaded to GPTCN"
        "T bits when GPTRST bit is set '1b'.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_GPTIMER1CTRL.
static const field_t hw_usbc_uh1_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        DESC("General Purpose Timer Counter.")
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        DESC("General Purpose Timer Mode  In one shot mode, the timer will count dow"
        "n to zero, generate an interrupt, and stop until the counter is reset "
        "by software.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        DESC("General Purpose Timer Reset")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        DESC("General Purpose Timer Run  GPTCNT bits are not effected when setting o"
        "r clearing this bit.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_SBUSCFG.
static const field_t hw_usbc_uh1_sbuscfg[] =
{
    {
        "AHBBRST",
        DESC("AHB master interface Burst configuration  These bits control AHB maste"
        "r transfer type sequence (or priority).")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_CAPLENGTH.
static const field_t hw_usbc_uh1_caplength[] =
{
    {
        "CAPLENGTH",
        DESC("These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.")
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HCIVERSION.
static const field_t hw_usbc_uh1_hciversion[] =
{
    {
        "HCIVERSION",
        DESC("Host Controller Interface Version Number  Default value is '10h', whic"
        "h means EHCI rev1.0.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HCSPARAMS.
static const field_t hw_usbc_uh1_hcsparams[] =
{
    {
        "N_PORTS",
        DESC("Number of downstream ports.")
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        DESC("Port Power Control  This field indicates whether the host controller i"
        "mplementation includes port power control.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        DESC("Number of Ports per Companion Controller  This field indicates the num"
        "ber of ports supported per internal Companion Controller.")
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        DESC("Number of Companion Controller (N_CC).")
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        DESC("Port Indicators (P INDICATOR)  This bit indicates whether the ports su"
        "pport port indicator control.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        DESC("Number of Ports per Transaction Translator (N_PTT).")
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        DESC("Number of Transaction Translators (N_TT).")
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_HCCPARAMS.
static const field_t hw_usbc_uh1_hccparams[] =
{
    {
        "ADC",
        DESC("64-bit Addressing Capability  This bit is set '0b' in all controller c"
        "ore, no 64-bit addressing capability is supported.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        DESC("Programmable Frame List Flag  If this bit is set to zero, then the sys"
        "tem software must use a frame list length of 1024 elements with this h"
        "ost controller.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        DESC("Asynchronous Schedule Park Capability  If this bit is set to a one, th"
        "en the host controller supports the park feature for high-speed queue "
        "heads in the Asynchronous Schedule.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        DESC("Isochronous Scheduling Threshold.")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        DESC("EHCI Extended Capabilities Pointer.")
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_USBCMD.
static const field_t hw_usbc_uh1_usbcmd[] =
{
    {
        "RS",
        DESC("Run/Stop (RS) - Read/Write.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        DESC("Controller Reset (RESET) - Read/Write.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS",
        DESC("See description at bit 15")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        DESC("Periodic Schedule Enable- Read/Write.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        DESC("Asynchronous Schedule Enable - Read/Write.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        DESC("Interrupt on Async Advance Doorbell - Read/Write.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        DESC("Asynchronous Schedule Park Mode Count - Read/Write.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        DESC("Asynchronous Schedule Park Mode Enable - Read/Write.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        DESC("Setup TripWire - Read/Write.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        DESC("Add dTD TripWire - Read/Write.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS1",
        DESC("See also bits 3-2  Frame List Size - (Read/Write or Read Only).")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        DESC("Interrupt Threshold Control -Read/Write.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_USBSTS.
static const field_t hw_usbc_uh1_usbsts[] =
{
    {
        "UI",
        DESC("USB Interrupt (USBINT) - R/WC.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        DESC("USB Error Interrupt (USBERRINT) - R/WC.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        DESC("Port Change Detect - R/WC.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        DESC("Frame List Rollover - R/WC.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        DESC("System Error- R/WC.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        DESC("Interrupt on Async Advance - R/WC.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        DESC("USB Reset Received - R/WC.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        DESC("SOF Received - R/WC.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        DESC("DCSuspend - R/WC.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        DESC("ULPI Interrupt - R/WC.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        DESC("HCHaIted - Read Only.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        DESC("Reclamation - Read Only.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        DESC("Periodic Schedule Status - Read Only.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        DESC("Asynchronous Schedule Status - Read Only.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        DESC("NAK Interrupt Bit--RO.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        DESC("General Purpose Timer Interrupt 0(GPTINT0)--R/WC.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        DESC("General Purpose Timer Interrupt 1(GPTINT1)--R/WC.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_USBINTR.
static const field_t hw_usbc_uh1_usbintr[] =
{
    {
        "UE",
        DESC("USB Interrupt Enalbe  When this bit is one and the UI bit in n_USBSTS "
        "register is a one the controller will issue an interrupt.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        DESC("USB Error Interrupt Enable  When this bit is one and the UEI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        DESC("Port Change Detect Interrupt Enable  When this bit is one and the PCI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        DESC("Frame List Rollover Interrupt Enable  When this bit is one and the FRI"
        " bit in n_USBSTS register is a one the controller will issue an interr"
        "upt.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        DESC("System Error Interrupt Enable  When this bit is one and the SEI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        DESC("Async Advance Interrupt Enable  When this bit is one and the AAI bit i"
        "n n_USBSTS register is a one the controller will issue an interrupt.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        DESC("USB Reset Interrupt Enable  When this bit is one and the URI bit in n_"
        "USBSTS register is a one the controller will issue an interrupt.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        DESC("SOF Received Interrupt Enable  When this bit is one and the SRI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        DESC("Sleep Interrupt Enable  When this bit is one and the SLI bit in n_n_US"
        "BSTS register is a one the controller will issue an interrupt.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        DESC("ULPI Interrupt Enable  When this bit is one and the UPLII bit in n_USB"
        "STS register is a one the controller will issue an interrupt.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        DESC("NAK Interrupt Enable  When this bit is one and the NAKI bit in n_USBST"
        "S register is a one the controller will issue an interrupt.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        DESC("USB Host Asynchronous Interrupt Enable  When this bit is one, and the "
        "UAI bit in the n_USBSTS register is one, host controller will issue an"
        " interrupt at the next interrupt threshold.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        DESC("USB Host Periodic Interrupt Enable  When this bit is one, and the UPI "
        "bit in the n_USBSTS register is one, host controller will issue an int"
        "errupt at the next interrupt threshold.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        DESC("General Purpose Timer #0 Interrupt Enable  When this bit is one and th"
        "e TI0 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        DESC("General Purpose Timer #1 Interrupt Enable  When this bit is one and th"
        "e TI1 bit in n_USBSTS register is a one the controller will issue an i"
        "nterrupt.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_FRINDEX.
static const field_t hw_usbc_uh1_frindex[] =
{
    {
        "FRINDEX",
        DESC("Frame Index.")
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_PERIODICLISTBASE.
static const field_t hw_usbc_uh1_periodiclistbase[] =
{
    {
        "BASEADR",
        DESC("Base Address (Low).")
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_ASYNCLISTADDR.
static const field_t hw_usbc_uh1_asynclistaddr[] =
{
    {
        "ASYBASE",
        DESC("Link Pointer Low (LPL).")
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_BURSTSIZE.
static const field_t hw_usbc_uh1_burstsize[] =
{
    {
        "RXPBURST",
        DESC("Programmable RX Burst Size.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        DESC("Programmable TX Burst Size.")
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_TXFILLTUNING.
static const field_t hw_usbc_uh1_txfilltuning[] =
{
    {
        "TXSCHOH",
        DESC("Scheduler Overhead.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        DESC("Scheduler Health Counter.")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        DESC("FIFO Burst Threshold.")
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_CONFIGFLAG.
static const field_t hw_usbc_uh1_configflag[] =
{
    {
        "CF",
        DESC("Configure Flag  Host software sets this bit as the last action in its "
        "process of configuring the Host Controller.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_PORTSC1.
static const field_t hw_usbc_uh1_portsc1[] =
{
    {
        "CCS",
        DESC("Current Connect Status-Read Only.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        DESC("Connect Status Change-R/WC.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        DESC("Port Enabled/Disabled-Read/Write.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        DESC("Port Enable/Disable Change-R/WC.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        DESC("Over-current Active-Read Only.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        DESC("Over-current Change-R/WC.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        DESC("Force Port Resume -Read/Write.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        DESC("Suspend - Read/Write or Read Only.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        DESC("Port Reset - Read/Write or Read Only.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        DESC("High-Speed Port - Read Only.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        DESC("Line Status-Read Only.")
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        DESC("Port Power (PP)-Read/Write or Read Only.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        DESC("Port Owner-Read/Write.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        DESC("Port Indicator Control - Read/Write.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        DESC("Port Test Control - Read/Write.")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        DESC("Wake on Connect Enable (WKCNNT_E) - Read/Write.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        DESC("Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        DESC("Wake on Over-current Enable (WKOC_E) - Read/Write.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        DESC("PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        DESC("Port Force Full Speed Connect - Read/Write.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS",
        DESC("See description at bits 31-30")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        DESC("Port Speed - Read Only.")
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        DESC("Parallel Transceiver Width  This bit has no effect if serial interface"
        " engine is used.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        DESC("Serial Transceiver Select - Read Only  Serial Transceiver Select  1 Se"
        "rial Interface Engine is selected  0 Parallel Interface signals is sel"
        "ected  Serial Interface Engine can be used in combination with UTMI+/U"
        "LPI physical interface to provide FS/LS signaling instead of the paral"
        "lel interface signals.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS1",
        DESC("Bit field {bit25, bit31, bit30}:  \"000b\" UTMI/UTMI+  \"001b\" Reserv"
        "ed  \"010b\" ULPI  \"011b\" Serial/USB 1.1 PHY/IC-USB (FS Only)  \"100"
        "b\" HSIC  All USB port interface modes are listed in this field descri"
        "ption, but not all are supported.")
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBC_UH1_USBMODE.
static const field_t hw_usbc_uh1_usbmode[] =
{
    {
        "CM",
        DESC("Controller Mode - R/WO.")
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        DESC("Endian Select - Read/Write.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        DESC("Setup Lockout Mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        DESC("Stream Disable Mode.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBC module.
static const reg_t hw_usbc[] =
{
    {
        "UOG1_ID",
        DESC("The ID register identifies the USB 2.0 High-Speed core and its revisio"
        "n.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog1_id
    },
    {
        "UOG1_HWGENERAL",
        DESC("General hardware parameters as defined in System Level Issues and Core"
        " Configuration.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog1_hwgeneral
    },
    {
        "UOG1_HWHOST",
        DESC("")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_hwhost
    },
    {
        "UOG1_HWDEVICE",
        DESC("This register is only available in OTG core.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_hwdevice
    },
    {
        "UOG1_HWTXBUF",
        DESC("")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_hwtxbuf
    },
    {
        "UOG1_HWRXBUF",
        DESC("")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_hwrxbuf
    },
    {
        "UOG1_GPTIMER0LD",
        DESC("This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_gptimer0ld
    },
    {
        "UOG1_GPTIMER0CTRL",
        DESC("This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.")
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog1_gptimer0ctrl
    },
    {
        "UOG1_GPTIMER1LD",
        DESC("This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.")
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_gptimer1ld
    },
    {
        "UOG1_GPTIMER1CTRL",
        DESC("This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.")
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog1_gptimer1ctrl
    },
    {
        "UOG1_SBUSCFG",
        DESC("")
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_sbuscfg
    },
    {
        "UOG1_CAPLENGTH",
        DESC("The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.")
        1, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_caplength
    },
    {
        "UOG1_HCIVERSION",
        DESC("This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.")
        2, // Width in bytes
        0x00000102, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_hciversion
    },
    {
        "UOG1_HCSPARAMS",
        DESC("The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).")
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usbc_uog1_hcsparams
    },
    {
        "UOG1_HCCPARAMS",
        DESC("This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.")
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usbc_uog1_hccparams
    },
    {
        "UOG1_DCIVERSION",
        DESC("This register indicates the two-byte BCD encoding of the device contro"
        "ller interface version number.")
        2, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_dciversion
    },
    {
        "UOG1_DCCPARAMS",
        DESC("These fields describe the overall device capability of the controller.")
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog1_dccparams
    },
    {
        "UOG1_USBCMD",
        DESC("The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.")
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_usbcmd
    },
    {
        "UOG1_USBSTS",
        DESC("This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.")
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usbc_uog1_usbsts
    },
    {
        "UOG1_USBINTR",
        DESC("The interrupts to software are enabled with this register.")
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbc_uog1_usbintr
    },
    {
        "UOG1_FRINDEX",
        DESC("This register is used by the host controller to index the periodic fra"
        "me list.")
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_frindex
    },
    {
        "UOG1_PERIODICLISTBASE",
        DESC("Host Controller only  This 32-bit register contains the beginning addr"
        "ess of the Periodic Frame List in the system memory.")
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_periodiclistbase
    },
    {
        "UOG1_ASYNCLISTADDR",
        DESC("Host Controller only  This 32-bit register contains the address of the"
        " next asynchronous queue head to be executed by the host.")
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_asynclistaddr
    },
    {
        "UOG1_BURSTSIZE",
        DESC("This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.")
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_burstsize
    },
    {
        "UOG1_TXFILLTUNING",
        DESC("The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.")
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbc_uog1_txfilltuning
    },
    {
        "UOG1_ENDPTNAK",
        DESC("")
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_endptnak
    },
    {
        "UOG1_ENDPTNAKEN",
        DESC("")
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_endptnaken
    },
    {
        "UOG1_CONFIGFLAG",
        DESC("")
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_configflag
    },
    {
        "UOG1_PORTSC1",
        DESC("Host Controller  A host controller could implement one to eight port s"
        "tatus and control registers.")
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usbc_uog1_portsc1
    },
    {
        "UOG1_OTGSC",
        DESC("This register is availabe only in OTG controller core.")
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_usbc_uog1_otgsc
    },
    {
        "UOG1_USBMODE",
        DESC("")
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog1_usbmode
    },
    {
        "UOG1_ENDPTSETUPSTAT",
        DESC("")
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog1_endptsetupstat
    },
    {
        "UOG1_ENDPTPRIME",
        DESC("This register is only used in device mode.")
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_endptprime
    },
    {
        "UOG1_ENDPTFLUSH",
        DESC("This register is only used in device mode.")
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_endptflush
    },
    {
        "UOG1_ENDPTSTAT",
        DESC("This register is only used in device mode.")
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_endptstat
    },
    {
        "UOG1_ENDPTCOMPLETE",
        DESC("This register is only used in device mode.")
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog1_endptcomplete
    },
    {
        "UOG1_ENDPTCTRL0",
        DESC("Every Device implements Endpoint 0 as a control endpoint.")
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbc_uog1_endptctrl0
    },
    {
        "UOG1_ENDPTCTRL1",
        DESC("This is endpoint control register for endpoint 1 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl1
    },
    {
        "UOG1_ENDPTCTRL2",
        DESC("This is endpoint control register for endpoint 2 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl2
    },
    {
        "UOG1_ENDPTCTRL3",
        DESC("This is endpoint control register for endpoint 3 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl3
    },
    {
        "UOG1_ENDPTCTRL4",
        DESC("This is endpoint control register for endpoint 4 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl4
    },
    {
        "UOG1_ENDPTCTRL5",
        DESC("This is endpoint control register for endpoint 5 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000001d4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl5
    },
    {
        "UOG1_ENDPTCTRL6",
        DESC("This is endpoint control register for endpoint 6 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000001d8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl6
    },
    {
        "UOG1_ENDPTCTRL7",
        DESC("This is endpoint control register for endpoint 7 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000001dc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog1_endptctrl7
    },
    {
        "UOG2_ID",
        DESC("The ID register identifies the USB 2.0 High-Speed core and its revisio"
        "n.")
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog2_id
    },
    {
        "UOG2_HWGENERAL",
        DESC("General hardware parameters as defined in System Level Issues and Core"
        " Configuration.")
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog2_hwgeneral
    },
    {
        "UOG2_HWHOST",
        DESC("")
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_hwhost
    },
    {
        "UOG2_HWDEVICE",
        DESC("This register is only available in OTG core.")
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_hwdevice
    },
    {
        "UOG2_HWTXBUF",
        DESC("")
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_hwtxbuf
    },
    {
        "UOG2_HWRXBUF",
        DESC("")
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_hwrxbuf
    },
    {
        "UOG2_GPTIMER0LD",
        DESC("This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.")
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_gptimer0ld
    },
    {
        "UOG2_GPTIMER0CTRL",
        DESC("This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.")
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog2_gptimer0ctrl
    },
    {
        "UOG2_GPTIMER1LD",
        DESC("This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.")
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_gptimer1ld
    },
    {
        "UOG2_GPTIMER1CTRL",
        DESC("This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.")
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog2_gptimer1ctrl
    },
    {
        "UOG2_SBUSCFG",
        DESC("")
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_sbuscfg
    },
    {
        "UOG2_CAPLENGTH",
        DESC("The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.")
        1, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_caplength
    },
    {
        "UOG2_HCIVERSION",
        DESC("This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.")
        2, // Width in bytes
        0x00000302, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_hciversion
    },
    {
        "UOG2_HCSPARAMS",
        DESC("The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).")
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usbc_uog2_hcsparams
    },
    {
        "UOG2_HCCPARAMS",
        DESC("This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.")
        4, // Width in bytes
        0x00000308, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usbc_uog2_hccparams
    },
    {
        "UOG2_DCIVERSION",
        DESC("This register indicates the two-byte BCD encoding of the device contro"
        "ller interface version number.")
        2, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_dciversion
    },
    {
        "UOG2_DCCPARAMS",
        DESC("These fields describe the overall device capability of the controller.")
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uog2_dccparams
    },
    {
        "UOG2_USBCMD",
        DESC("The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.")
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_usbcmd
    },
    {
        "UOG2_USBSTS",
        DESC("This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.")
        4, // Width in bytes
        0x00000344, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usbc_uog2_usbsts
    },
    {
        "UOG2_USBINTR",
        DESC("The interrupts to software are enabled with this register.")
        4, // Width in bytes
        0x00000348, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbc_uog2_usbintr
    },
    {
        "UOG2_FRINDEX",
        DESC("This register is used by the host controller to index the periodic fra"
        "me list.")
        4, // Width in bytes
        0x0000034c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_frindex
    },
    {
        "UOG2_PERIODICLISTBASE",
        DESC("Host Controller only  This 32-bit register contains the beginning addr"
        "ess of the Periodic Frame List in the system memory.")
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_periodiclistbase
    },
    {
        "UOG2_ASYNCLISTADDR",
        DESC("Host Controller only  This 32-bit register contains the address of the"
        " next asynchronous queue head to be executed by the host.")
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_asynclistaddr
    },
    {
        "UOG2_BURSTSIZE",
        DESC("This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.")
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_burstsize
    },
    {
        "UOG2_TXFILLTUNING",
        DESC("The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.")
        4, // Width in bytes
        0x00000364, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbc_uog2_txfilltuning
    },
    {
        "UOG2_ENDPTNAK",
        DESC("")
        4, // Width in bytes
        0x00000378, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_endptnak
    },
    {
        "UOG2_ENDPTNAKEN",
        DESC("")
        4, // Width in bytes
        0x0000037c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_endptnaken
    },
    {
        "UOG2_CONFIGFLAG",
        DESC("")
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_configflag
    },
    {
        "UOG2_PORTSC1",
        DESC("Host Controller  A host controller could implement one to eight port s"
        "tatus and control registers.")
        4, // Width in bytes
        0x00000384, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usbc_uog2_portsc1
    },
    {
        "UOG2_OTGSC",
        DESC("This register is availabe only in OTG controller core.")
        4, // Width in bytes
        0x000003a4, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_usbc_uog2_otgsc
    },
    {
        "UOG2_USBMODE",
        DESC("")
        4, // Width in bytes
        0x000003a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uog2_usbmode
    },
    {
        "UOG2_ENDPTSETUPSTAT",
        DESC("")
        4, // Width in bytes
        0x000003ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uog2_endptsetupstat
    },
    {
        "UOG2_ENDPTPRIME",
        DESC("This register is only used in device mode.")
        4, // Width in bytes
        0x000003b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_endptprime
    },
    {
        "UOG2_ENDPTFLUSH",
        DESC("This register is only used in device mode.")
        4, // Width in bytes
        0x000003b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_endptflush
    },
    {
        "UOG2_ENDPTSTAT",
        DESC("This register is only used in device mode.")
        4, // Width in bytes
        0x000003b8, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_endptstat
    },
    {
        "UOG2_ENDPTCOMPLETE",
        DESC("This register is only used in device mode.")
        4, // Width in bytes
        0x000003bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uog2_endptcomplete
    },
    {
        "UOG2_ENDPTCTRL0",
        DESC("Every Device implements Endpoint 0 as a control endpoint.")
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbc_uog2_endptctrl0
    },
    {
        "UOG2_ENDPTCTRL1",
        DESC("This is endpoint control register for endpoint 1 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000003c4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl1
    },
    {
        "UOG2_ENDPTCTRL2",
        DESC("This is endpoint control register for endpoint 2 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000003c8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl2
    },
    {
        "UOG2_ENDPTCTRL3",
        DESC("This is endpoint control register for endpoint 3 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000003cc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl3
    },
    {
        "UOG2_ENDPTCTRL4",
        DESC("This is endpoint control register for endpoint 4 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl4
    },
    {
        "UOG2_ENDPTCTRL5",
        DESC("This is endpoint control register for endpoint 5 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000003d4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl5
    },
    {
        "UOG2_ENDPTCTRL6",
        DESC("This is endpoint control register for endpoint 6 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000003d8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl6
    },
    {
        "UOG2_ENDPTCTRL7",
        DESC("This is endpoint control register for endpoint 7 in device operation m"
        "ode.")
        4, // Width in bytes
        0x000003dc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uog2_endptctrl7
    },
    {
        "UH1_ID",
        DESC("The ID register identifies the USB 2.0 High-Speed core and its revisio"
        "n.")
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uh1_id
    },
    {
        "UH1_HWGENERAL",
        DESC("General hardware parameters as defined in System Level Issues and Core"
        " Configuration.")
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbc_uh1_hwgeneral
    },
    {
        "UH1_HWHOST",
        DESC("")
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh1_hwhost
    },
    {
        "UH1_HWTXBUF",
        DESC("")
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh1_hwtxbuf
    },
    {
        "UH1_HWRXBUF",
        DESC("")
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usbc_uh1_hwrxbuf
    },
    {
        "UH1_GPTIMER0LD",
        DESC("This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.")
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_gptimer0ld
    },
    {
        "UH1_GPTIMER0CTRL",
        DESC("This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.")
        4, // Width in bytes
        0x00000484, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh1_gptimer0ctrl
    },
    {
        "UH1_GPTIMER1LD",
        DESC("This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.")
        4, // Width in bytes
        0x00000488, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_gptimer1ld
    },
    {
        "UH1_GPTIMER1CTRL",
        DESC("This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.")
        4, // Width in bytes
        0x0000048c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh1_gptimer1ctrl
    },
    {
        "UH1_SBUSCFG",
        DESC("")
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_sbuscfg
    },
    {
        "UH1_CAPLENGTH",
        DESC("The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.")
        1, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_caplength
    },
    {
        "UH1_HCIVERSION",
        DESC("This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.")
        2, // Width in bytes
        0x00000502, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_hciversion
    },
    {
        "UH1_HCSPARAMS",
        DESC("The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).")
        4, // Width in bytes
        0x00000504, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usbc_uh1_hcsparams
    },
    {
        "UH1_HCCPARAMS",
        DESC("This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.")
        4, // Width in bytes
        0x00000508, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usbc_uh1_hccparams
    },
    {
        "UH1_USBCMD",
        DESC("The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.")
        4, // Width in bytes
        0x00000540, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbc_uh1_usbcmd
    },
    {
        "UH1_USBSTS",
        DESC("This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.")
        4, // Width in bytes
        0x00000544, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usbc_uh1_usbsts
    },
    {
        "UH1_USBINTR",
        DESC("The interrupts to software are enabled with this register.")
        4, // Width in bytes
        0x00000548, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbc_uh1_usbintr
    },
    {
        "UH1_FRINDEX",
        DESC("This register is used by the host controller to index the periodic fra"
        "me list.")
        4, // Width in bytes
        0x0000054c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_frindex
    },
    {
        "UH1_PERIODICLISTBASE",
        DESC("Host Controller only  This 32-bit register contains the beginning addr"
        "ess of the Periodic Frame List in the system memory.")
        4, // Width in bytes
        0x00000554, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_periodiclistbase
    },
    {
        "UH1_ASYNCLISTADDR",
        DESC("Host Controller only  This 32-bit register contains the address of the"
        " next asynchronous queue head to be executed by the host.")
        4, // Width in bytes
        0x00000558, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_asynclistaddr
    },
    {
        "UH1_BURSTSIZE",
        DESC("This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.")
        4, // Width in bytes
        0x00000560, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbc_uh1_burstsize
    },
    {
        "UH1_TXFILLTUNING",
        DESC("The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.")
        4, // Width in bytes
        0x00000564, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbc_uh1_txfilltuning
    },
    {
        "UH1_CONFIGFLAG",
        DESC("")
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbc_uh1_configflag
    },
    {
        "UH1_PORTSC1",
        DESC("Host Controller  A host controller could implement one to eight port s"
        "tatus and control registers.")
        4, // Width in bytes
        0x00000584, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usbc_uh1_portsc1
    },
    {
        "UH1_USBMODE",
        DESC("")
        4, // Width in bytes
        0x000005a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbc_uh1_usbmode
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBNC
#endif

// Bitfields in register USBNC_USB_OTG1_CTRL.
static const field_t hw_usbnc_usb_otg1_ctrl[] =
{
    {
        "OVER_CUR_DIS",
        DESC("Disable OTG1 Overcurrent Detection")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVER_CUR_POL",
        DESC("OTG1 Polarity of Overcurrent  The polarity of OTG1 port overcurrent ev"
        "ent")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_POL",
        DESC("OTG1 Power Polarity  This bit should be set according to PMIC Power Pi"
        "n polarity.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        DESC("OTG1 Wake-up Interrupt Enable  This bit enables or disables the OTG1 w"
        "ake-up interrupt.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        DESC("OTG1 Software Wake-up Enable")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        DESC("OTG1 Software Wake-up")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_ID_EN",
        DESC("OTG1 Wake-up on ID change enable")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_VBUS_EN",
        DESC("OTG1 wake-up on VBUS change enable")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        DESC("OTG1 Wake-up Interrupt Request  This bit indicates that a wake-up inte"
        "rrupt request is received on the OTG1 port.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_OTG2_CTRL.
static const field_t hw_usbnc_usb_otg2_ctrl[] =
{
    {
        "OVER_CUR_DIS",
        DESC("Disable OTG2 Overcurrent Detection")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVER_CUR_POL",
        DESC("OTG2 Polarity of Overcurrent  The polarity of OTG2 port overcurrent ev"
        "ent")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_POL",
        DESC("OTG2 Power Polarity  This bit should be set according to PMIC Power Pi"
        "n polarity.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        DESC("OTG2 Wake-up Interrupt Enable  This bit enables or disables the OTG2 w"
        "ake-up interrupt.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        DESC("OTG2 Software Wake-up Enable")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        DESC("OTG2 Software Wake-up")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_ID_EN",
        DESC("OTG2 Wake-up on ID change enable")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_VBUS_EN",
        DESC("OTG2 wake-up on VBUS change enable")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        DESC("OTG2 Wake-up Interrupt Request  This bit indicates that a wake-up inte"
        "rrupt request is received on the OTG port.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_UH_CTRL.
static const field_t hw_usbnc_usb_uh_ctrl[] =
{
    {
        "WIE",
        DESC("Host Wake-up Interrupt Enable  This bit enables or disables the Host w"
        "ake-up interrupt.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET",
        DESC("Force Host UTMI PHY Reset  This bit is used to force a reset to the UT"
        "MI PHY.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSPENDM",
        DESC("Force Host UTMI PHY Suspend  This bit is used to put PHY into suspend "
        "mode.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "_480M_CLK_ON",
        DESC("Force OTG UTMI PHY 480M clock output on when Host is not in suspend mo"
        "de.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        DESC("Host Software Wake-up Enable")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        DESC("Host Software Wake-up")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        DESC("Host Wake-up Interrupt Request  This bit indicates that a wake-up inte"
        "rrupt request is received on the Host port.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_UH_HSIC_CTRL.
static const field_t hw_usbnc_usb_uh_hsic_ctrl[] =
{
    {
        "HSIC_CLK_ON",
        DESC("Force Host HSIC module 480M clock on, even when in Host is in suspend "
        "mode.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSIC_EN",
        DESC("Host HSIC enable")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_VLD",
        DESC("Indicating whether Host HSIC clock is valid.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_OTG1_PHY_CTRL_0.
static const field_t hw_usbnc_usb_otg1_phy_ctrl_0[] =
{
    {
        "UTMI_CLK_VLD",
        DESC("Indicating whether OTG1 UTMI PHY clock is valid")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_OTG2_PHY_CTRL_0.
static const field_t hw_usbnc_usb_otg2_phy_ctrl_0[] =
{
    {
        "UTMI_CLK_VLD",
        DESC("Indicating whether OTG2 UTMI PHY clock is valid")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBNC module.
static const reg_t hw_usbnc[] =
{
    {
        "USB_OTG1_CTRL",
        DESC("The USB OTG1 control register controls the integration specific featur"
        "es of the USB OTG1 module.")
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usbnc_usb_otg1_ctrl
    },
    {
        "USB_OTG2_CTRL",
        DESC("The USB OTG2 control register controls the integration specific featur"
        "es of the USB OTG2 module.")
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usbnc_usb_otg2_ctrl
    },
    {
        "USB_UH_CTRL",
        DESC("The USB Host control register controls the integration specific featur"
        "es of the USB host module.")
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usbnc_usb_uh_ctrl
    },
    {
        "USB_UH_HSIC_CTRL",
        DESC("The USB Host HSIC control register controls Host high speed IC configu"
        "ration.")
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbnc_usb_uh_hsic_ctrl
    },
    {
        "USB_OTG1_PHY_CTRL_0",
        DESC("USB OTG1 UTMI PHY control register 0 is used to control the on-chip OT"
        "G1 UTMI PHY.")
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbnc_usb_otg1_phy_ctrl_0
    },
    {
        "USB_OTG2_PHY_CTRL_0",
        DESC("USB OTG2 UTMI PHY Control Register 0 are used to control the on-chip O"
        "TG2 UTMI PHY.")
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbnc_usb_otg2_phy_ctrl_0
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBPHY
#endif

// Bitfields in register USBPHY_PWD.
static const field_t hw_usbphy_pwd[] =
{
    {
        "TXPWDFS",
        DESC("0 = Normal operation.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        DESC("0 = Normal operation.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        DESC("0 = Normal operation.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDENV",
        DESC("0 = Normal operation.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        DESC("0 = Normal operation.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        DESC("0 = Normal operation.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        DESC("0 = Normal operation.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX.
static const field_t hw_usbphy_tx[] =
{
    {
        "D_CAL",
        DESC("Resistor Trimming Code:  0000 = 0.16%  0111 = Nominal  1111 = +25%")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DN",
        DESC("Decode to select a 45-Ohm resistance to the USB_DN output pin.")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        DESC("Decode to select a 45-Ohm resistance to the USB_DP output pin.")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX.
static const field_t hw_usbphy_rx[] =
{
    {
        "ENVADJ",
        DESC("The ENVADJ field adjusts the trip point for the envelope detector.")
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCONADJ",
        DESC("The DISCONADJ field adjusts the trip point for the disconnect detector"
        ":  000 = Trip-Level Voltage is 0.57500 V  001 = Trip-Level Voltage is "
        "0.56875 V  010 = Trip-Level Voltage is 0.58125 V  011 = Trip-Level Vol"
        "tage is 0.58750 V  1XX = Reserved")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDBYPASS",
        DESC("0 = Normal operation.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL.
static const field_t hw_usbphy_ctrl[] =
{
    {
        "ENOTG_ID_CHG_IRQ",
        DESC("Enable OTG_ID_CHG_IRQ.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHOSTDISCONDETECT",
        DESC("For host mode, enables high-speed disconnect detector.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQHOSTDISCON",
        DESC("Enables interrupt for detection of disconnection to Device when in hig"
        "h-speed host mode.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        DESC("Indicates that the device has disconnected in high-speed mode.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDETECT",
        DESC("For device mode, enables 200-KOhm pullups for detecting connectivity t"
        "o the host.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_POLARITY",
        DESC("For device mode, if this bit is cleared to 0, then it trips the interr"
        "upt if the device is plugged in.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_CHG_IRQ",
        DESC("OTG ID change interrupt.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENOTGIDDETECT",
        DESC("Enables circuit to detect resistance of MiniAB ID pin.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUMEIRQSTICKY",
        DESC("Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it"
        ".")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQRESUMEDETECT",
        DESC("Enables interrupt for detection of a non-J state on the USB line.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_IRQ",
        DESC("Indicates that the host is sending a wake-up after suspend.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQDEVPLUGIN",
        DESC("Enables interrupt for the detection of connectivity to the USB line.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        DESC("Indicates that the device is connected.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ON_LRADC",
        DESC("Enables the LRADC to monitor USB_DP and USB_DM.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        DESC("Enables UTMI+ Level2.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        DESC("Enables UTMI+ Level3.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQWAKEUP",
        DESC("Enables interrupt for the wakeup events.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP_IRQ",
        DESC("Indicates that there is a wakeup event.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        DESC("Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        DESC("Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD"
        " if there is wakeup event while USB is suspended.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDPDMCHG_WKUP",
        DESC("Enables the feature to wakeup USB if DP/DM is toggled when USB is susp"
        "ended.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIDCHG_WKUP",
        DESC("Enables the feature to wakeup USB if ID is toggled when USB is suspend"
        "ed.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENVBUSCHG_WKUP",
        DESC("Enables the feature to wakeup USB if VBUS is toggled when USB is suspe"
        "nded.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        DESC("Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_VALUE",
        DESC("Almost same as OTGID_STATUS in USBPHYx_STATUS Register.")
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        DESC("Forces the next FS packet that is transmitted to have a EOP with LS ti"
        "ming.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        DESC("Used by the PHY to indicate a powered-down state.")
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        DESC("Gate UTMI Clocks.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        DESC("Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, U"
        "SBPHYx_RX, and USBPHYx_CTRL registers.")
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_STATUS.
static const field_t hw_usbphy_status[] =
{
    {
        "HOSTDISCONDETECT_STATUS",
        DESC("Indicates that the device has disconnected while in high-speed host mo"
        "de.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVPLUGIN_STATUS",
        DESC("Indicates that the device has been connected on the USB_DP and USB_DM "
        "lines.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTGID_STATUS",
        DESC("Indicates the results of ID pin on MiniAB plug.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_STATUS",
        DESC("Indicates that the host is sending a wake-up after suspend and has tri"
        "ggered an interrupt.")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG.
static const field_t hw_usbphy_debug[] =
{
    {
        "OTGIDPIOLOCK",
        DESC("Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the val"
        "ue.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        DESC("Use holding registers to assist in timing for external UTMI interface.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        DESC("Set bit 3 to 1 to pull down 15-KOhm on USB_DP line.")
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        DESC("Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX2RXCOUNT",
        DESC("Delay in between the end of transmit to the beginning of receive.")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        DESC("Set this bit to allow a countdown to transition in between TX and RX.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        DESC("Delay in between the detection of squelch to the reset of high-speed R"
        "X.")
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENSQUELCHRESET",
        DESC("Set bit to allow squelch to reset high-speed receive.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        DESC("Duration of RESET in terms of the number of 480-MHz cycles.")
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        DESC("Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.")
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        DESC("Gate Test Clocks.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG0_STATUS.
static const field_t hw_usbphy_debug0_status[] =
{
    {
        "LOOP_BACK_FAIL_COUNT",
        DESC("Running count of the failed pseudo-random generator loopback.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UTMI_RXERROR_FAIL_COUNT",
        DESC("Running count of the UTMI_RXERROR.")
        16, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SQUELCH_COUNT",
        DESC("Running count of the squelch reset instead of normal end for HS RX.")
        26, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1.
static const field_t hw_usbphy_debug1[] =
{
    {
        "ENTAILADJVD",
        DESC("Delay increment of the rise of squelch:  00 = Delay is nominal  01 = D"
        "elay is +20%  10 = Delay is -20%  11 = Delay is -40%")
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_VERSION.
static const field_t hw_usbphy_version[] =
{
    {
        "STEP",
        DESC("Fixed read-only value reflecting the stepping of the RTL version.")
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        DESC("Fixed read-only value reflecting the MINOR field of the RTL version.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        DESC("Fixed read-only value reflecting the MAJOR field of the RTL version.")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBPHY module.
static const reg_t hw_usbphy[] =
{
    {
        "PWD",
        DESC("The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usbphy_pwd
    },
    {
        "TX",
        DESC("The USB PHY Transmitter Control Register handles the transmit controls"
        ".")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_tx
    },
    {
        "RX",
        DESC("The USB PHY Receiver Control Register handles receive path controls.")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_rx
    },
    {
        "CTRL",
        DESC("The USB PHY General Control Register handles OTG and Host controls.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        29, // Number of bitfields
        hw_usbphy_ctrl
    },
    {
        "STATUS",
        DESC("The USB PHY Status Register holds results of IRQ and other detects.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbphy_status
    },
    {
        "DEBUG",
        DESC("This register is used to debug the USB PHY.")
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_usbphy_debug
    },
    {
        "DEBUG0_STATUS",
        DESC("The UTMI Debug Status Register 0 holds multiple views for counters and"
        " status of state machines.")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbphy_debug0_status
    },
    {
        "DEBUG1",
        DESC("Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.")
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbphy_debug1
    },
    {
        "VERSION",
        DESC("Fields for RTL Version.")
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbphy_version
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USDHC
#endif

// Bitfields in register USDHC_DS_ADDR.
static const field_t hw_usdhc_ds_addr[] =
{
    {
        "DS_ADDR",
        DESC("DMA System Address: This register contains the 32-bit system memory ad"
        "dress for a DMA transfer.")
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_BLK_ATT.
static const field_t hw_usdhc_blk_att[] =
{
    {
        "BLKSIZE",
        DESC("Transfer Block Size: This register specifies the block size for block "
        "data transfers.")
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLKCNT",
        DESC("Blocks Count For Current Transfer: This register is enabled when the B"
        "lock Count Enable bit in the Transfer Mode register is set to 1 and is"
        " valid only for multiple block transfers.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_ARG.
static const field_t hw_usdhc_cmd_arg[] =
{
    {
        "CMDARG",
        DESC("Command Argument: The SD/MMC Command Argument is specified as bits 39-"
        "8 of the Command Format in the SD or MMC Specification.This register i"
        "s write protected when the Command Inhibit (CMD) bit in the Present St"
        "ate register is set.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_XFR_TYP.
static const field_t hw_usdhc_cmd_xfr_typ[] =
{
    {
        "RSPTYP",
        DESC("Response Type Select:")
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCCEN",
        DESC("Command CRC Check Enable: If this bit is set to 1, the uSDHC shall che"
        "ck the CRC field in the response.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CICEN",
        DESC("Command Index Check Enable: If this bit is set to 1, the uSDHC will ch"
        "eck the Index field in the response to see if it has the same value as"
        " the command index.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPSEL",
        DESC("Data Present Select: This bit is set to 1 to indicate that data is pre"
        "sent and shall be transferred using the DAT line.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDTYP",
        DESC("Command Type: There are three types of special commands: Suspend, Resu"
        "me and Abort.")
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDINX",
        DESC("Command Index: These bits shall be set to the command number that is s"
        "pecified in bits 45-40 of the Command-Format in the SD Memory Card Phy"
        "sical Layer Specification and SDIO Card Specification.")
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_RSP0.
static const field_t hw_usdhc_cmd_rsp0[] =
{
    {
        "CMDRSP0",
        DESC("Command Response 0: Refer to for the mapping of command responses from"
        " the SD Bus to this register for each response type.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_RSP1.
static const field_t hw_usdhc_cmd_rsp1[] =
{
    {
        "CMDRSP1",
        DESC("Command Response 1: Refer to for the mapping of command responses from"
        " the SD Bus to this register for each response type.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_RSP2.
static const field_t hw_usdhc_cmd_rsp2[] =
{
    {
        "CMDRSP2",
        DESC("Command Response 2: Refer to for the mapping of command responses from"
        " the SD Bus to this register for each response type.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_RSP3.
static const field_t hw_usdhc_cmd_rsp3[] =
{
    {
        "CMDRSP3",
        DESC("Command Response 3: Refer to for the mapping of command responses from"
        " the SD Bus to this register for each response type.")
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_DATA_BUFF_ACC_PORT.
static const field_t hw_usdhc_data_buff_acc_port[] =
{
    {
        "DATCONT",
        DESC("Data Content: The Buffer Data Port register is for 32-bit data access "
        "by the ARM platform or the external DMA.")
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_PRES_STATE.
static const field_t hw_usdhc_pres_state[] =
{
    {
        "CIHB",
        DESC("Command Inhibit (CMD): If this status bit is 0, it indicates that the "
        "CMD line is not in use and the uSDHC can issue a SD/MMC Command using "
        "the CMD line.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CDIHB",
        DESC("Command Inhibit (DAT): This status bit is generated if either the DAT "
        "Line Active or the Read Transfer Active is set to 1.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLA",
        DESC("Data Line Active This status bit indicates whether one of the DAT line"
        "s on the SD Bus is in use.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDSTB",
        DESC("SD Clock Stable This status bit indicates that the internal card clock"
        " is stable.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPGOFF",
        DESC("ipg_clk Gated Off Internally: This status bit indicates that the ipg_c"
        "lk is internally gated off.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HCKOFF",
        DESC("hclk Gated Off Internally: This status bit indicates that the hclk is "
        "internally gated off.")
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PEROFF",
        DESC("ipg_perclk Gated Off Internally: This status bit indicates that the ip"
        "g_perclk is internally gated off.")
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDOFF",
        DESC("SD Clock Gated Off Internally: This status bit indicates that the SD C"
        "lock is internally gated off, because of buffer over/under-run or read"
        " pause without read wait assertion, or the driver set FRC_SDCLK_ON bit"
        " is 0 to stop the SD clock in idle status.")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WTA",
        DESC("Write Transfer Active: This status bit indicates a write transfer is a"
        "ctive.")
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTA",
        DESC("Read Transfer Active: This status bit is used for detecting completion"
        " of a read transfer.")
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BWEN",
        DESC("Buffer Write Enable: This status bit is used for non-DMA write transfe"
        "rs.")
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BREN",
        DESC("Buffer Read Enable: This status bit is used for non-DMA read transfers"
        ".")
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTR",
        DESC("Re-Tuning Request: (only for SD3.0 SDR104 mode) Host Controller may re"
        "quest Host Driver to execute re-tuning sequence by setting this bit wh"
        "en the data window is shifted by temperature drift and a tuned samplin"
        "g point does not have a good margin to receive correct data.")
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSCD",
        DESC("Tape Select Change Done : This bit indicates the dealy setting is effe"
        "ctive after write CLK_TUNE_CTRL_STATUS register.")
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CINST",
        DESC("Card Inserted: This bit indicates whether a card has been inserted.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CDPL",
        DESC("Card Detect Pin Level: This bit reflects the inverse value of the CD# "
        "pin for the card socket.")
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WPSPL",
        DESC("Write Protect Switch Pin Level: The Write Protect Switch is supported "
        "for memory and combo cards.This bit reflects the inverted value of the"
        " WP pin of the card socket.")
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLSL",
        DESC("CMD Line Signal Level: This status is used to check the CMD line level"
        " to recover from errors, and for debugging.")
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLSL",
        DESC("DAT[7:0] Line Signal Level: This status is used to check the DAT line "
        "level to recover from errors, and for debugging.This is especially use"
        "ful in detecting the busy signal level from DAT[0].")
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_PROT_CTRL.
static const field_t hw_usdhc_prot_ctrl[] =
{
    {
        "LCTL",
        DESC("LED Control: This bit, fully controlled by the Host Driver, is used to"
        " caution the user not to remove the card while the card is being acces"
        "sed.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTW",
        DESC("Data Transfer Width: This bit selects the data width of the SD bus for"
        " a data transfer.")
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3CD",
        DESC("DAT3 as Card Detection Pin: If this bit is set, DAT3 should be pulled "
        "down to act as a card detection pin.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EMODE",
        DESC("Endian Mode: The uSDHC supports all three endian modes in data transfe"
        "r.")
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CDTL",
        DESC("Card Detect Test Level: This is bit is enabled while the Card Detectio"
        "n Signal Selection is set to 1 and it indicates card insertion.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CDSS",
        DESC("Card Detect Signal Selection: This bit selects the source for the card"
        " detection.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMASEL",
        DESC("DMA Select: This field is valid while DMA (SDMA or ADMA) is enabled an"
        "d selects the DMA operation.")
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SABGREQ",
        DESC("Stop At Block Gap Request: This bit is used to stop executing a transa"
        "ction at the next block gap for both DMA and non-DMA transfers.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREQ",
        DESC("Continue Request: This bit is used to restart a transaction which was "
        "stopped using the Stop At Block Gap Request.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWCTL",
        DESC("Read Wait Control: The read wait function is optional for SDIO cards.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IABG",
        DESC("Interrupt At Block Gap: This bit is valid only in 4-bit mode, of the S"
        "DIO card, and selects a sample point in the interrupt cycle.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DONE_NO_8CLK",
        DESC("Read done no 8 clock: According to the SD/MMC spec, for read data tran"
        "saction, 8 clocks are needed after the end bit of the last data block.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECINT",
        DESC("Wakeup Event Enable On Card Interrupt: This bit enables a wakeup event"
        ", via a Card Interrupt, in the Interrupt Status register.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECINS",
        DESC("Wakeup Event Enable On SD Card Insertion: This bit enables a wakeup ev"
        "ent, via a Card Insertion, in the Interrupt Status register.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECRM",
        DESC("Wakeup Event Enable On SD Card Removal: This bit enables a wakeup even"
        "t, via a Card Removal, in the Interrupt Status register.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_LEN_EN",
        DESC("BURST length enable for INCR, INCR4/INCR8/INCR16, INCR4-WRAP/INCR8-WRA"
        "P/INCR16-WRAP This is used to enable/disable the burst length for the "
        "external AHB2AXI bridge.")
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NON_EXACT_BLK_RD",
        DESC("Current block read is non-exact block read.")
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_SYS_CTRL.
static const field_t hw_usdhc_sys_ctrl[] =
{
    {
        "DVS",
        DESC("Divisor: This register is used to provide a more exact divisor to gene"
        "rate the desired SD clock frequency.")
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDCLKFS",
        DESC("SDCLK Frequency Select: This register is used to select the frequency "
        "of the SDCLK pin.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOCV",
        DESC("Data Timeout Counter Value: This value determines the interval by whic"
        "h DAT line timeouts are detected.")
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPP_RST_N",
        DESC("This register's value will be output to CARD from pad directly for har"
        "dware reset of the card if the card supports this feature.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTA",
        DESC("Software Reset For ALL: This reset effects the entire Host Controller "
        "except for the card detection circuit.")
        24, // LSB
        24, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RSTC",
        DESC("Software Reset For CMD Line: Only part of the command circuit is reset"
        ".")
        25, // LSB
        25, // MSB
        false, // Readable
        true // Writable
    },
    {
        "RSTD",
        DESC("Software Reset For DAT Line: Only part of the data circuit is reset.")
        26, // LSB
        26, // MSB
        false, // Readable
        true // Writable
    },
    {
        "INITA",
        DESC("Initialization Active: When this bit is set, 80 SD-Clocks are sent to "
        "the card.")
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTT",
        DESC("Reset Tuning: When set this bit to 1, it will reset tuning circuit.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_INT_STATUS.
static const field_t hw_usdhc_int_status[] =
{
    {
        "CC",
        DESC("Command Complete: This bit is set when you receive the end bit of the "
        "command response (except Auto CMD12).")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TC",
        DESC("Transfer Complete: This bit is set when a read or write transfer is co"
        "mpleted.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGE",
        DESC("Block Gap Event: If the Stop At Block Gap Request bit in the Protocol "
        "Control register is set, this bit is set when a read or write transact"
        "ion is stopped at a block gap.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINT",
        DESC("DMA Interrupt: Occurs only when the internal DMA finishes the data tra"
        "nsfer successfully.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWR",
        DESC("Buffer Write Ready: This status bit is set if the Buffer Write Enable "
        "bit, in the Present State register, changes from 0 to 1.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRR",
        DESC("Buffer Read Ready: This status bit is set if the Buffer Read Enable bi"
        "t, in the Present State register, changes from 0 to 1.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINS",
        DESC("Card Insertion: This status bit is set if the Card Inserted bit in the"
        " Present State register changes from 0 to 1.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRM",
        DESC("Card Removal: This status bit is set if the Card Inserted bit in the P"
        "resent State register changes from 1 to 0.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINT",
        DESC("Card Interrupt: This status bit is set when an interrupt signal is det"
        "ected from the external card.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTE",
        DESC("Re-Tuning Event: (only for SD3.0 SDR104 mode) This status is set if Re"
        "-Tuning Request in the Present State register changes from 0 to 1.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TP",
        DESC("Tuning Pass:(only for SD3.0 SDR104 mode) Current CMD19 transfer is don"
        "e successfully.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOE",
        DESC("Command Timeout Error: Occurs only if no response is returned within 6"
        "4 SDCLK cycles from the end bit of the command.")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCE",
        DESC("Command CRC Error: Command CRC Error is generated in two cases.")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBE",
        DESC("Command End Bit Error: Occurs when detecting that the end bit of a com"
        "mand response is 0.")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIE",
        DESC("Command Index Error: Occurs if a Command Index error occurs in the com"
        "mand response.")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOE",
        DESC("Data Timeout Error: Occurs when detecting one of following time-out co"
        "nditions.")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCE",
        DESC("Data CRC Error: Occurs when detecting a CRC error when transferring re"
        "ad data, which uses the DAT line, or when detecting the Write CRC stat"
        "us having a value other than 010.")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBE",
        DESC("Data End Bit Error: Occurs either when detecting 0 at the end bit posi"
        "tion of read data, which uses the DAT line, or at the end bit position"
        " of the CRC.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12E",
        DESC("Auto CMD12 Error: Occurs when detecting that one of the bits in the Au"
        "to CMD12 Error Status register has changed from 0 to 1.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNE",
        DESC("Tuning Error: (only for SD3.0 SDR104 mode) This bit is set when an unr"
        "ecoverable error is detected in a tuning circuit.")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAE",
        DESC("DMA Error: Occurs when an Internal DMA transfer has failed.")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_INT_STATUS_EN.
static const field_t hw_usdhc_int_status_en[] =
{
    {
        "CCSEN",
        DESC("Command Complete Status Enable: 1 Enabled 0 Masked")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEN",
        DESC("Transfer Complete Status Enable:")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGESEN",
        DESC("Block Gap Event Status Enable:")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINTSEN",
        DESC("DMA Interrupt Status Enable:")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWRSEN",
        DESC("Buffer Write Ready Status Enable:")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRRSEN",
        DESC("Buffer Read Ready Status Enable:")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINSSEN",
        DESC("Card Insertion Status Enable:")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRMSEN",
        DESC("Card Removal Status Enable:")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINTSEN",
        DESC("Card Interrupt Status Enable: If this bit is set to 0, the uSDHC will "
        "clear the interrupt request to the System.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTESEN",
        DESC("Re-Tuning Event Status Enable")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPSEN",
        DESC("Tuning Pass Status Enable")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOESEN",
        DESC("Command Timeout Error Status Enable:")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCESEN",
        DESC("Command CRC Error Status Enable:")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBESEN",
        DESC("Command End Bit Error Status Enable:")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIESEN",
        DESC("Command Index Error Status Enable:")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOESEN",
        DESC("Data Timeout Error Status Enable:")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCESEN",
        DESC("Data CRC Error Status Enable:")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBESEN",
        DESC("Data End Bit Error Status Enable:")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12ESEN",
        DESC("Auto CMD12 Error Status Enable:")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNESEN",
        DESC("Tuning Error Status Enable:")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAESEN",
        DESC("DMA Error Status Enable:")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_INT_SIGNAL_EN.
static const field_t hw_usdhc_int_signal_en[] =
{
    {
        "CCIEN",
        DESC("Command Complete Interrupt Enable:")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCIEN",
        DESC("Transfer Complete Interrupt Enable:")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGEIEN",
        DESC("Block Gap Event Interrupt Enable:")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINTIEN",
        DESC("DMA Interrupt Enable:")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWRIEN",
        DESC("Buffer Write Ready Interrupt Enable:")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRRIEN",
        DESC("Buffer Read Ready Interrupt Enable:")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINSIEN",
        DESC("Card Insertion Interrupt Enable:")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRMIEN",
        DESC("Card Removal Interrupt Enable:")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINTIEN",
        DESC("Card Interrupt Interrupt Enable:")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTEIEN",
        DESC("Re-Tuning Event Interrupt Enable")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPIEN",
        DESC("Tuning Pass Interrupt Enable")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOEIEN",
        DESC("Command Timeout Error Interrupt Enable")
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCEIEN",
        DESC("Command CRC Error Interrupt Enable:")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBEIEN",
        DESC("Command End Bit Error Interrupt Enable:")
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIEIEN",
        DESC("Command Index Error Interrupt Enable:")
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOEIEN",
        DESC("Data Timeout Error Interrupt Enable:")
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCEIEN",
        DESC("Data CRC Error Interrupt Enable:")
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBEIEN",
        DESC("Data End Bit Error Interrupt Enable:")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12EIEN",
        DESC("Auto CMD12 Error Interrupt Enable:")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNEIEN",
        DESC("Tuning Error Interrupt Enable")
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAEIEN",
        DESC("DMA Error Interrupt Enable:")
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_AUTOCMD12_ERR_STATUS.
static const field_t hw_usdhc_autocmd12_err_status[] =
{
    {
        "AC12NE",
        DESC("Auto CMD12 Not Executed: If memory multiple block data transfer is not"
        " started, due to a command error, this bit is not set because it is no"
        "t necessary to issue an Auto CMD12.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12TOE",
        DESC("Auto CMD12 Timeout Error: Occurs if no response is returned within 64 "
        "SDCLK cycles from the end bit of the command.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12EBE",
        DESC("Auto CMD12 End Bit Error: Occurs when detecting that the end bit of co"
        "mmand response is 0 which should be 1.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12CE",
        DESC("Auto CMD12 CRC Error: Occurs when detecting a CRC error in the command"
        " response.")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12IE",
        DESC("Auto CMD12 Index Error: Occurs if the Command Index error occurs in re"
        "sponse to a command.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CNIBAC12E",
        DESC("Command Not Issued By Auto CMD12 Error: Setting this bit to 1 means CM"
        "D_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this "
        "register.")
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EXECUTE_TUNING",
        DESC("Execute Tuning: When std_tuning_en bit is set, this bit is used to sta"
        "rt tuning procedure.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMP_CLK_SEL",
        DESC("Sample Clock Select: When std_tuning_en bit is set, this bit is used t"
        "o select sampling clock to receive CMD and DAT.")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_HOST_CTRL_CAP.
static const field_t hw_usdhc_host_ctrl_cap[] =
{
    {
        "SDR50_SUPPORT",
        DESC("SDR50 support: This bit indicates support of SDR50 mode.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDR104_SUPPORT",
        DESC("SDR104 support: This bit indicates support of SDR104 mode.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR50_SUPPORT",
        DESC("DDR50 support: This bit indicates support of DDR50 mode.")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TIME_COUNT_RETUNING",
        DESC("Time counter for retuning: This bit indicates an initial value of the "
        "Retuning Timer for Re-Tuning Mode1 and 3.Setting to 0 disables Retunin"
        "g Timer.")
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USE_TUNING_SDR50",
        DESC("Use Tuning for SDR50: This bit is set to 1.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RETUNING_MODE",
        DESC("Retuning Mode: This bit selects retuning method.")
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MBL",
        DESC("Max Block Length: This value indicates the maximum block size that the"
        " Host Driver can read and write to the buffer in the uSDHC.")
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMAS",
        DESC("ADMA Support: This bit indicates whether the uSDHC supports the ADMA f"
        "eature.")
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HSS",
        DESC("High Speed Support: This bit indicates whether the uSDHC supports High"
        " Speed mode and the Host System can supply a SD Clock frequency from 2"
        "5 MHz to 50 MHz.")
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMAS",
        DESC("DMA Support: This bit indicates whether the uSDHC is capable of using "
        "the internal DMA to transfer data between system memory and the data b"
        "uffer directly.")
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SRS",
        DESC("Suspend / Resume Support: This bit indicates whether the uSDHC support"
        "s Suspend / Resume functionality.")
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS33",
        DESC("Voltage Support 3.3V: This bit shall depend on the Host System ability"
        ".")
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS30",
        DESC("Voltage Support 3.0V: This bit shall depend on the Host System ability"
        ".")
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS18",
        DESC("Voltage Support 1.8V: This bit shall depend on the Host System ability"
        ".")
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_WTMK_LVL.
static const field_t hw_usdhc_wtmk_lvl[] =
{
    {
        "RD_WML",
        DESC("Read Watermark Level: The number of words used as the watermark level "
        "(FIFO threshold) in a DMA read operation.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_BRST_LEN",
        DESC("Read Burst Length: Due to system restriction, the actual burst length "
        "may not exceed 16.")
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_WML",
        DESC("Write Watermark Level: The number of words used as the watermark level"
        " (FIFO threshold) in a DMA write operation.")
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_BRST_LEN",
        DESC("Write Burst Length: Due to system restriction, the actual burst length"
        " may not exceed 16.")
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_MIX_CTRL.
static const field_t hw_usdhc_mix_ctrl[] =
{
    {
        "DMAEN",
        DESC("DMA Enable: This bit enables DMA functionality.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCEN",
        DESC("Block Count Enable: This bit is used to enable the Block Count registe"
        "r, which is only relevant for multiple block transfers.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12EN",
        DESC("Auto CMD12 Enable: Multiple block transfers for memory require a CMD12"
        " to stop the transaction.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_EN",
        DESC("Dual Data Rate mode selection")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTDSEL",
        DESC("Data Transfer Direction Select: This bit defines the direction of DAT "
        "line data transfers.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSBSEL",
        DESC("Multi / Single Block Select: This bit enables multiple block DAT line "
        "data transfers.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NIBBLE_POS",
        DESC("In DDR 4-bit mode nibble position indictation.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC23EN",
        DESC("Auto CMD23 Enable When this bit is set to 1, the Host Controller issue"
        "s a CMD23 automatically before issuing a command specified in the Comm"
        "and Register.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXE_TUNE",
        DESC("Execute Tuning: (Only used for SD3.0, SDR104 mode) When std_tuning_en "
        "is 0, this bit is set to 1 to indicate the Host Driver is starting tun"
        "ing procedure.")
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMP_CLK_SEL",
        DESC("When std_tuning_en is 0, this bit is used to select Tuned clock or Fix"
        "ed clock to sample data/cmd (Only used for SD3.0, SDR104 mode)")
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_TUNE_EN",
        DESC("Auto tuning enable (Only used for SD3.0, SDR104 mode)")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBCLK_SEL",
        DESC("Feedback clock source selection (Only used for SD3.0, SDR104 mode)")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_FORCE_EVENT.
static const field_t hw_usdhc_force_event[] =
{
    {
        "FEVTAC12NE",
        DESC("Force Event Auto Command 12 Not Executed: Forces the AC12NE bit in the"
        " Auto Command12 Error Status Register to be set")
        0, // LSB
        0, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTAC12TOE",
        DESC("Force Event Auto Command 12 Time Out Error: Forces the AC12TOE bit in "
        "the Auto Command12 Error Status Register to be set")
        1, // LSB
        1, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTAC12CE",
        DESC("Force Event Auto Command 12 CRC Error: Forces the AC12CE bit in the Au"
        "to Command12 Error Status Register to be set")
        2, // LSB
        2, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTAC12EBE",
        DESC("Force Event Auto Command 12 End Bit Error: Forces the AC12EBE bit in t"
        "he Auto Command12 Error Status Register to be set")
        3, // LSB
        3, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTAC12IE",
        DESC("Force Event Auto Command 12 Index Error: Forces the AC12IE bit in the "
        "Auto Command12 Error Status Register to be set")
        4, // LSB
        4, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTCNIBAC12E",
        DESC("Force Event Command Not Executed By Auto Command 12 Error: Forces the "
        "CNIBAC12E bit in the Auto Command12 Error Status Register to be set")
        7, // LSB
        7, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTCCE",
        DESC("Force Event Command Time Out Error: Forces the CTOE bit of Interrupt S"
        "tatus Register to be set")
        16, // LSB
        16, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTCCE1",
        DESC("Force Event Command CRC Error: Forces the CCE bit of Interrupt Status "
        "Register to be set")
        17, // LSB
        17, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTCEBE",
        DESC("Force Event Command End Bit Error: Forces the CEBE bit of Interrupt St"
        "atus Register to be set")
        18, // LSB
        18, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTCIE",
        DESC("Force Event Command Index Error: Forces the CCE bit of Interrupt Statu"
        "s Register to be set")
        19, // LSB
        19, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTDTOE",
        DESC("Force Event Data Time Out Error: Force the DTOE bit of Interrupt Statu"
        "s Register to be set")
        20, // LSB
        20, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTDCE",
        DESC("Force Event Data CRC Error: Forces the DCE bit of Interrupt Status Reg"
        "ister to be set")
        21, // LSB
        21, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTDEBE",
        DESC("Force Event Data End Bit Error: Forces the DEBE bit of Interrupt Statu"
        "s Register to be set")
        22, // LSB
        22, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTAC12E",
        DESC("Force Event Auto Command 12 Error: Forces the AC12E bit of Interrupt S"
        "tatus Register to be set")
        24, // LSB
        24, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTTNE",
        DESC("Force Tuning Error: Forces the TNE bit of Interrupt Status Register to"
        " be set")
        26, // LSB
        26, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTDMAE",
        DESC("Force Event DMA Error: Forces the DMAE bit of Interrupt Status Registe"
        "r to be set")
        28, // LSB
        28, // MSB
        false, // Readable
        true // Writable
    },
    {
        "FEVTCINT",
        DESC("Force Event Card Interrupt: Writing 1 to this bit generates a short lo"
        "w-level pulse on the internal DAT[1] line, as if a self clearing inter"
        "rupt was received from the external card.")
        31, // LSB
        31, // MSB
        false, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_ADMA_ERR_STATUS.
static const field_t hw_usdhc_adma_err_status[] =
{
    {
        "ADMAES",
        DESC("ADMA Error State (when ADMA Error is occurred.): This field indicates "
        "the state of the ADMA when an error has occurred during an ADMA data t"
        "ransfer.")
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMALME",
        DESC("ADMA Length Mismatch Error: This error occurs in the following 2 cases"
        ": While the Block Count Enable is being set, the total data length spe"
        "cified by the Descriptor table is different from that specified by the"
        " Block Count and Block Length Total data length can not be divided by "
        "the block length")
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMADCE",
        DESC("ADMA Descritor Error: This error occurs when invalid descriptor fetche"
        "d by ADMA:")
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_ADMA_SYS_ADDR.
static const field_t hw_usdhc_adma_sys_addr[] =
{
    {
        "ADS_ADDR",
        DESC("ADMA System Address: This register holds the word address of the execu"
        "ting command in the Descriptor table.")
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_DLL_CTRL.
static const field_t hw_usdhc_dll_ctrl[] =
{
    {
        "DLL_CTRL_ENABLE",
        DESC("Set this bit to 1 to enable the DLL and delay chain; otherwise; set to"
        " 0 to bypasses DLL.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_RESET",
        DESC("Setting this bit to 1 force a reset on DLL.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_FORCE_UPD",
        DESC("Setting this bit to 1, forces the slave delay line to update to the DL"
        "L calibrated value immediately.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_DLY_TARGET",
        DESC("The delay target for the uSDHC loopback read clock can be programmed i"
        "n 1/16th increments of an ref_clock half-period.")
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_GATE_UPDATE",
        DESC("Set this bit to 1 to prevent the DLL from updating (since when clock_i"
        "n exists, glitches may appear during DLL updates).")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE",
        DESC("Set this bit to 1 to Enable manual override for slave delay chain usin"
        "g SLV_OVERRIDE_VAL; to set 0 to disable manual override.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE_VAL",
        DESC("When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical tap"
        "s manually.")
        9, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_DLY_TARGET1",
        DESC("Refer to DLL_CTRL_SLV_DLY_TARGET[3:0] below.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_UPDATE_INT",
        DESC("Slave delay line update interval.")
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_REF_UPDATE_INT",
        DESC("DLL control loop update interval.")
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_DLL_STATUS.
static const field_t hw_usdhc_dll_status[] =
{
    {
        "DLL_STS_SLV_LOCK",
        DESC("Slave delay-line lock status.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_REF_LOCK",
        DESC("Reference DLL lock status.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_SLV_SEL",
        DESC("Slave delay line select status.")
        2, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_REF_SEL",
        DESC("Reference delay line select taps.")
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CLK_TUNE_CTRL_STATUS.
static const field_t hw_usdhc_clk_tune_ctrl_status[] =
{
    {
        "DLY_CELL_SET_POST",
        DESC("Set the number of delay cells on the feedback clock between CLK_OUT an"
        "d CLK_POST.")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLY_CELL_SET_OUT",
        DESC("Set the number of delay cells on the feedback clock between CLK_PRE an"
        "d CLK_OUT.")
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLY_CELL_SET_PRE",
        DESC("Set the number of delay cells on the feedback clock between the feedba"
        "ck clock and CLK_PRE.")
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NXT_ERR",
        DESC("NXT error which means the number of delay cells added on the feedback "
        "clock is too large.")
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_POST",
        DESC("Reflect the number of delay cells added on the feedback clock between "
        "CLK_OUT and CLK_POST.")
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_OUT",
        DESC("Reflect the number of delay cells added on the feedback clock between "
        "CLK_PRE and CLK_OUT.")
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_PRE",
        DESC("Reflects the number of delay cells added on the feedback clock between"
        " the feedback clock and CLK_PRE.")
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRE_ERR",
        DESC("PRE error which means the number of delay cells added on the feedback "
        "clock is too small.")
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_VEND_SPEC.
static const field_t hw_usdhc_vend_spec[] =
{
    {
        "EXT_DMA_EN",
        DESC("External DMA Request Enable Enable the request to external DMA.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSELECT",
        DESC("Voltage Selection Change the value of output signal VSELECT, to contro"
        "l the voltage on pads for external card.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONFLICT_CHK_EN",
        DESC("It's not implemented in uSDHC IP.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12_WR_CHKBUSY_EN",
        DESC("Check busy enable after auto CMD12 for write data packet")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAT3_CD_POL",
        DESC("Only for debug.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CD_POL",
        DESC("Only for debug.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP_POL",
        DESC("Only for debug.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKONJ_IN_ABORT",
        DESC("Only for debug.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRC_SDCLK_ON",
        DESC("Force CLK output active:")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPG_CLK_SOFT_EN",
        DESC("IPG_CLK software enable")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCLK_SOFT_EN",
        DESC("Please note, hardware auto-enables the AHB clock when the internal DMA"
        " is enabled even if HCLK_SOFT_EN is 0.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPG_PERCLK_SOFT_EN",
        DESC("ipg_perclk software enable")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_CLK_SOFT_EN",
        DESC("card clock software enable")
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CRC_CHK_DIS",
        DESC("CRC check disable")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_ST_VAL",
        DESC("Internal State Value Internal state value, reflecting the correspondin"
        "g state value selected by Debug Select field.")
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_MMC_BOOT.
static const field_t hw_usdhc_mmc_boot[] =
{
    {
        "DTOCV_ACK",
        DESC("Boot ACK time out counter value.")
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_ACK",
        DESC("Boot ack mode select.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_MODE",
        DESC("Boot mode select.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_EN",
        DESC("Boot mode enable.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_SABG_EN",
        DESC("During boot, enable auto stop at block gap function.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_TIME_OUT",
        DESC("Please note, when this bit is set, there is no timeout check no matter"
        " whether boot_en is set or not.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_BLK_CNT",
        DESC("The value defines the Stop At Block Gap value of automatic mode.")
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_VEND_SPEC2.
static const field_t hw_usdhc_vend_spec2[] =
{
    {
        "SDR104_TIMING_DIS",
        DESC("Timeout counter test.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDR104_OE_DIS",
        DESC("CMD_OE/DAT_OE logic generation test.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDR104_NSD_DIS",
        DESC("Interrupt window after abort command is sent.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_INT_D3_TEST",
        DESC("Card interrupt detection test.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_8BIT_EN",
        DESC("Enable the auto tuning circuit to check the DAT[7:0].")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_1BIT_EN",
        DESC("Enable the auto tuning circuit to check the DAT0 only.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_CMD_EN",
        DESC("Enable the auto tuning circuit to check the CMD line.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_INT_AUTO_CLR_DIS",
        DESC("Disable the feature to clear the Card interrupt status bit when Card I"
        "nterrupt status enable bit is cleared.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_TUNING_CTRL.
static const field_t hw_usdhc_tuning_ctrl[] =
{
    {
        "TUNING_START_TAP",
        DESC("The start dealy cell point when send first CMD19 in tuning procedure.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_COUNTER",
        DESC("The MAX repeat CMD19 times in tuning procedure.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_STEP",
        DESC("The increasing delay cell step in tuning procedure.")
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_WINDOW",
        DESC("Select data window value for auto tuning")
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STD_TUNING_EN",
        DESC("Standard tuning circuit and procedure enable: This bit is used to enab"
        "le standard tuning circuit and procedure.")
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USDHC module.
static const reg_t hw_usdhc[] =
{
    {
        "DS_ADDR",
        DESC("This register contains the physical system memory address used for DMA"
        " transfers.")
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_ds_addr
    },
    {
        "BLK_ATT",
        DESC("This register is used to configure the number of data blocks and the n"
        "umber of bytes in each block.")
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usdhc_blk_att
    },
    {
        "CMD_ARG",
        DESC("This register contains the SD/MMC Command Argument.")
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_arg
    },
    {
        "CMD_XFR_TYP",
        DESC("This register is used to control the operation of data transfers.")
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usdhc_cmd_xfr_typ
    },
    {
        "CMD_RSP0",
        DESC("This register is used to store part 0 of the response bits from the ca"
        "rd.")
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp0
    },
    {
        "CMD_RSP1",
        DESC("This register is used to store part 1 of the response bits from the ca"
        "rd.")
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp1
    },
    {
        "CMD_RSP2",
        DESC("This register is used to store part 2 of the response bits from the ca"
        "rd.")
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp2
    },
    {
        "CMD_RSP3",
        DESC("This register is used to store part 3 of the response bits from the ca"
        "rd.")
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp3
    },
    {
        "DATA_BUFF_ACC_PORT",
        DESC("This is a 32-bit data port register used to access the internal buffer"
        ".")
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_data_buff_acc_port
    },
    {
        "PRES_STATE",
        DESC("The Host Driver can get status of the uSDHC from this 32-bit read only"
        " register.")
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        19, // Number of bitfields
        hw_usdhc_pres_state
    },
    {
        "PROT_CTRL",
        DESC("There are three cases to restart the transfer after stop at the block "
        "gap.")
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usdhc_prot_ctrl
    },
    {
        "SYS_CTRL",
        DESC("")
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usdhc_sys_ctrl
    },
    {
        "INT_STATUS",
        DESC("An interrupt is generated when the Normal Interrupt Signal Enable is e"
        "nabled and at least one of the status bits is set to 1.")
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_status
    },
    {
        "INT_STATUS_EN",
        DESC("Setting the bits in this register to 1 enables the corresponding Inter"
        "rupt Status to be set by the specified event.")
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_status_en
    },
    {
        "INT_SIGNAL_EN",
        DESC("This register is used to select which interrupt status is indicated to"
        " the Host System as the interrupt.")
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_signal_en
    },
    {
        "AUTOCMD12_ERR_STATUS",
        DESC("When the Auto CMD12 Error Status bit in the Status register is set, th"
        "e Host Driver shall check this register to identify what kind of error"
        " the Auto CMD12 indicated.")
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_usdhc_autocmd12_err_status
    },
    {
        "HOST_CTRL_CAP",
        DESC("This register provides the Host Driver with information specific to th"
        "e uSDHC implementation.")
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_usdhc_host_ctrl_cap
    },
    {
        "WTMK_LVL",
        DESC("Both write and read watermark levels (FIFO threshold) are configurable"
        ".")
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usdhc_wtmk_lvl
    },
    {
        "MIX_CTRL",
        DESC("This register is used to DMA and data transfer.")
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usdhc_mix_ctrl
    },
    {
        "FORCE_EVENT",
        DESC("The Force Event Register is not a physically implemented register.")
        4, // Width in bytes
        0x00000050, // Base address offset
        false, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usdhc_force_event
    },
    {
        "ADMA_ERR_STATUS",
        DESC("When an ADMA Error Interrupt has occurred, the ADMA Error States field"
        " in this register holds the ADMA state and the ADMA System Address reg"
        "ister holds the address around the error descriptor.")
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usdhc_adma_err_status
    },
    {
        "ADMA_SYS_ADDR",
        DESC("This register contains the physical system memory address used for ADM"
        "A transfers.")
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_adma_sys_addr
    },
    {
        "DLL_CTRL",
        DESC("This register contains control bits for DLL.")
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usdhc_dll_ctrl
    },
    {
        "DLL_STATUS",
        DESC("This register contains the DLL status information.")
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usdhc_dll_status
    },
    {
        "CLK_TUNE_CTRL_STATUS",
        DESC("This register contains the Clock Tuning Control status information.")
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usdhc_clk_tune_ctrl_status
    },
    {
        "VEND_SPEC",
        DESC("This register contains the vendor specific control/status register.")
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usdhc_vend_spec
    },
    {
        "MMC_BOOT",
        DESC("This register contains the MMC Fast Boot control register.")
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usdhc_mmc_boot
    },
    {
        "VEND_SPEC2",
        DESC("This register contains the vendor specific control 2 register.")
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usdhc_vend_spec2
    },
    {
        "TUNING_CTRL",
        DESC("The register contains configuration of tunning circuit.")
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_usdhc_tuning_ctrl
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark WDOG
#endif

// Bitfields in register WDOG_WCR.
static const field_t hw_wdog_wcr[] =
{
    {
        "WDZST",
        DESC("Watchdog Low Power.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDBG",
        DESC("Watchdog DEBUG Enable.")
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDE",
        DESC("Watchdog Enable.")
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDT",
        DESC("WDOG Time-out assertion.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRS",
        DESC("Software Reset Signal.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDA",
        DESC("WDOG assertion.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        DESC("adopt a new way to generate a more robust software reset.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDW",
        DESC("Watchdog Disable for Wait.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WT",
        DESC("Watchdog Time-out Field.")
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WSR.
static const field_t hw_wdog_wsr[] =
{
    {
        "WSR",
        DESC("Watchdog Service Register.")
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WRSR.
static const field_t hw_wdog_wrsr[] =
{
    {
        "SFTW",
        DESC("Software Reset.")
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TOUT",
        DESC("Timeout.")
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "POR",
        DESC("Power On Reset.")
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WICR.
static const field_t hw_wdog_wicr[] =
{
    {
        "WICT",
        DESC("Watchdog Interrupt Count Time-out (WICT) field determines, how long be"
        "fore the counter time-out must the interrupt occur.")
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTIS",
        DESC("Watchdog TImer Interrupt Status bit will reflect the timer interrupt s"
        "tatus, whether interrupt has occurred or not.")
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        DESC("Watchdog Timer Interrupt enable bit.")
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WMCR.
static const field_t hw_wdog_wmcr[] =
{
    {
        "PDE",
        DESC("Power Down Enable bit.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a WDOG module.
static const reg_t hw_wdog[] =
{
    {
        "WCR",
        DESC("The Watchdog Control Register (WDOG_WCR) controls the WDOG operation.")
        2, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_wdog_wcr
    },
    {
        "WSR",
        DESC("When enabled, the WDOG requires that a service sequence be written to "
        "the Watchdog Service Register (WSR) to prevent the timeout condition.")
        2, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wdog_wsr
    },
    {
        "WRSR",
        DESC("The WRSR is a read-only register that records the source of the output"
        " reset assertion.")
        2, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_wdog_wrsr
    },
    {
        "WICR",
        DESC("The WDOG_WICR controls the WDOG interrupt generation.")
        2, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_wdog_wicr
    },
    {
        "WMCR",
        DESC("WDOG_WMCR Controls the Power Down counter operation.")
        2, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wdog_wmcr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark XTALOSC24M
#endif

// Bitfields in register XTALOSC24M_MISC0.
static const field_t hw_xtalosc24m_misc0[] =
{
    {
        "REFTOP_PWD",
        DESC("Control bit to power-down the analog bandgap reference circuitry.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        DESC("Control bit to disable the self-bias circuit in the analog bandgap.")
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        DESC("Not related to oscillator.")
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        DESC("Status bit which signals that the analog bandgap voltage is up and sta"
        "ble.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        DESC("Configure the analog behavior in stop mode.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        DESC("This bit field determines the bias current in the 24MHz oscillator.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        DESC("Status bit which signals that the output of the 24MHz crystal oscillat"
        "or is stable.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        DESC("Enable bit for the xtal_ok module(24 MHz)")
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBCP_VPW_THRESH",
        DESC("This signal alters the voltage that the pwell is charged pumped to.")
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        DESC("This bit allows disabling the clock gate (always un-gated) for the xta"
        "l 24MHz clock that clocks the digital logic in the analog block.")
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        DESC("This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and release the clock to the digital logic inside the analog block.")
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_LPC_MISC1.
static const field_t hw_xtalosc24m_lpc_misc1[] =
{
    {
        "RC_OSC_EN",
        DESC("RC Osc.")
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        DESC("RC osc.")
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        DESC("Select the source for the 24MHz clock.")
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        DESC("Bandgap select.")
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        DESC("Low power bandgap test bit.")
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        DESC("Low power reftop ibias disable.")
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        DESC("L1 power gate control.")
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        DESC("L2 power gate control.")
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        DESC("CPU power gate control.")
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        DESC("Display logic power gate control.")
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWB_EN",
        DESC("Reverse well bias enable control.")
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        DESC("For debug purposes only.")
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        DESC("Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.")
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        DESC("Status of the 24MHz xtal oscillator.")
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a XTALOSC24M module.
static const reg_t hw_xtalosc24m[] =
{
    {
        "MISC0",
        DESC("This register defines the control and status bits for miscellaneous an"
        "alog blocks.")
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_xtalosc24m_misc0
    },
    {
        "LPC_MISC1",
        DESC("XTAL OSC miscellaneous register 1.")
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_xtalosc24m_lpc_misc1
    },
    { 0 } // Terminator
};


//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark mx6
#endif

const module_t mx6sl[] =
{
    // Module name, instance number, base address, register count, register definitions
    { "AIPSTZ1",         1, 0x02000000, 6,    hw_aipstz },
    { "AIPSTZ2",         2, 0x02100000, 6,    hw_aipstz },
    { "ARMGLOBALTIMER",  1, 0x00a00000, 7,    hw_armglobaltimer },
    { "AUDMUX",          1, 0x021d8000, 14,   hw_audmux },
    { "CCM",             1, 0x020c4000, 32,   hw_ccm },
    { "CCM_ANALOG",      1, 0x020c8000, 15,   hw_ccm_analog },
    { "CSI",             1, 0x020e4000, 13,   hw_csi },
    { "CSU",             1, 0x021c0000, 43,   hw_csu },
    { "DBGMON",          1, 0x02090000, 10,   hw_dbgmon },
    { "DCP",             1, 0x020fc000, 35,   hw_dcp },
    { "DVFSC",           1, 0x020dc000, 17,   hw_dvfsc },
    { "ECSPI1",          1, 0x02008000, 10,   hw_ecspi },
    { "ECSPI2",          2, 0x0200c000, 10,   hw_ecspi },
    { "ECSPI3",          3, 0x02010000, 10,   hw_ecspi },
    { "ECSPI4",          4, 0x02014000, 10,   hw_ecspi },
    { "EIM",             1, 0x021b8000, 41,   hw_eim },
    { "EPDC",            1, 0x020f4000, 101,  hw_epdc },
    { "EPIT1",           1, 0x020d0000, 5,    hw_epit },
    { "EPIT2",           2, 0x020d4000, 5,    hw_epit },
    { "FEC",             1, 0x02188000, 23,   hw_fec },
    { "GPC",             1, 0x020dc000, 10,   hw_gpc },
    { "GPIO1",           1, 0x0209c000, 8,    hw_gpio },
    { "GPIO2",           2, 0x020a0000, 8,    hw_gpio },
    { "GPIO3",           3, 0x020a4000, 8,    hw_gpio },
    { "GPIO4",           4, 0x020a8000, 8,    hw_gpio },
    { "GPIO5",           5, 0x020ac000, 8,    hw_gpio },
    { "GPIO6",           6, 0x020b0000, 8,    hw_gpio },
    { "GPIO7",           7, 0x020b4000, 8,    hw_gpio },
    { "GPT",             1, 0x02098000, 10,   hw_gpt },
    { "GPU2D",           1, 0x00134000, 36,   hw_gpu2d },
    { "I2C1",            1, 0x021a0000, 5,    hw_i2c },
    { "I2C2",            2, 0x021a4000, 5,    hw_i2c },
    { "I2C3",            3, 0x021a8000, 5,    hw_i2c },
    { "I2C4",            4, 0x021f8000, 5,    hw_i2c },
    { "IOMUXC",          1, 0x020e0000, 535,  hw_iomuxc },
    { "KPP",             1, 0x020b8000, 4,    hw_kpp },
    { "LCDIF",           1, 0x020f8000, 33,   hw_lcdif },
    { "MMDC",            1, 0x021b0000, 79,   hw_mmdc },
    { "OCOTP",           1, 0x021bc000, 75,   hw_ocotp },
    { "PGC",             1, 0x020dc000, 12,   hw_pgc },
    { "PMU",             1, 0x020c8000, 8,    hw_pmu },
    { "PWM1",            1, 0x02080000, 6,    hw_pwm },
    { "PWM2",            2, 0x02084000, 6,    hw_pwm },
    { "PWM3",            3, 0x02088000, 6,    hw_pwm },
    { "PWM4",            4, 0x0208c000, 6,    hw_pwm },
    { "PXP",             1, 0x020f0000, 52,   hw_pxp },
    { "QOS",             1, 0x02094000, 9,    hw_qos },
    { "RNG",             1, 0x021b4000, 6,    hw_rng },
    { "ROMC",            1, 0x021ac000, 28,   hw_romc },
    { "SDMAARM",         1, 0x020ec000, 106,  hw_sdmaarm },
    { "SDMABP",          1, 0x020ec000, 7,    hw_sdmabp },
    { "SDMACORE",        1, 0x020ec000, 21,   hw_sdmacore },
    { "SJC",             1, 0x00000000, 7,    hw_sjc },
    { "SPBA",            1, 0x0203c000, 32,   hw_spba },
    { "SPDC",            1, 0x020e8000, 18,   hw_spdc },
    { "SPDIF",           1, 0x02004000, 17,   hw_spdif },
    { "SRC",             1, 0x020d8000, 6,    hw_src },
    { "SSI1",            1, 0x02028000, 21,   hw_ssi },
    { "SSI2",            2, 0x0202c000, 21,   hw_ssi },
    { "SSI3",            3, 0x02030000, 21,   hw_ssi },
    { "TEMPMON",         1, 0x020c8000, 2,    hw_tempmon },
    { "UART1",           1, 0x02020000, 17,   hw_uart },
    { "UART2",           2, 0x021e8000, 17,   hw_uart },
    { "UART3",           3, 0x021ec000, 17,   hw_uart },
    { "UART4",           4, 0x021f0000, 17,   hw_uart },
    { "UART5",           5, 0x021f4000, 17,   hw_uart },
    { "USBC",            1, 0x02184000, 113,  hw_usbc },
    { "USBNC",           1, 0x02184000, 6,    hw_usbnc },
    { "USBPHY1",         1, 0x020c9000, 9,    hw_usbphy },
    { "USBPHY2",         2, 0x020ca000, 9,    hw_usbphy },
    { "USB_ANALOG",      1, 0x020c8000, 11,   hw_usb_analog },
    { "USDHC1",          1, 0x02190000, 29,   hw_usdhc },
    { "USDHC2",          2, 0x02194000, 29,   hw_usdhc },
    { "USDHC3",          3, 0x02198000, 29,   hw_usdhc },
    { "USDHC4",          4, 0x0219c000, 29,   hw_usdhc },
    { "WDOG1",           1, 0x020bc000, 5,    hw_wdog },
    { "WDOG2",           2, 0x020c0000, 5,    hw_wdog },
    { "XTALOSC24M",      1, 0x020c8000, 2,    hw_xtalosc24m },
    { 0 } // Terminator
};

////////////////////////////////////////////////////////////////////////////////
